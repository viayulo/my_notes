#+TITLE: Unreal Engine
#+AUTHOR: viayulo
#+EMAIL: vvvhope45@gmail.com
#+LANGUAGE: en
#+STARTUP: overview inlineimages
#+OPTIONS: num:3 p:t
#+SETUPFILE: ../theme-readtheorg.setup
#+HTML_HEAD: <style>pre.src{background:#343131;color:white;} </style>
#+HTML_HEAD: <style> #content{max-width:1800px;}</style>
#+HTML_HEAD: <style> p{max-width:800px;}</style>
#+HTML_HEAD: <style> li{max-width:800px;}</style>

* Engine Setup

** Editor Preferences

*** General

+ Appearance - User Interface - Asset Editor Open Location :: Last Docked Window or New Window

+ Keyboard Shortcuts

  - Play World (PIE/SIE) - Stop simulation :: =Shift= + =Escape=

+ Loading & Saving - Load Level at Startup :: Last Opened

+ Performance - Editor Performance :: Check "Show Frame Rate and Memory"

*** Level Editor

+ Viewports - Controls - Advanced :: Check "Use distance-scaled camera speed"

*** Privacy

+ Bug Reports :: Don't Send

+ Usage Data :: Don't Send

*** Disable Hot Reload and Reinstancing

Hot Reload and reinstancing could permanently corrupts your BPs silently

Enable Live Coding (This disables Hot Reload, which is worse)

Check =Editor Preferences > General > Live Coding > Enable Live Coding=
Uncheck =Editor Preferences > General > Live Coding > Enable Reinstancing=

Also if you want LC to not even load before a compile set it to Manual startup.
Another option you want off is =Automatically Compile Newly Added C++ Classes=.

#+begin_quote
Warning: Only use Live Coding to change function bodies (except constructor body).
#+end_quote

**** in =Config/DefaultEditorPerProjectUserSettings.ini=

#+begin_src conf
; Enable LiveCoding to disable Hot Reload
; Disable reinstancing to prevent blueprint corrupts
[/Script/LiveCoding.LiveCodingSettings]
bEnabled=True
Startup=Manual
bEnableReinstancing=False
#+end_src

*** Setup Local DDC path

+ General - Global :: set =Global Local DDC Path= to a local fast disk (default in %LocalAppData%/UnrealEngine)

** IDE

*** Visual Studio Setup

**** Install Workloads

+ Desktop development with C++
+ Game development with C++
+ C++ profiling tools
+ C++ AddressSanitizer

**** Configurations

***** Change Solution Configurations Width

Right click on the toolbar -> Customize -> =Commands= tab -> select Toolbar: Standard -> select =Solution Configurations= -> Modify Selection -> set the width to 200

***** Show Solution Platforms

Standard Toolbar drop down option -> Add or Remove Buttons

***** Disable Error List Window

Tools -> Options -> Projects and Solutions -> uncheck "Always show Error List if build finishes with errors"

***** Turn off Show Inactive Blocks

Tools -> Options -> Text Editor -> C/C++ -> View -> set "Show Inactive Blocks" to False

***** Disable External Dependencies

Tools -> Options -> Text Editor -> C/C++ -> Advanced -> set "Disable External Dependencies Folders" to True

***** Turn off Hot Reload (previously called Edit and Continue)

Tools -> Options -> Debugging -> uncheck "Enable Hot Reload"

***** Turn off Paste Indent and Format

Tools -> Options -> Text Editor -> C/C++ -> Code Style -> Formatting -> When I paste -> Do nothing

***** Disable Sign in Prompt

in =C:\Program Files\Microsoft Visual Studio\2022\Community\Common7\ServiceHub\Hosts\ServiceHub.Host.dotnet.x64=

rename =ServiceHub.IdentityHost.exe= to =ServiceHub.IdentityHost_disabled.exe=

and do NOT open =Account Settings...= from within Visual Studio

***** Turn off Visual Studio Source Control if you want

Tools -> Source Control

***** Unreal Engine Macros Formatting for C++

search “Unreal Engine” in Options or go to Tools > Options > Text Editor > C/C++ > Code Style > Formatting > Unreal Engine and check “Apply special formatting for Slate declarative syntax and Unreal Engine reflection macros.”

**** (Optional) extensions

- =Productivity Power Tool=
- =Viasfora= :: rainbow bracket
- =CodeMaid=
- =File Icons=
- =Output enhancer=
- =Trailing Whitespace Visualizer=
- =Force UTF-8 (No BOM)=
- =Indent Guides=
- =ClaudiaIDE= :: custom background
- =Trim Copy=
- =File Path On Footer=
- =Struct Layout= :: C++ struct memory layout visualization

**** Integration Configuration

***** =VisualStudioTools= Plugin

Under Engine/Plugins/Marketplace

***** =.editorconfig=

=.editorconfig= file alongside to your =.uproject= file:

[[https://raw.githubusercontent.com/microsoft/vc-ue-extensions/main/Source/.editorconfig][Content]]

***** HLSL Support

=shadertoolsconfig.json= file alongside to your =.uproject= file.

#+begin_src js
{
  "hlsl.preprocessorDefinitions": {
  },
  " hlsl.additionalIncludeDirectories": [
  ],
  "hlsl.virtualDirectoryMappings": {
  }
}
#+end_src

* *Gameplay*

** *Gameplay Framework*

Gameplay Framework facilitates the organization of logic and interaction between different entities of your game.

+ No weapon System
+ No concept of health or death

Object->Actor+Component->Level->World->WorldContext->GameInstance->Engine

*** UObject

+ GC
+ Metadata
+ Reflection
+ Serialization
+ Editable
+ Class Default Object

*** Actor & Component

+ Actor

  An entity in a level

  Usually contains ActorComponents

  + Dose *not* have a location/rotation!
    Has a RootComponent pointer instead
  + Create them using SpawnActor
    Not NewObject/ConstructObject in C++
  + Will not be Garbage Collected during gameplay

+ ActorComponent
  Re-usable functionality that can be added to an Actor

**** =AActor= : UObject

+ Replication
+ Spawn
+ Tick

#+begin_src cpp
TArray<AActor*> Children;
void Tick(float DeltaSeconds);

AActor* Owner;//(weak)
TSet<UActorComponent*> OwnedComponents;// All components of the Actor
TArray<UActorComponent*> InstanceComponents;// store components of the Actor instance
#+end_src

***** (for replication) Ownership and Relevancy

ownership is used to figure out an actor belongs to which client connection, so we can evaluate the relevancy to decide whether the actor should be replicated to certain client.

you can set Owner on spawn or runtime by ~SetOwner~

UNetConnection Owns APlayerController, and any actor can trace their ownership back to the PlayerController.

PlayerController automatically own the pawn it possessing.

****** Relevancy

Relevant actor will be replicated

by default, an actor is bAlwaysRelevant, it will be replicated to all client from server if it replicates. (e.g. GameState and PlayerState)

for most Actors, if it's owned by the player's pawn(ViewTarget) or controller(RealViewer), or if the player's pawn is the actor's instigator, the actor is considered relevant.

except for PlayerController, it is bOnlyRelevantToOwner.

actor can also inherits its owner's relevancy by bNetUseOwnerRelevancy

relevancy is decided by visibility(collision) and distance from player(NetCullDistanceSquared)

IsNetRelevantFor is a virtual function.

****** NetPriority

***** Multiplayer Spawn Actor

****** Check "Replicates" in detail panel of the actor (not component)

or ~bReplicates = true;~

- Same Actor to all client
  - lifetime synced(Spawn/Destory).
  - Properties flagged for replication will be replicated.
  - (RPC) multicast function call will called on clients.

SpawnActor(Server Only)

Destroy(Server Only)

****** Server -> Multicast(SpawnActor)

- Different Actor on clients

**** =UActorComponent= : UObject

+ For abstract behavior
+ No visual presence no location

#+begin_src cpp
void ReceiveTick(float DeltaSeconds);

AActor* OwnerPrivate;
UWorld* WorldPrivate;
#+end_src

**** =USceneComponent= : UActorComponent

+ Have transform
+ Can attach
+ Do not require visual presentation

#+begin_src cpp
USceneComponent* AttachParent;
TArray<USceneComponent*> AttachChildren;
FTransform ComponentToWorld;
FBoxSphereBounds Bounds;
#+end_src

**** =UPrimitiveComponent= : USceneComponent

+ with visual presentation

#+begin_src cpp
FLightingChannels LightingChannels;
FBodyInstance BodyInstance;
#+end_src

**** =UMeshComponent= : UPrimitiveComponent

#+begin_src cpp
TArray<class UMaterialInterface*>
#+end_src

**** =UStaticMeshComponent= : UMeshComponent

#+begin_src cpp
UStaticMesh* StaticMesh;
TArray<struct FStaticMeshComponentLODInfo> LODData;
#+end_src

**** =UChildActorComponent= : USceneComponent

***** Child Actor Template(since UE 4.14)

Modify ChildActor via blueprint or Details panel

*** Level & World

**** =ULevel= : UObject

#+begin_src cpp
TArray<AActor*> Actors;
ALevelScriptActor* LevelScriptActor;
TArray<UModelComponent*> ModelComponents;

AWorldSettings* WorldSettings;//(Actors[0])
#+end_src

**** =ALevelScriptActor= : AActor

#+begin_src cpp
uint32 bInputEnabled = 1;
#+end_src

**** =AInfo= : AActor

#+begin_src cpp
UBillboardComponent* SpriteComponent;
#+end_src

**** =AWorldSettings= : AInfo

#+begin_src cpp
TSubclassOf<class AGameMode> DefaultGameMode;
#+end_src

**** =UWorld= : UObject

#+begin_src cpp
TArray<ULevel*> Levels;
AGameMode* AuthorityGameMode;
AGameMode* GameState;
UWorldComposition* WorldComposition;
FPhysScene* PhysicsScene;

ULevel* PersistentLevel;
ULevel* CurrentLevel;
TArray<ULevelStreaming*> StreamingLevels;
UGameInstance* OwningGameInstance;
TArray<TAutoWeakObjectPtr<AController>> ControllerList;
TArray<TAutoWeakObjectPtr<APlayerController>> PlayerControllerList;
TArray<TAutoWeakObjectPtr<APawn>> PawnList;
#+end_src

#+begin_src cpp
namespace EWorldType
{
  enum Type
  {
    None,     // An untyped world, in most cases this will be the vestigial worlds of streamed in sub-levels
    Game,     // The game world
    Editor,   // A world being edited in the editor
    PIE,      // A Play In Editor world
    Preview,  // A preview world for an editor tool
    Inactive  // An editor world that was loaded but not currently being edited in the level editor
  };
}
#+end_src

**** =FWorldContext=

store context of switching between Worlds or Levels

For standalone, there is only one FWorldContext

#+begin_src cpp
UGameInstance* OwningGameInstance;
UWorld* ThisCurrentWorld;
UGameViewportClient* GameViewport;
#+end_src

***** World Context Object

There can be multiple UWorlds in an Unreal Engine game and editor. The editor for example, has one for the editor and one for play in editor window.

It is the top level object representing a map or sandbox in which actors and components will exist and be rendered.

Hence, some functions require context of which world to access. Typically something like the spawn actor from class blueprint gets the world context automatically from the actor the function was called in.

In C++ it's literally called on the UWorld object, so you already knows which one to use. (If you don't you have to get it such as =GEngine->GetWorldFromContextObject(this, EGetWorldErrorMode::ReturnNull)= and input something like an existing actor instance.

Any who there are also multiple worlds when dealing with multiplayer, each client having their own, the server having its own.

WorldContextObject can be anything with an implemented GetWorld() function. Most frequently this will be an Actor or =this=, but GetWorld() should have worked just fine.

**** =UGameInstance= : UObject

#+begin_src cpp
FWorldContext* WorldContext;
TArray<ULocalPlayer*> LocalPlayers;
UOnlineSession* OnlineSession;
#+end_src

**** =UEngine= : UObject

+ GEngine :: Global pointer to UEngine instance

#+begin_src cpp
TIndirectArray<FWorldContext> WorldList;
#+end_src

***** =UGameEngine= : UEngine

there is only one World, hence UGameEngine just store a pointer to GameInstance for convenience.

#+begin_src cpp
UGameInstance* GameInstance;
#+end_src

***** =UEditorEngine= : UEngine

EditorWorld does not owning GameInstance

GameInstance store in PlayWorld->OwningGameInstance

#+begin_src cpp
UWorld* PlayWorld;
UWorld* EditorWorld;
TArray<FEditorViewportClient*> AllViewportClients;
#+end_src

**** =UGameplayStatics= : UBlueprintFunctionLibrary

GetPlayerController, SpawActor, Openlevel

*** Pawns & Controller

+ Relationship
  A *Pawn* is an Actor that can be an "agent" within the world.
  *Pawns* can be _possessed_ by a *Controller*.
  The *Pawn* is the _physical representation_ of that agent in the game.
  The *Controller* possesses the *Pawn* and can set rules for its _behavior_.

A *Controller* can either be a *PlayerController* taking input from a human player or an *AIController* with automated control by the computer.

+ Pawn

  No movement or input code by default

  Usually handles movement input

+ Controller

  Only one Pawn at a time

  + A Controller that represents a local human player
    - *Not* an AI or remote client over network
  + Contains some useful options
    - Whether to show mouse cursor
    - Options for touch/click events
  + Good place to put things not associated with the agent
    - In-game menu
    - Voice chat

  + Control Rotation

    + have a "Control Rotation"
    + Pawns has flags to match Control Rotation
      - E.g. "Use Control Rotation Pitch"
    + CameraComponent and SpringArmComponent have similar
    + Quick to iterate on different camera modes

**** Pawn

***** =APawn= : AActor

An Actor can be *Controlled

#+begin_src cpp
TSubclassOf<AController> AIControllerClass;
uint32 bInputEnabled=1;
FVector ControlInputVector;
#+end_src

***** =ADefaultPawn= : APawn

A Pawn with _Pawn Movement Component_, _Sphere Collision Component_, _Static Mesh Component_

#+begin_src cpp
USphereComponent* CollisionComponent;
UPawnMovementComponent* MovementComponent;
#+end_src

****** =ASpectatorPawn= : ADefaultPawn

A Default Pawn with _Spectator Pawn Movement_, turn off Static Mesh, Set _collision channel_ to "Spectator"

***** =ACharacter= : APawn

A Pawn with _Character Movement Component_, _Capsule Collision Component_, _Skeleton Mesh Component_

+ Special *Pawn* that contains walking logic
+ Comes with several components
  - CapsuleComponent for collision
  - CharacterMovementComponent for movement logic
  - SkeletalMeshComponent for Visuals
  - ArrowComponent to indicate forwards (+X)
+ Automatically support networking
  - Including client side perdiction etc.
  - Improved form UE3

#+begin_src cpp
USkeletonMeshComponent* Mesh;
UCharacterMovementComponent* CharacterMovement;
UCapsuleComponent* CapsuleComponent;
#+end_src

**** Controller

***** =AController= : AActor

#+begin_src cpp
void Possess(APawn* InPawn);
void UnPossess();
void ChangeState(FName NewState);
void InitPlayerState();

APlayerState* PlayerState;
uint32 bAttachToPawn=1;
FRotator ControlRotation;
FName StateName;
TWeakObjectPtr<class AActor> StartSpot;
APawn* Pawn;
ACharacter* Character;
USceneComponent* TransformComponent;
#+end_src

***** =APlayerState= : AInfo

***** =APlayerController= : AController

#+begin_src cpp
void SetPlayer(UPlayer* InPlayer);

UPlayer* Player;
AHUD* MyHUD;
APlayerCameraManager* PlayerCameraManager;
UPlayerInput* PlayerInput;
APawn* AcknowledgedPawn;
ASpectatorPawn* SpectatorPawn;
#+end_src

***** =AAIController= : AController

#+begin_src cpp
MoveToActor(AActor* Goal,...);
MoveToLocation(const FVector& Dest,...);
bool RunBehavior(UBehaviorTree* BTAsset);
UseBlackboard(UBlackboardData* BlackboardAsset, UBlackboardComponent* BlackboardComponent)
ClaimTaskResource(TSubclassOf<UGameplayTaskResource> ResourceClass);

UBrainComponent* BrainComponent;
UAIPerceptionComponent* PerceptionComponent;
UBlackboardComponent* Blackboard;
#+end_src

*** GameMode

+ Only exists on the server in multiplayer games
  - For information clients need to know, make a GameState
+ Can access from anywhere (GetGameMode)

**** =AGameModeBase= : AInfo

#+begin_src cpp
void InitGame(const FString& MapName, const FString& Options, FString& ErrorMessage);
void InitGameState();
bool SetPause(APlayerController* PC, FCanUnpause CanUnpauseDelegate);
void ProcessServerTravel(const FString& URL, bool bAbsolute = false);
APlayerController* ProcessClientTravel(FString& URL,...);
APlayerController* Login(class UPlayer* NewPlayer,...);
void PostLogin(APlayerController* NewPlayer);

TSubclassOf<class APlayerController> PlayerControllerClass;
TSubclassOf<class ASpectatorPawn> SpectatorPawnClass;
TSubclassOf<class APlayerController> ReplaySpectatorPlayerControllerClass;
TSubclassOf<class APlayerState> PlayerStateClass;
TSubclassOf<class AGameStateBase> GameStateClass;
AGameSession* GameSession;
AGameStateBase* GameState;
uint32 bUseSeamlessTrabel:1;
uint32 bPauseable:1;
uint32 bStartPlayersAsSpectators:1;
#+end_src

***** =AGameMode= : AGameModeBase

Default multi-player implement

#+begin_src cpp
void SetMatchState(FName NewState);

FName MatchState;
TSubclassOf<class ULocalMessage> EngineMessageClass;
int32 NumSpectators;
int32 NumPlayers;
int32 NumBots;
#+end_src

**** =AGameStateBase= : AInfo

#+begin_src cpp
void AddPlayerState(class APlayerState* PlayerState);

TSubclassOf<AGameModeBase> GameModeClass;
AGameModeBase* AuthorityGameMode;
TSubclassOf<ASpectatorPawn> SpectatorClass;
TArray<class APlayerState*> PlayerArray;
#+end_src

***** =AGameState= : AGameStateBase

#+begin_src cpp
void SetMatchState(FName NewState);

FName MatchState;
FName PreviousMatchState;
#+end_src

**** =AGameSession= : AInfo

*** Player

**** =UPlayer= : UObject

#+begin_src cpp
void SwitchController(APlayerController* PC);

APlayerController* PlayerController;
int32 CurrentNetSpeed;
#+end_src

**** =ULocalPlayer= : UPlayer

#+begin_src cpp
UWorld* GetWorld();
UGameInstance* GetGameInstance() const;
bool SpawnPlayActor(const FString& URL, FString& OutError, UWorld* InWorld);
bool IsPrimaryPlayer() const;

TSharedPtr<const FUniqueNetId> CachedUniqueNetId;
UGameViewportClient* ViewportClient;
FVector2D Origin;
FVector2D Size;
FVector LastViewLocation;
TSubclassOf<class APlayerController> PendingLevelPlayerControllerClass;
int32 ControllerId;
#+end_src

**** =UNetConnection= : UPlayer

When the UNetDriver of server and client maed contact, establish UNetConnection within NetDriver.

server has multiple NetConnection each represent a player, client has only one.

has channels like =UControlChannel=, =UVoiceChannel=, =UActorChannel= for information exchange.

***** UChannel

*** GameInstance

**** =UGameInstance=

*** Subsystems

+ automatically instantiate
+ life cycle manager
+ use *soft reference* for asset to prevent initial loading stall

**** Initialize Dependence (for same level subsystems)

Call =InitializeDependency()= from =FSubsystemCollectionBase=.

#+begin_src cpp
void UMySubsystem1::Initialize(FSubsystemCollectionBase& Collection)
{
    // Initialize UMySubsystem2 first if not initialized
    Collection.InitializeDependency(UMySubsystem2::StaticClass());

    auto _MySubsystem2 = GetGameInstance()->GetSubsystem<UMySubsystem2>();
    if(_MySubsystem2){
        // Processing UMySubsystem2
    }
}
#+end_src

**** =USubsystem= : UObject

**** =UGameInstanceSubsystem= : USubsystem

**** =UWorldSubsystem= : USubsystem

**** =ULocalPlayerSubsystem= : USubsystem

Due to =UCLASS(Within = LocalPlayer)=, =ULocalPlayerSubsystem= cannot be accessed outside local player (e.g. dedicated servers have no local player), access via PlayerController.

**** =UDynamicSubsystem= : USubsystem

**** =UEditorSubsystem= : UDynamicSubsystem

***** Build.cs

#+begin_src c
if (Target.bBuildEditor)
{
    PublicDependencyModuleNames.AddRange(new string[] { "EditorSubsystem" });
}
#+end_src

**** =UEngineSubsystem= : UDynamicSubsystem

**** E.g.

***** Definition

#+begin_src cpp
UCLASS()
class HELLO_API UMyScoreSubsystem: public UGameInstanceSubsystem
{
    GENERATED_BODY()
public:
    virtual bool ShouldCreateSubsystem(UObject* Outer) const override { return true; }
    virtual void Initialize(FSubsystemCollectionBase& Collection) override;
    virtual void Deinitialize() override;
public:
    UFUNCTION(BlueprintCallable)
    void AddScore(float delta);
public:
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    float Score;
}
#+end_src

***** Access subsystem

+ EngineSubsystem
  #+begin_src cpp
  UMyEngineSubsystem* MySubSystem = GEngine->GetEngineSubsystem<UMyEngineSubsystem>();
  #+end_src

+ EditorSubsystem
  #+begin_src cpp
  UMyEditorSubsystem* MySubSystem = GEditor->GetEditorSubsystem<UMyEditorSubsystem>();
  #+end_src

+ GameInstanceSubsystem
  #+begin_src cpp
  UGameInstance* GameInstance = UGameplayStatics::GetGameInstance(...);
  UMyGameInstanceSubsystem* MySubsystem = GameInstance->GetSubsystem<UMyGameInstanceSubsystem>();
  #+end_src

+ WorldSubsystem
  #+begin_src cpp
  UWorld* World = MyActor->GetWorld();// Or any other way to get world
  UMyWorldSubsystem* MySubsystem = World->GetSubsystem<UMyWorldSubsystem>();
  #+end_src

+ LocalPlayerSubsystem
  #+begin_src cpp
  ULocalPlayer* LocalPlayer = Cast<ULocalPlayer>(PlayerController->Player);
  UMyLocalPlayerSubsystem* MySubsystem = LocalPlayer->GetSubsystem<UMyLocalPlayerSubsystem>();
  #+end_src

**** =FSubsystemCollectionBase= : FGCObject

***** =FSubsystemCollection= : FSubsystemCollectionBase

*** Camera

**** =FTViewTarget=

A ViewTarget is the primary actor the camera is associated with.

Responsible for providing the PlayerCameraManager with an ideal _Point of View_ (POV).

#+begin_src cpp
public:

    /** Target Actor used to compute POV */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=TViewTarget)
    TObjectPtr<class AActor> Target;

    /** Computed point of view */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=TViewTarget)
    struct FMinimalViewInfo POV;

protected:
    /** PlayerState (used to follow same player through pawn transitions, etc., when spectating) */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=TViewTarget)
    TObjectPtr<class APlayerState> PlayerState;
#+end_src

***** =FMinimalViewInfo=

**** =APlayerCameraManager= : AActor

Calculate point of view, apply camera modifiers.

**** =UCameraComponent= : USceneComponent

Represents a camera viewpoint and settings, such as POV, FOV, projection type, and post-process overrides.
=GetCameraView()=

**** =ACameraActor= : AActor

An Actor with CameraComponent that can be placed in a level.

**** Camera Responsibility Chain

#+ATTR_HTML: width="900px"
#+ATTR_ORG: :width 900
[[file:./images/camera_responsibility_chain.webp]]

**** Point of View update sequence

=APlayerController::UpdateCameraManager()= called after all actors have been ticked, =APlayerCameraManager::UpdateCamera(float DeltaTime)= performs per-tick camera update.

=APlayerCameraManager::FillCameraCache(const FMinimalViewInfo& NewInfo)= called in =APlayerCameraManager::DoUpdateCamera(float DeltaTime)= to caches given final POV info for efficient access from other game code.

=APlayerCameraManager::UpdateViewTarget(FTViewTarget& OutVT, float DeltaTime)= calculates an updated POV for the given ViewTarget, apply camera modifiers at the end (view shakes for example), synchronize the actor (=SetActorLocationAndRotation(OutVT.POV.Location, OutVT.POV.Rotation, false);=) with the view target results.

**** Two approach to setup camera

***** Add CameraComponent to target actor

***** Use ViewTarget and offset to calculate POV (in PlayerCameraManager)

Override =APlayerCameraManager::UpdateViewTarget(FTViewTarget& OutVT, float DeltaTime)=

*** ModularGameplay (Plugin)

**** =UGameFrameworkComponent= : UActorComponent

**** =UControllerComponent= : UGameFrameworkComponent

**** =UGameStateComponent= : UGameFrameworkComponent

**** =UPawnComponent= : UGameFrameworkComponent

**** =UPlayerStateComponent= : UGameFrameworkComponent

** Gameplay Tags

*** Native Gameplay Tags

[[https://www.thegames.dev/?p=106][Native Gameplay Tags (New in 4.27 and UE5)]]

+ header
  #+begin_src cpp
  #pragma once

  #include "NativeGameplayTags.h"

  namespace MyNativeTags
  {
      // Declare all of the custom native tags that game will use.
      MYMODULE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(MyTag_Foo);
      MYMODULE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(MyTag_Bar);
  }
  #+end_src

+ .cpp

  #+begin_src cpp
  namespace MyNativeTags
  {
      UE_DEFINE_GAMEPLAY_TAG(MyTag_Foo, "MyTag.Foo");
      UE_DEFINE_GAMEPLAY_TAG_COMMENT(MyTag_Bar, "MyTag.Bar", "Comment here.");
  }
  #+end_src

+ How to use

  #+begin_src cpp
  #include "MyNativeTags.h"

  HasTag(MyNativeTags::MyTag_Foo);
  #+end_src

*** Adding and using Gameplay Tags in C++

[[https://www.thegames.dev/?p=78][Adding and using Gameplay Tags in C++]]

#+begin_quote
About pass value

const FGameplayTag = will be copied no matter what, don't use this
const FGameplayTag&/FGameplayTag = compiler will just move the existing object if it can
#+end_quote

*** IGameplayTagAssetInterface

Interface for assets which contain gameplay tags.

**** Tags on AbilitySystemComponent

***** header

#+begin_src cpp
#include "GameplayTagAssetInterface.h"

struct FGameplayTag;
struct FGameplayTagContainer;

class AMyActor : /*...*/, public IGameplayTagAssetInterface
{
    // ...

public:

    //~IGameplayTagAssetInterface interface
    virtual void GetOwnedGameplayTags(FGameplayTagContainer& TagContainer) const override;
    virtual bool HasMatchingGameplayTag(FGameplayTag TagToCheck) const override;
    virtual bool HasAllMatchingGameplayTags(const FGameplayTagContainer& TagContainer) const override;
    virtual bool HasAnyMatchingGameplayTags(const FGameplayTagContainer& TagContainer) const override;
    //~End of IGameplayTagAssetInterface interface

}
#+end_src

***** cpp

#+begin_src cpp
void AMyActor::GetOwnedGameplayTags(FGameplayTagContainer& TagContainer) const
{
    if (const UAbilitySystemComponent* ASC = GetAbilitySystemComponent())
    {
        ASC->GetOwnedGameplayTags(TagContainer);
    }
}

bool AMyActor::HasMatchingGameplayTag(FGameplayTag TagToCheck) const
{
    if (const UAbilitySystemComponent* ASC = GetAbilitySystemComponent())
    {
        return ASC->HasMatchingGameplayTag(TagToCheck);
    }

    return false;
}

bool AMyActor::HasAllMatchingGameplayTags(const FGameplayTagContainer& TagContainer) const
{
    if (const UAbilitySystemComponent* ASC = GetAbilitySystemComponent())
    {
        return ASC->HasAllMatchingGameplayTags(TagContainer);
    }

    return false;
}

bool AMyActor::HasAnyMatchingGameplayTags(const FGameplayTagContainer& TagContainer) const
{
    if (const UAbilitySystemComponent* ASC = GetAbilitySystemComponent())
    {
        return ASC->HasAnyMatchingGameplayTags(TagContainer);
    }

    return false;
}
#+end_src

**** Tags on object self

***** header

#+begin_src cpp
#include "GameplayTagAssetInterface.h"
#include "GameplayTagContainer.h"

class UMyObject : /*...*/, public IGameplayTagAssetInterface
{
    // ...

public:

    //~IGameplayTagAssetInterface
    virtual void GetOwnedGameplayTags(FGameplayTagContainer& TagContainer) const override;
    //~End of IGameplayTagAssetInterface

protected:

    // Gameplay-related tags associated with this object
    UPROPERTY(EditAnywhere, BlueprintReadOnly)
    FGameplayTagContainer StaticGameplayTags;
}
#+end_src

***** cpp

#+begin_src cpp
void UMyObject::GetOwnedGameplayTags(FGameplayTagContainer& TagContainer) const
{
    TagContainer.AppendTags(StaticGameplayTags);
}
#+end_src

*** Add CustomTag.ini to Plugin

You can add tag .ini file to custom plugin just like what game module does, but I highly recommend native gameplay tags over these.

**** Add .ini file to [PluginFolder]/Config/Tags/

#+begin_src conf
[/Script/GameplayTags.GameplayTagsList]
GameplayTagList=(Tag="FooBar",DevComment="")
#+end_src

**** Adding =GameplayTags= to the =PublicDependencyModuleNames= in [PluginFolder]/Source/MyPlugin/MyPlugin.Build.cs

#+begin_src csharp
PublicDependencyModuleNames.AddRange(
    new string[]
    {
        "Core",
        "GameplayTags",
        // ... add other public dependencies that you statically link with here ...
    }
);
#+end_src

**** Editing the =StartupModule()= function in [PluginFolder]/Source/MyPlugin/Private/MyPluginModule.cpp

#+begin_src cpp
#include "GameplayTagsManager.h"
#include "Misc/Paths.h"
#include "Modules/ModuleManager.h"

class FMyPluginModule : public IModuleInterface
{
public:
  /** IModuleInterface implementation */
  virtual void StartupModule() override;
  virtual void ShutdownModule() override;
};

void FMyPluginModule::StartupModule()
{
  UGameplayTagsManager::Get().AddTagIniSearchPath(FPaths::ProjectPluginsDir() / TEXT("MyPlugin/Config/Tags"));
}

void FMyPluginModule::ShutdownModule()
{
}

IMPLEMENT_MODULE(FMyPluginModule, MyPlugin)
#+end_src

** *Gameplay Abilities System (GAS)*

A highly flexible framework for building the types of abilities and attributes that you might find in an RPG or MOBA title.

*** Benefits and Pitfalls

*** Features

+ Skills
  Consumption
  Cooldown
+ Handle attribute (HP、MP、Attack、Defend)
+ Apply state effect (Knockup、on fire、stun)
+ Apply GameplayTags
+ Generate VFX and SFX
+ Network replication, prediction
+ damage type
+ player battle state

*** Applicable Project

+ C++ Project
+ Multiplayer game using Dedicated Server
+ Plenty complex skill logic

*** Concepts

**** TargetData

**** Meta Attributes

*** Ability System Component(ASC) =UAbilitySystemComponent= : =UGameplayTasksComponent=

Core

Recommended using =PlayerState= as OwnerActor

**** GameplayAbility(GA) =UGameplayAbility=

Ability, logic

NOT for basic movement, ray trace, UI

Call from Class Default Object(CDO) or use Instance to store value

***** =FGameplayAbilitySpec=

#+begin_src cpp
UGameplayAbility* Ability;
int32 Level;
FGameplayAbilityActivationInfo ActivationInfo;
#+end_src

Level will pass to GameplayEffect

**** GameplayEffect(GE) =UGameplayEffect=

Apply ability effect

(Pure config Blueprint)
(Only use GE to modify Attribute)

Data "Template" for FGameplayEffectSpec

+ FGameplayModifierInfo
+ FGameplayEffectCue

***** =FGameplayEffectSpec=

#+begin_src cpp
const UGameplayEffect* Def;
float Level;
#+end_src

"Instance" after every time UGameplayAbility =Apply= UGameplayEffect

Can change value depend on Level

***** =FActiveGameplayEffect=

**** GameplayCue(GC) =UGameplayCueNotify=

FX

***** Trigger

+ UGameplayAbility -> Execute/Add
+ UGameplayEffect
+ Global Tag-Handler Map
  GameplayCueEditor

***** Static Cue =UGameplayCueNotify_Static=

Trigger once
Class Default Object(CDO)

***** Actor Cue =AGameplayCueNotify_Actor=

Continuous
Spawn

**** GameplayAttribute =FGameplayAttribute=

Attribute
(Only use GE to modify Attribute)

#+begin_src cpp
FString AttributeName;
UStruct* AttributeOwner;
TFieldPath<FProperty> Attribute;
#+end_src

***** =FGameplayAttributeData=

#+begin_src cpp
float BaseValue;
float CurrentValue;
#+end_src

+ BaseValue
+ CurrentValue
  for temporary value change like buff
  can return to Basevalue after GE end

***** =UAttributeSet=

**** GameplayTag =FGameplayTag=

Tag system
X.Y.Z FName

#+begin_src cpp
FName TagName;
#+end_src

***** =FGameplayTagContainer=

#+begin_src cpp
TArray<FGameplayTag> GameplayTags;
#+end_src

***** =FGameplayTagQuery=

#+begin_src cpp
TArray<FGameplayTag> TagDictionary;
#+end_src

***** =FGameplayTagNode=

#+begin_src cpp
FName TagName;
FGameplayTagNode* ParentNode;
TArray<FGameplayTagNode*> ChildTags;
#+end_src

***** =UGameplayTagsManager=

store tree

#+begin_src cpp
TSharedPtr<FGameplayTagNode> GameplayRootTag;
#+end_src

**** GameplayTask =UGameplayTask=

Async task
(can run without GAS)

***** =UGameplayTasksComponent=

***** =UAbilityTask:UGameplayTask=

#+begin_src cpp
UGameplayAbility* Ability;
#+end_src

**** Event =FGameplayEventData=

register callbacks to ASC, call when =Send=
Map with Tag
payload data

*** Gameplay Effect

**** UIData

**** set by Caller

*** Implement

**** OwnerActor & AvatarActor

PlayerState (OwnerActor)
Pawn (AvatarActor)

**** GameplayTags

Project Settings -> GameplayTags

**** GameplayAbility

behavior, ability
Eg. Can or cannot be knockup, knockdown，use specific item

**** GameplayEffect

+ Blueprint
+ Configurable data table (in Details panel)，not to add logic
+ Damage evaluate
+ Add buff (Change GameplayTags)

**** AttributeSet

+ Define attributes
+ Manage attribute changes
+ Network Replicate

***** Character

Need be added as variable to Actor，and register to ASC

+ AGASSampleCharacter.h
  #+begin_src cpp
  public:
      UPROPERTY()
      USampleAttributeSet* AttributeSet;
  #+end_src

+ AGASSampleCharacter.cpp
  #+begin_src cpp
  AGASSampleCharacter::AGASSampleCharacter()
  {
      // Instantiate ASC
      AbilitySystem = CreateDefaultSubobject<UAbilitySystemComponent>(TEXT("AbilitySystem"));

      // AttributeSet created in OwnerActor constructer will automatically register to ASC
      AttributeSet = CreateDefaultSubobject<USampleAttributeSet>(TEXT("AttributeSet"));
  }
  #+end_src

***** AttributeSet

+ SampleAttributeSet.h
  #+begin_src cpp
  #pragma once

  #include "CoreMinimal.h"
  #include "AttributeSet.h"
  #include "AbilitySystemComponent.h"
  #include "Net/UnrealNetwork.h"
  #include "GameplayEffectExtension.h"
  #include "SampleAttributeSet.generated.h"

  // Define macro that add getter and setter functions
  #define ATTRIBUTE_ACCESSORS(ClassName, PropertyName) \
      GAMEPLAYATTRIBUTE_PROPERTY_GETTER(ClassName, PropertyName) \
      GAMEPLAYATTRIBUTE_VALUE_GETTER(PropertyName) \
      GAMEPLAYATTRIBUTE_VALUE_SETTER(PropertyName) \
      GAMEPLAYATTRIBUTE_VALUE_INITTER(PropertyName)

  UCLASS()
  class GASSAMPLE_API USampleAttributeSet : public UAttributeSet
  {
      GENERATED_BODY()
  public:
      USampleAttributeSet();

      virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;

  public:
      UPROPERTY(BlueprintReadOnly, Category = "Health", ReplicatedUsing = OnRep_Health)
      FGameplayAttributeData Health;
      ATTRIBUTE_ACCESSORS(USampleAttributeSet, Health);
      UFUNCTION()
      void OnRep_Health(const FGameplayAttributeData& OldValue);

      UPROPERTY(BlueprintReadOnly, Category = "Health", ReplicatedUsing = OnRep_MaxHealth)
      FGameplayAttributeData MaxHealth;
      ATTRIBUTE_ACCESSORS(USampleAttributeSet, MaxHealth);
      UFUNCTION()
      void OnRep_MaxHealth(const FGameplayAttributeData& OldValue);

      UPROPERTY(BlueprintReadOnly, Category = "Physical", ReplicatedUsing = OnRep_Physical)
      FGameplayAttributeData Physical;
      ATTRIBUTE_ACCESSORS(USampleAttributeSet, Physical);
      UFUNCTION()
      void OnRep_Physical(const FGameplayAttributeData& OldValue);

      UPROPERTY(BlueprintReadOnly, Category = "Physical", ReplicatedUsing = OnRep_MaxPhysical)
      FGameplayAttributeData MaxPhysical;
      ATTRIBUTE_ACCESSORS(USampleAttributeSet, MaxPhysical);
      UFUNCTION()
      void OnRep_MaxPhysical(const FGameplayAttributeData& OldValue);

  public:
      // Callback before attribute change
      virtual void PreAttributeChange(const FGameplayAttribute& Attribute, float& NewValue);

      // Callback after GE execute
      virtual void PostGameplayEffectExecute(const FGameplayEffectModCallbackData& Data) override;
  }
  #+end_src

*** Workflow

**** Enable Plugin

Enable "Gameplay Abilities" "GameplayTagsEditor"

**** Register Plugin

+ Build.cs
  #+begin_src cpp
  PublicDependencyModuleNames.AddRange(new string[] { "core", "CoreUObject", "Engine",
      "GameplayAbilities",// Register plugin
      "GameplayTags", "GameplayTasks"// To customize Task
  });
  #+end_src

+ Character.h
#+begin_src cpp
#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Character.h"

// Add header files
#include "AbilitySystemInterface.h"
#include "AbilitySystemComponent.h"
#include "SampleAttributeSet.h"

#include "GASSampleCharacter.generated.h"

UCLASS(config=Game)
class AGASSampleCharacter : public ACharacter,
    public IAbilitySystemInterface // Inherit AbilitySystem Interface
{
    GENERATED_BODY()

public:
    // Declare ASC
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = GameplayAbilities, meta = (AllowPrivateAccess = "true"))
    class UAbilitySystemComponent* AbilitySystem;

    // Implement interface method
    virtual UAbilitySystemComponent* GetAbilitySystemComponent() const override;

    // Declare an Ability array
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Abilities)
    TArray<TSubclassOf<UGameplayAbility>> MyAbilities;

    UPROPERTY()
    USampleAttributeSet* AttributeSet;

}
#+end_src

+ Character.cpp
#+begin_src cpp
UAbilitySystemComponent* AGASSampleCharacter::GetAbilitySystemComponent() const
{
    return AbilitySystem;
}

AGASSampleCharacter::AGASSampleCharacter()
{

    // Instantiate ASC
    AbilitySystem = CreateDefaultSubobject<UAbilitySystemComponent>(TEXT("AbilitySystem"));

    // AttributeSet created in OwnerActor constructer will automatically register to ASC
    AttributeSet = CreateDefaultSubobject<USampleAttributeSet>(TEXT("AttributeSet"));
}

AGASSampleCharacter::BeginPlay()
{
    Super::BeginPlay();

    if (AbilitySystem != nullptr)
    {
        // Grant Abilities to ASC
        if (HasAuthority() && MyAbilities.Num() > 0)
        {
            for (auto i = 0; i < MyAbilities.Num(); i++)
            {
                if (MyAbilities[i] == nullptr)
                {
                    continue;
                }
                AbilitySystem->GiveAbility(FGameplayAbilitySpec(MyAbilities[i].GetDefaultObject(), 1, 0));
            }
        }

        // Initialize ASC
        AbilitySystem->InitAbilityActorInfo(this, this);
    }
}
#+end_src

*** Ability Set

*** Ability Tag Relationship Mapping

#+BEGIN_QUOTE
Gameplay Tag Relationships

Kaos Spectrum

When dealing with a lot of abilities, the block and cancel tags can get confusing and hard to keep managed. By using a relationship, we can apply block, cancel and activation tags from a more central location. This allows us to define what ability tags block and cancels what abilities.
#+END_QUOTE

**** AbilityTagRelationshipMapping.h

#+BEGIN_QUOTE
Lets create a new class, which is going to be a DataAsset, and populate it with the required fields
#+END_QUOTE

#+begin_src cpp
#pragma once

#include "CoreMinimal.h"
#include "GameplayTagContainer.h"
#include "Engine/DataAsset.h"
#include "AbilityTagRelationshipMapping.generated.h"

/** Struct that defines the relationship between different ability tags */
USTRUCT()
struct ABILITYSYSTEMUTILITY_API FAbilityTagRelationship
{
    GENERATED_BODY()

    /** The tag that this container relationship is about. Single tag, but abilities can have multiple of these */
    UPROPERTY(EditAnywhere, Category = Ability, meta = (Categories = "Gameplay.Action"))
    FGameplayTag AbilityTag;

    /** The other ability tags that will be blocked by any ability using this tag */
    UPROPERTY(EditAnywhere, Category = Ability)
    FGameplayTagContainer AbilityTagsToBlock;

    /** The other ability tags that will be canceled by any ability using this tag */
    UPROPERTY(EditAnywhere, Category = Ability)
    FGameplayTagContainer AbilityTagsToCancel;

    /** If an ability has the tag, this is implicitly added to the activation required tags of the ability */
    UPROPERTY(EditAnywhere, Category = Ability)
    FGameplayTagContainer ActivationRequiredTags;

    /** If an ability has the tag, this is implicitly added to the activation blocked tags of the ability */
    UPROPERTY(EditAnywhere, Category = Ability)
    FGameplayTagContainer ActivationBlockedTags;
};


/** Mapping of how ability tags block or cancel other abilities */
UCLASS()
class ABILITYSYSTEMUTILITY_API UAbilityTagRelationshipMapping : public UDataAsset
{
    GENERATED_BODY()

private:
    /** The list of relationships between different gameplay tags (which ones block or cancel others) */
    UPROPERTY(EditAnywhere, Category = Ability, meta=(TitleProperty="AbilityTag"))
    TArray<FAbilityTagRelationship> AbilityTagRelationships;

public:
    /** Given a set of ability tags, parse the tag relationship and fill out tags to block and cancel */
    void GetAbilityTagsToBlockAndCancel(const FGameplayTagContainer& AbilityTags, FGameplayTagContainer* OutTagsToBlock, FGameplayTagContainer* OutTagsToCancel) const;

    /** Given a set of ability tags, add additional required and blocking tags */
    void GetRequiredAndBlockedActivationTags(const FGameplayTagContainer& AbilityTags, FGameplayTagContainer* OutActivationRequired, FGameplayTagContainer* OutActivationBlocked) const;

    /** Returns true if the specified ability tags are canceled by the passed in action tag */
    bool IsAbilityCancelledByTag(const FGameplayTagContainer& AbilityTags, const FGameplayTag& ActionTag) const;
};
#+end_src

**** AbilityTagRelationshipMapping.cpp

#+begin_src cpp
#include "AbilityTagRelationshipMapping.h"

void UAbilityTagRelationshipMapping::GetAbilityTagsToBlockAndCancel(const FGameplayTagContainer& AbilityTags, FGameplayTagContainer* OutTagsToBlock, FGameplayTagContainer* OutTagsToCancel) const
{
    // Simple iteration for now
    for (int32 i = 0; i < AbilityTagRelationships.Num(); i++)
    {
        const FAbilityTagRelationship& Tags = AbilityTagRelationships[i];
        if (AbilityTags.HasTag(Tags.AbilityTag))
        {
            if (OutTagsToBlock)
            {
                OutTagsToBlock->AppendTags(Tags.AbilityTagsToBlock);
            }
            if (OutTagsToCancel)
            {
                OutTagsToCancel->AppendTags(Tags.AbilityTagsToCancel);
            }
        }
    }
}

void UAbilityTagRelationshipMapping::GetRequiredAndBlockedActivationTags(const FGameplayTagContainer& AbilityTags, FGameplayTagContainer* OutActivationRequired, FGameplayTagContainer* OutActivationBlocked) const
{
    // Simple iteration for now
    for (int32 i = 0; i < AbilityTagRelationships.Num(); i++)
    {
        const FAbilityTagRelationship& Tags = AbilityTagRelationships[i];
        if (AbilityTags.HasTag(Tags.AbilityTag))
        {
            if (OutActivationRequired)
            {
                OutActivationRequired->AppendTags(Tags.ActivationRequiredTags);
            }
            if (OutActivationBlocked)
            {
                OutActivationBlocked->AppendTags(Tags.ActivationBlockedTags);
            }
        }
    }
}

bool UAbilityTagRelationshipMapping::IsAbilityCancelledByTag(const FGameplayTagContainer& AbilityTags, const FGameplayTag& ActionTag) const
{
    // Simple iteration for now
    for (int32 i = 0; i < AbilityTagRelationships.Num(); i++)
    {
        const FAbilityTagRelationship& Tags = AbilityTagRelationships[i];

        if (Tags.AbilityTag == ActionTag && Tags.AbilityTagsToCancel.HasAny(AbilityTags))
        {
            return true;
        }
    }

    return false;
}
#+end_src

#+BEGIN_QUOTE
Now we need to add a couple of things to the Ability System Component so we can make use of these relationships
#+END_QUOTE

**** MyAbilitySystemComponent.h

#+BEGIN_QUOTE
Add the following to your custom ASC
#+END_QUOTE

#+begin_src cpp
#pragma region TagRelationship

public:

    // Sets the current tag relationship mapping, if null it will clear it out
    void SetTagRelationshipMapping(UAbilityTagRelationshipMapping* NewMapping);

    // Looks at ability tags and gathers additional required and blocking tags
    void GetAdditionalActivationTagRequirements(const FGameplayTagContainer& AbilityTags, FGameplayTagContainer& OutActivationRequired, FGameplayTagContainer& OutActivationBlocked) const;

protected:

    //~UAbilitySystemComponent interface
    virtual void ApplyAbilityBlockAndCancelTags(const FGameplayTagContainer& AbilityTags, UGameplayAbility* RequestingAbility, bool bEnableBlockTags, const FGameplayTagContainer& BlockTags, bool bExecuteCancelTags, const FGameplayTagContainer& CancelTags) override;
    virtual void HandleChangeAbilityCanBeCanceled(const FGameplayTagContainer& AbilityTags, UGameplayAbility* RequestingAbility, bool bCanBeCanceled) override;
    //~End of UAbilitySystemComponent interface

    // If set, this table is used to look up tag relationships for activate and cancel
    UPROPERTY(EditDefaultsOnly, Category = "Abilities|GameplayTags")
    TObjectPtr<class UAbilityTagRelationshipMapping> TagRelationshipMapping;

#pragma endregion TagRelationship
#+end_src

**** MyAbilitySystemComponent.cpp

#+begin_src cpp
#pragma region TagRelationship

void UGFAbilitySystemComponent::SetTagRelationshipMapping(UAbilityTagRelationshipMapping* NewMapping)
{
    TagRelationshipMapping = NewMapping;
}

void UGFAbilitySystemComponent::GetAdditionalActivationTagRequirements(const FGameplayTagContainer& AbilityTags, FGameplayTagContainer& OutActivationRequired, FGameplayTagContainer& OutActivationBlocked) const
{
    if (TagRelationshipMapping)
    {
        TagRelationshipMapping->GetRequiredAndBlockedActivationTags(AbilityTags, &OutActivationRequired, &OutActivationBlocked);
    }
}

void UGFAbilitySystemComponent::ApplyAbilityBlockAndCancelTags(const FGameplayTagContainer& AbilityTags, UGameplayAbility* RequestingAbility, bool bEnableBlockTags, const FGameplayTagContainer& BlockTags, bool bExecuteCancelTags, const FGameplayTagContainer& CancelTags)
{
    FGameplayTagContainer ModifiedBlockTags = BlockTags;
    FGameplayTagContainer ModifiedCancelTags = CancelTags;

    if (TagRelationshipMapping)
    {
        // Use the mapping to expand the ability tags into block and cancel tag
        TagRelationshipMapping->GetAbilityTagsToBlockAndCancel(AbilityTags, &ModifiedBlockTags, &ModifiedCancelTags);
    }

    Super::ApplyAbilityBlockAndCancelTags(AbilityTags, RequestingAbility, bEnableBlockTags, ModifiedBlockTags, bExecuteCancelTags, ModifiedCancelTags);

    //@TODO: Apply any special logic like blocking input or movement
}

void UGFAbilitySystemComponent::HandleChangeAbilityCanBeCanceled(const FGameplayTagContainer& AbilityTags, UGameplayAbility* RequestingAbility, bool bCanBeCanceled)
{
    Super::HandleChangeAbilityCanBeCanceled(AbilityTags, RequestingAbility, bCanBeCanceled);

    //@TODO: Apply any special logic like blocking input or movement
}

#pragma endregion TagRelationship
#+end_src

#+BEGIN_QUOTE
Now the block and cancel tags will work, but we need to do some stuff in your custom Gameplay Ability to handle the Activation Required and Activation Blocked tags.
#+END_QUOTE

**** MyGameplayAbility.h

#+BEGIN_QUOTE
Lets override the following function in your custom Gameplay Ability class
#+END_QUOTE

#+begin_src cpp
#pragma region TagRelationship

protected:

    //~UGameplayAbility interface
    virtual bool DoesAbilitySatisfyTagRequirements(const UAbilitySystemComponent& AbilitySystemComponent, const FGameplayTagContainer* SourceTags, const FGameplayTagContainer* TargetTags, OUT FGameplayTagContainer* OptionalRelevantTags) const override;
    //~End of UGameplayAbility interface

#pragma endregion TagRelationship
#+end_src

**** MyGameplayAbility.cpp

#+BEGIN_QUOTE
and implement the function like this (this is a hard override of the default GameplayAbility function
#+END_QUOTE

#+begin_src cpp
#include "AbilitySystem/MyAbilitySystemComponent.h"
#include "GameplayTagContainer.h"
#include "AbilitySystemGlobals.h"

#pragma region TagRelationship

bool UGFGameplayAbility::DoesAbilitySatisfyTagRequirements(const UAbilitySystemComponent& AbilitySystemComponent, const FGameplayTagContainer* SourceTags, const FGameplayTagContainer* TargetTags, OUT FGameplayTagContainer* OptionalRelevantTags) const
{
    // Specialized version to handle death exclusion and AbilityTags expansion via ASC

    bool bBlocked = false;
    bool bMissing = false;

    UAbilitySystemGlobals& AbilitySystemGlobals = UAbilitySystemGlobals::Get();
    const FGameplayTag& BlockedTag = AbilitySystemGlobals.ActivateFailTagsBlockedTag;
    const FGameplayTag& MissingTag = AbilitySystemGlobals.ActivateFailTagsMissingTag;

    // Check if any of this ability's tags are currently blocked
    if (AbilitySystemComponent.AreAbilityTagsBlocked(AbilityTags))
    {
        bBlocked = true;
    }

    const UMyAbilitySystemComponent* MyASC = Cast<UMyAbilitySystemComponent>(&AbilitySystemComponent);
    static FGameplayTagContainer AllRequiredTags;
    static FGameplayTagContainer AllBlockedTags;

    AllRequiredTags = ActivationRequiredTags;
    AllBlockedTags = ActivationBlockedTags;

    // Expand our ability tags to add additional required/blocked tags
    if (MyASC)
    {
        MyASC->GetAdditionalActivationTagRequirements(AbilityTags, AllRequiredTags, AllBlockedTags);
    }

    // Check to see the required/blocked tags for this ability
    if (AllBlockedTags.Num() || AllRequiredTags.Num())
    {
        static FGameplayTagContainer AbilitySystemComponentTags;

        AbilitySystemComponentTags.Reset();
        AbilitySystemComponent.GetOwnedGameplayTags(AbilitySystemComponentTags);

        if (AbilitySystemComponentTags.HasAny(AllBlockedTags))
        {
            bBlocked = true;
        }

        if (!AbilitySystemComponentTags.HasAll(AllRequiredTags))
        {
            bMissing = true;
        }
    }

    if (SourceTags != nullptr)
    {
        if (SourceBlockedTags.Num() || SourceRequiredTags.Num())
        {
            if (SourceTags->HasAny(SourceBlockedTags))
            {
                bBlocked = true;
            }

            if (!SourceTags->HasAll(SourceRequiredTags))
            {
                bMissing = true;
            }
        }
    }

    if (TargetTags != nullptr)
    {
        if (TargetBlockedTags.Num() || TargetRequiredTags.Num())
        {
            if (TargetTags->HasAny(TargetBlockedTags))
            {
                bBlocked = true;
            }

            if (!TargetTags->HasAll(TargetRequiredTags))
            {
                bMissing = true;
            }
        }
    }

    if (bBlocked)
    {
        if (OptionalRelevantTags && BlockedTag.IsValid())
        {
            OptionalRelevantTags->AddTag(BlockedTag);
        }
        return false;
    }
    if (bMissing)
    {
        if (OptionalRelevantTags && MissingTag.IsValid())
        {
            OptionalRelevantTags->AddTag(MissingTag);
        }
        return false;
    }

    return true;
}

#pragma endregion TagRelationship
#+end_src

*** Ability Fail Tag

AbilitySystemGlobal

DefaultGame.ini

** Gameplay Camera

** Mover

General Physics

** Gameplay Debugger Tool (GDT)

*** Add GameplayDebuggerCategory

in Private/Debug/

#+begin_src cpp
#pragma once

#if WITH_GAMEPLAY_DEBUGGER

#include "CoreMinimal.h"
#include "GameplayDebuggerCategory.h"

// System for adding Equipment-related debugging info and visualization to the Gameplay Debugger tool
class FGameplayDebuggerCategory_Equipment : public FGameplayDebuggerCategory
{
public:
    FGameplayDebuggerCategory_Equipment();

    virtual void CollectData(APlayerController* OwnerPC, AActor* DebugActor) override;
    virtual void DrawData(APlayerController* OwnerPC, FGameplayDebuggerCanvasContext& CanvasContext) override;

    static TSharedRef<FGameplayDebuggerCategory> MakeInstance();

protected:
    void DrawOverheadInfo(AActor& DebugActor, FGameplayDebuggerCanvasContext& CanvasContext);
    void DrawInWorldInfo(AActor& DebugActor, FGameplayDebuggerCanvasContext& CanvasContext);

protected:
    struct FRepData
    {
        FString CarrierName;

        void Serialize(FArchive& Ar);
    };
    FRepData DataPack;
};

#endif // WITH_GAMEPLAY_DEBUGGER
#+end_src

#+begin_src cpp
#include "GameplayDebuggerCategory_Equipment.h"

#if WITH_GAMEPLAY_DEBUGGER

#include "GameFramework/Actor.h"

namespace UE::GameplayEquipment::Debug
{

}

FGameplayDebuggerCategory_Equipment::FGameplayDebuggerCategory_Equipment()
{
    SetDataPackReplication<FRepData>(&DataPack);
}


void FGameplayDebuggerCategory_Equipment::CollectData(APlayerController* OwnerPC, AActor* DebugActor)
{
    DataPack.CarrierName = IsValid(DebugActor) ? DebugActor->GetHumanReadableName() : FString(TEXT("{red}No selected actor."));

    // Set defaults for info that may not be available

}


void FGameplayDebuggerCategory_Equipment::DrawData(APlayerController* OwnerPC, FGameplayDebuggerCanvasContext& CanvasContext)
{
    AActor* FocusedActor = FindLocalDebugActor();

    if (IsValid(FocusedActor))
    {
        // Display any info attached to the focused actor

        //DrawOverheadInfo(*FocusedActor, CanvasContext);
        //DrawInWorldInfo(*FocusedActor, CanvasContext);
    }

    CanvasContext.Printf(TEXT("{yellow}%s\n{grey}Local"),
        *DataPack.CarrierName
        );
}



TSharedRef<FGameplayDebuggerCategory> FGameplayDebuggerCategory_Equipment::MakeInstance()
{
    return MakeShareable(new FGameplayDebuggerCategory_Equipment());
}

void FGameplayDebuggerCategory_Equipment::FRepData::Serialize(FArchive& Ar)
{
    Ar << CarrierName;
}

#endif // WITH_GAMEPLAY_DEBUGGER
#+end_src

in Module.cpp

#+begin_src cpp
#if WITH_GAMEPLAY_DEBUGGER
#include "GameplayDebugger.h"
#include "Debug/GameplayDebuggerCategory_Equipment.h"
#define EQUIPMENT_CATEGORY_NAME "Equipment"
#endif // WITH_GAMEPLAY_DEBUGGER

#define LOCTEXT_NAMESPACE "FGameplayModularEquipmentModule"

void FGameplayModularEquipmentModule::StartupModule()
{
    // This code will execute after your module is loaded into memory; the exact timing is specified in the .uplugin file per-module

#if WITH_GAMEPLAY_DEBUGGER
    IGameplayDebugger& GameplayDebuggerModule = IGameplayDebugger::Get();
    GameplayDebuggerModule.RegisterCategory(EQUIPMENT_CATEGORY_NAME, IGameplayDebugger::FOnGetCategory::CreateStatic(&FGameplayDebuggerCategory_Equipment::MakeInstance));
    GameplayDebuggerModule.NotifyCategoriesChanged();
#endif // WITH_GAMEPLAY_DEBUGGER
}

void FGameplayModularEquipmentModule::ShutdownModule()
{
    // This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,
    // we call this function before unloading the module.

#if WITH_GAMEPLAY_DEBUGGER
    if (IGameplayDebugger::IsAvailable())
    {
        IGameplayDebugger& GameplayDebuggerModule = IGameplayDebugger::Get();
        GameplayDebuggerModule.UnregisterCategory(EQUIPMENT_CATEGORY_NAME);
        GameplayDebuggerModule.NotifyCategoriesChanged();
    }
#endif // WITH_GAMEPLAY_DEBUGGER
}

#undef LOCTEXT_NAMESPACE
#+end_src

in =.Build.cs=, add:

#+begin_src cpp
        SetupGameplayDebuggerSupport(Target);
#+end_src

** Smart Object

Annotated objects with self-contained logic

- Object Query System :: for selecting best object
- Reservation System :: occupy slot and other cannot target it

*** Design

- Entry/Exit points
- Behavior

**** Selection & Query

- Spatial Proximity :: candidate SOs by spatial data (location/can be reached).
- Tags criterias :: SO and each slot of it can have tags (add in editor or runtime).
- Slot Reservation :: check if SO is "claimed".
- Slot Dependencies :: Some slots might have prerequisite (e.g. slot 2 enabled when slot 1 get claimed).
- World Conditions :: extra preconditions for selection.

**** Slot

Slot

***** Entrance

Must in NavMesh

*** Setup

+ Enable Plugin
  SmartObject
  GameplayBehaviorSmartObject
  AI Behaviors

** Gameplay Behavior

** *State Tree* - /General purpose hierarchical state machine/

A state tree is a data asset and an instance is created from it. Its data is handled through Instanced Data. The schema tells you all the info you need about ownership and its ultimate user.

BT system use bt instances per tree execution and st's handle state tree instanced data per tree execution (state tree execution context)

*** Schema

=StateTreeSchema_FooBar=

need to hardcode FGuid, have enough bits that the likelihood of a duplicate is so incredibly unlikely that you don't have to worry about it as long as you _aren't following an obvious pattern_.

*** execution flow

**** initialize

- TreeStart (Evaluator)
- Tick to ensure output valid (Evaluator)
- =SelectState= (root)
  - Eval (evaluate =EnterCondition= until leaf)
  - Apply (call =EnterState= from tasks _root to leaf_)

**** Runtime tick

- Tick (Evaluator)
- Tick (tick Tasks left to right in each state from _root to leaf_)
  - Stop ticking sub Tasks if any Task succeeded/failed(completed)
  - call =StateComplete= for all tasks (even not ticked) of _activated states_ from _leaf to root_
  - Transition
    - test conditions of Transition from _leaf to root_
    - call =ExitState= of tasks from _leaf to root_
    - =SelectState= (transition target state)
- test tick transition condition
  - test tick transition condition for all activated states
  - call =ExitState= of tasks from _leaf to root_
  - =SelectState= (transition target state)

*** Execution Context

StateTree Execution Context is a helper that is used to update StateTree instance data.

#+begin_quote
Every tick. When the state tree component ticks, it creates a Execution context and ticks it. Within the EC tick everything is evaluated (global tasks, transitions etc)

St's are tick dependant. To be more precise State Tree Execution Context dependant
#+end_quote
You can only tick on demand?

**** ~FStateTreeInstanceData~

Store the runtime state of a =StateTree=.

If ~FStateTreeInstanceData~ is placed on an struct, you must call ~AddStructReferencedObjects()~ manually, as it is not automatically called recursively.

**** ~FStateTreeReadOnlyExecutionContext~

Read-only execution context to interact with the state tree instance data.

Multiple ~FStateTreeReadOnlyExecutionContext~ can coexist on different threads as long no other (minimal, weak, regular) execution context exists.

The user is responsible for preventing invalid multithread access.

**** ~FStateTreeMinimalExecutionContext~ : public ~FStateTreeReadOnlyExecutionContext~

A regular execution context requires the context data and external data to be valid to execute all possible operations.

The minimal execution context doesn't requires those data but supports only a subset of operations.

**** ~FStateTreeExecutionContext~ : public ~FStateTreeMinimalExecutionContext~

(UObject& InOwner, const UStateTree& InStateTree, FStateTreeInstanceData& InInstanceData)


You can extend ~FStateTreeExecutionContext~ to provide additional data to Tasks ().
Usage:

#+begin_src cpp
EStateTreeRunStatus FCitySampleMassContextualAnimTask::EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const
{
    const FMassStateTreeExecutionContext& MassContext = static_cast<FMassStateTreeExecutionContext&>(Context);

    // ...
#+end_src

***** ~FStateTreeExecutionState~ (In InstanceStorage)

****** ~FStateTreeExecutionFrame~

Describes an active branch of a State Tree.

***** ~LinkedAssetStateTreeOverrides~

You can override a state to another StateTree by setting ~LinkedAssetStateTreeOverrides~ for Execution Context via ~SetLinkedStateTreeOverrides()~, the type of override table is ~FStateTreeReferenceOverrides~.

***** ~FStateTreeScheduledTick~

Information on how a state tree should tick next.

***** ~FStateTreeExecutionExtension~

Used by the execution context or a weak execution context to extend their functionalities.

*** Transition

- Gate Delay :: additional delay before transition happen

*** State Tree Node

base class of =Task=, =Evaluator=, =Condition=, =PropertyFunction=.

**** Instance Data

Struct for storing *runtime* data of a state tree node, static parameter can store inside node class as member variables.

example:

#+begin_src cpp
USTRUCT()
struct FStateTreeDebugTextTaskInstanceData
{
    GENERATED_BODY()

    /** Optional actor where to draw the text at. */
    UPROPERTY(EditAnywhere, Category = "Input", meta=(Optional))
    TObjectPtr<AActor> ReferenceActor = nullptr;

    UPROPERTY(EditAnywhere, Category = "Parameter")
    FString BindableText;
};
#+end_src

setup in node:

#+begin_src cpp
USTRUCT(meta = (DisplayName = "Debug Text Task"))
struct FStateTreeDebugTextTask : public FStateTreeTaskCommonBase
{
    GENERATED_BODY()

    using FInstanceDataType = FStateTreeDebugTextTaskInstanceData;

    UE_API FStateTreeDebugTextTask();

    virtual const UStruct* GetInstanceDataType() const override { return FInstanceDataType::StaticStruct(); }

    // ...
}
#+end_src

#+begin_src cpp
{
    const FInstanceDataType& InstanceData = Context.GetInstanceData(*this);

    // InstanceData.ReferenceActor = ...
}
#+end_src

***** ~TStateTreeInstanceDataStructRef~

Stores indexed reference to a instance data struct.

The instance data structs may be relocated when the instance data composition changed. For that reason you cannot store pointers to the instance data.
This is often needed for example when dealing with delegate lambda's. This helper struct stores data to be able to find the instance data in the instance data array.
That way we can access the instance data even of the array changes, and the instance data moves in memory.

Note that the reference is valid only during the lifetime of a task (between a call ~EnterState()~ and ~ExitState()~).

You generally do not use this directly, but via ~FStateTreeExecutionContext~.

#+begin_src cpp
EStateTreeRunStatus FTestTask::EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const
{
    FInstanceDataType& InstanceData = Context.GetInstanceData(*this);

    Context.GetWorld()->GetTimerManager().SetTimer(
        InstanceData.TimerHandle,
        [InstanceDataRef = Context.GetInstanceDataStructRef(*this)]()
        {
            if (FInstanceDataType* InstanceData = InstanceDataRef.GetPtr())
            {
                //...
            }
        },
        Delay, true);

    return EStateTreeRunStatus::Running;
}
#+end_src

**** Property Bind

use category UPROPERTY in =InstanceData= to create bind-able properties.

- ~Category = "Input"~ :: value set only by bind
  use ~meta=(Optional)~ if the input binding is optional.

- ~Category = "Output"~ :: for other bindings

- other category or no category :: can bind input or set value directly

***** How to write to the =Parameters= of state tree (or per state) in C++

#+begin_quote
=Parameters= in state tree in not global for each execution context (each related actors, etc.), and stored in ~FStateTreeReference~.
#+end_quote

use =FStateTreePropertyRef= to change the value of parameter.

create bind-able reference for parameters binding.

#+begin_src cpp
USTRUCT()
struct FXXXTask_InstanceData
{
    GENERATED_BODY()

    // Reference to float
    UPROPERTY(EditAnywhere)
    TStateTreePropertyRef<float> RefToFloat;

    // Reference to FTestStructBase (optional)
    UPROPERTY(EditAnywhere, meta = (Optional))
    TStateTreePropertyRef<FTestStructBase> RefToTest;

    // Reference to TArray<FTestStructBase>
    UPROPERTY(EditAnywhere)
    TStateTreePropertyRef<TArray<FTestStructBase>> RefToArrayOfTests;

    // Reference to FTestStructBase or TArray<FTestStructBase>
    UPROPERTY(EditAnywhere, meta = (CanRefToArray))
    TStateTreePropertyRef<FTestStructBase> RefToSingleOrArrayOfTests;
};
#+end_src

use:

#+begin_src cpp
EStateTreeRunStatus FStateTreeTask_XXX::EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const
{
    // Get InstanceData struct
    FInstanceDataType* InstanceData = Context.GetInstanceDataPtr<FInstanceDataType>(*this);
    check(InstanceData);

    // Get property if binded
    if (auto* PropertyPtr = InstanceData->RefToFloat.GetMutablePtr(Context))
    {
        *PropertyPtr = 42.0;
    }

    return EStateTreeRunStatus::Running;
}
#+end_src

[[https://pafuhana1213.hatenablog.com/entry/2025/01/04/161529][【UE5】StateTreeのParameterを実行中に変更する方法（C++版）]]

ref inside =StateTreePropertyRef.h=

**** External Data

External data is cached external info and access by handle later.

The allowed types of external data is set via virtual function =IsExternalItemAllowed= in state tree schema,

#+begin_src cpp
struct FTestStateTreeTask_XXX : public FStateTreeTaskBase
{
    // ...
protected:
    virtual bool Link(FStateTreeLinker& Linker) override;

    // ここで使用できる型はSchemaで指定した型のみ！
    TStateTreeExternalDataHandle<UXXXComponent> CompHandle;
};
#+end_src

#+begin_src cpp
bool FTestStateTreeTask_XXX::Link(FStateTreeLinker& Linker)
{
    Linker.LinkExternalData(CompHandle);

    return true;
}

EStateTreeRunStatus FTestSTTask_Test::EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const
{
    const UStateTreeComponent& Component = Context.GetExternalData(CompHandle);

    // ...
}
#+end_src

**** Nodes

***** Task

- =bShouldCallTick= :: whether to enable =Tick()=.
- =bShouldCopyBoundPropertiesOnTick= :: if you don't update the bound properties after enter state (assume the value does not change), you can set this to false in ctor.
- =bShouldCopyBoundPropertiesOnExitState= :: similar to above
- =bShouldAffectTransitions= :: call function =TriggerTransitions()= during transition handling.

***** Conditions

Instance data mutable but *no persistent state*.

If you happen to have a Statetree condition where you store data from the world that might change (like a timestamp), don't.

State Tree Conditions share a single "InstanceData" between all actors and PIE sessions. The assumption expressed on the commit message is that "conditions should not hold state"

I also found this on the StateTreeConditionBase.h header:

Note: The condition instance data is shared between all the uses a State Tree asset. You should not modify the instance data in this callback.
This is a comment above methods EnterState(), ExitState() and StateCompleted().

*** Property Function

bind function to node property (e.g. GetFoo(), XOR), kind like Evaluater but called right before evaluating bindings for the owning node (when EnterState or Condition handling).

#+begin_quote
also allowed via =IsStructAllowed= in schema.
#+end_quote

#+begin_src cpp
#pragma once

#include "StateTreePropertyFunctionBase.h"

#include "StateTreeTestPropertyFunctions.generated.h"

USTRUCT()
struct FStateTreePropertyFunction_Test_InstanceData
{
    GENERATED_BODY()

    UPROPERTY(EditAnywhere, Category = Parameter)
    bool bInput = false;

    UPROPERTY(EditAnywhere, Category = Output)
    bool bResult = false;
};

USTRUCT(DisplayName = "Test")
struct FStateTreePropertyFunction_Test : public FStateTreePropertyFunctionCommonBase
{
    GENERATED_BODY()

    using FInstanceData = FMySTFunction_Test_InstanceData;
    virtual const UStruct* GetInstanceDataType() const override { return FInstanceData::StaticStruct(); };

    virtual void Execute(FStateTreeExecutionContext& Context) const override;

#if WITH_EDITOR
    virtual FText GetDescription(const FGuid& ID, FStateTreeDataView InstanceDataView, const IStateTreeBindingLookup& BindingLookup, EStateTreeNodeFormatting Formatting) const;
#endif
};
#+end_src

#+begin_src cpp
#include "StateTreeTestPropertyFunctions.h"

#include "StateTreeExecutionContext.h"
#include "StateTreeNodeDescriptionHelpers.h"

#define LOCTEXT_NAMESPACE "StateTree"

void FStateTreePropertyFunction_Test::Execute(FStateTreeExecutionContext& Context) const
{
    FInstanceDataType& InstanceData = Context.GetInstanceData(*this);
    InstanceData.bResult = InstanceData.bInput;
}

#if WITH_EDITOR
FText FStateTreePropertyFunction_Test::GetDescription(const FGuid& ID, FStateTreeDataView InstanceDataView, const IStateTreeBindingLookup& BindingLookup, EStateTreeNodeFormatting Formatting) const
{
    return UE::StateTree::DescHelpers::GetDescriptionForSingleParameterFunc<FInstanceDataType>(LOCTEXT("StateTreeTest", "Test"), ID, InstanceDataView, BindingLookup, Formatting);
}
#endif // WITH_EDITOR

#undef LOCTEXT_NAMESPACE
#+end_src

**** GetDescription

there are multiple helpers in namespace =UE::StateTree::DescHelpers= to format a description.

*** Usage

**** State tree on UObject

**** Communication

***** External Data Input

Context
Evaluator (deprecated, use Global Task)
Global Task

** Gameplay Interaction (Plugin)

rely on
- Contextual Animation :: Multi-actor sync + Motion Warp
- StateTree

** *Modular Gameplay*

*** Modular Gameplay

**** GameFrameworkComponentManager (Game Instance Subsystem)

***** Initialization State System (InitState)

This system provides registration and notification functions that make _synchronizing the initialization of components on an Actor_ coordination simpler.

- Why we need this system?
  In the past (especially when online project), the =BeginPlay()= of components on client might called earlier then =PlayerState= is ready (PlayerState in Controller might be null, or the Owner of PlayerState is not setup as Controller), or another dependent component is not ready.

  The one solution is to check whether the data is available in every related timing (e.g. =OnRep_PlayerState=), this is basically what the system dose, each component only need to care about the state and change condition.

=UGameFrameworkInitStateInterface=

****** Terminology

| Term           | Description                                                                                                                                                          |
|----------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| InitState      | User-defined global =GameplayTags= for tracking the initialization and general life cycle of different features (usually implemented by components) attached to Actor. |
| (Actor)Feature | Unique =FName= identifier in Implementer object (often a component), which has InitState.                                                                              |
| StateChain     | Linearly arranged InitStates, (usually static) const TArray<FGameplayTag>.                                                                                           |

****** Lyra

******* StateChain (Defined in =CheckDefaultInitialization()=)

- Spawned (=LyraGameplayTags::InitState_Spawned=) :: The feature has finished spawning and initial replication, which is only set in =BeginPlay=.
- DataAvailable (=LyraGameplayTags::InitState_DataAvailable=) :: All data needed by the feature has been replicated or loaded, including dependencies on other actors that may also need to be replicated.
- DataInitialized (=LyraGameplayTags::InitState_DataInitialized=) :: After all of the data becomes available, it is used to complete other initialization actions like adding gameplay abilities.
- GameplayReady (=LyraGameplayTags::InitState_GameplayReady=) :: The object has finished all initialization and is ready to be interacted with in normal gameplay.

******* PawnExtension

******** =BeginPlay=

=BindOnActorInitStateChanged(NAME_None, ...)= listen for InitState changes of all the other features

******* HeroComponent

******** =BeginPlay=

=BindOnActorInitStateChanged()= listen for =PawnExtension= changes init state

=TryToChangeInitState()= notifies done spawning (change InitState to =InitState_Spawned=)

****** Implementation

******* Inherit =IGameFrameworkInitStateInterface=

******** override =GetFeatureName()=

#+begin_src cpp
// header
  // in class
  {
  public:

      /** The name of this overall feature, this one depends on the other named component features */
      static const FName NAME_ActorFeatureName;

      //~IGameFrameworkInitStateInterface interface
      virtual FName GetFeatureName() const override { return NAME_ActorFeatureName; }
      //~End of IGameFrameworkInitStateInterface interface

      // ...
  }

// cpp
  // ...
  const FName ULyraPawnExtensionComponent::NAME_ActorFeatureName("PawnExtension");
  // ...
#+end_src

******** s

******* =RegisterInitStateFeature()= in object =OnRegister()=

Register self with =ModularGameplay= plugin’s =UGameFrameworkComponentManager=
Registers with the system but does not set a state, this is useful to call from component =OnRegister=.

#+begin_src cpp
void UMyComponent::OnRegister()
{
    Super::OnRegister();

    // ...
    // May add some assert and log here

    // Register with the init state system early, this will only work if this is a game world
    RegisterInitStateFeature();
}
#+end_src

******* =UnregisterInitStateFeature()=

This should generally be called from EndPlay to unregister from the system and unbind notification delegates.

#+begin_src cpp
void UMyComponent::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
    // ...

    UnregisterInitStateFeature();

    Super::EndPlay(EndPlayReason);
}
#+end_src

******* =CanChangeInitState() const=

Implement checks to see if the required data is available.

#+begin_src cpp
bool ULyraPawnExtComponent::CanChangeInitState(UGameFrameworkComponentManager* Manager, FGameplayTag CurrentState, FGameplayTag DesiredState) const
{
    check(Manager);

    APawn* Pawn = GetPawn<APawn>();
    if (!CurrentState.IsValid() && DesiredState == LyraGameplayTags::InitState_Spawned)
    {
        // As long as we are on a valid pawn, we count as spawned
        if (Pawn)
        {
            return true;
        }
    }
    if (CurrentState == LyraGameplayTags::InitState_Spawned && DesiredState == LyraGameplayTags::InitState_DataAvailable)
    {
        // Pawn data is required.
        if (!PawnData)
        {
            return false;
        }

        const bool bHasAuthority = Pawn->HasAuthority();
        const bool bIsLocallyControlled = Pawn->IsLocallyControlled();

        if (bHasAuthority || bIsLocallyControlled)
        {
            // Check for being possessed by a controller.
            if (!GetController<AController>())
            {
                return false;
            }
        }

        return true;
    }
    else if (CurrentState == LyraGameplayTags::InitState_DataAvailable && DesiredState == LyraGameplayTags::InitState_DataInitialized)
    {
        // Transition to initialize if all features have their data available
        return Manager->HaveAllFeaturesReachedInitState(Pawn, LyraGameplayTags::InitState_DataAvailable);
    }
    else if (CurrentState == LyraGameplayTags::InitState_DataInitialized && DesiredState == LyraGameplayTags::InitState_GameplayReady)
    {
        return true;
    }

    return false;
}
#+end_src

******* =HandleChangeInitState()=

Overridden to perform any object-specific changes that should occur on a specific state transition.

#+begin_src cpp
void UMyComponent::HandleChangeInitState(UGameFrameworkComponentManager* Manager, FGameplayTag CurrentState, FGameplayTag DesiredState)
{
    if (CurrentState == MyGameplayTags::InitState_Foo && DesiredState == MyGameplayTags::InitState_Bar)
    {
        // ...do something when state changes
    }
}
#+end_src

******* =CheckDefaultInitialization()=

Try and progress the default initialization path, likely using =ContinueInitStateChain(StateChain)=.

#+begin_src cpp
void ULyraPawnExtensionComponent::CheckDefaultInitialization()
{
    // Before checking our progress, try progressing any other features we might depend on (set by BindOnActorInitStateChanged)
    CheckDefaultInitializationForImplementers();

    static const TArray<FGameplayTag> StateChain = { LyraGameplayTags::InitState_Spawned, LyraGameplayTags::InitState_DataAvailable, LyraGameplayTags::InitState_DataInitialized, LyraGameplayTags::InitState_GameplayReady };

    // This will try to progress from spawned (which is only set in BeginPlay) through the data initialization stages until it gets to gameplay ready
    ContinueInitStateChain(StateChain);
}
#+end_src

******* =BindOnActorInitStateChanged()= & =OnActorInitStateChanged()=

Can be used on the interface to quickly listen for changes made to other features on the _same Actor_.

This can then be used to call functions like =CheckDefaultInitialization= that may advance the init state of the feature.

#+begin_src cpp
void ULyraHeroComponent::BeginPlay()
{
    Super::BeginPlay();

    // Listen for changes to all features
    //BindOnActorInitStateChanged(NAME_None, FGameplayTag(), false);

    // Listen for when the pawn extension component changes init state
    BindOnActorInitStateChanged(ULyraPawnExtensionComponent::NAME_ActorFeatureName, FGameplayTag(), false);

    // Notifies state manager that we have spawned, then try rest of default initialization
    ensure(TryToChangeInitState(LyraGameplayTags::InitState_Spawned));
    CheckDefaultInitialization();
}
#+end_src

#+begin_src cpp
void ULyraHeroComponent::OnActorInitStateChanged(const FActorInitStateChangedParams& Params)
{
    if (Params.FeatureName == ULyraPawnExtensionComponent::NAME_ActorFeatureName)
    {
        if (Params.FeatureState == LyraGameplayTags::InitState_DataInitialized)
        {
            // If the extension component says all all other components are initialized, try to progress to next state
            CheckDefaultInitialization();
        }
    }
}
#+end_src

******* In character, check if data replicated in every critical phase like =OnRep_PlayerState=, etc.

******* Register tag order for init state GameplayTags in =GameInstance::Init()=

#+begin_src cpp
#include "Components/GameFrameworkComponentManager.h"

void ULyraGameInstance::Init()
{
    Super::Init();

    // Register our custom init states
    UGameFrameworkComponentManager* ComponentManager = GetSubsystem<UGameFrameworkComponentManager>(this);

    if (ensure(ComponentManager))
    {
        ComponentManager->RegisterInitState(LyraGameplayTags::InitState_Spawned, false, FGameplayTag());
        ComponentManager->RegisterInitState(LyraGameplayTags::InitState_DataAvailable, false, LyraGameplayTags::InitState_Spawned);
        ComponentManager->RegisterInitState(LyraGameplayTags::InitState_DataInitialized, false, LyraGameplayTags::InitState_DataAvailable);
        ComponentManager->RegisterInitState(LyraGameplayTags::InitState_GameplayReady, false, LyraGameplayTags::InitState_DataInitialized);
    }
}
#+end_src

***** Use ActorExtensionEvent in actor (Extension system) (not recommended, use GameFeature instead)

Send event to actor with a FName.

- FComponentRequestHandle :: A handle for a request to put components or call a delegate for an extensible actor class. When this handle is destroyed, it will remove the associated request from the system.

****** Sender

#+begin_src cpp
public:
    // The name of the extension event sent via UGameFrameworkComponentManager when FooBarReady.
    static const FName NAME_FooBar;
#+end_src

#+begin_src cpp
const FName UAvatarComponent::NAME_FooBar("FooBarReady");

UGameFrameworkComponentManager::SendGameFrameworkComponentExtensionEvent(AReceiverActor, NAME_FooBar);
#+end_src

****** Receiver

#+begin_src cpp
if (UGameFrameworkComponentManager* ComponentMan = UGameInstance::GetSubsystem<UGameFrameworkComponentManager>(GameInstance))
{
    auto FooBarDelegate = UGameFrameworkComponentManager::FExtensionHandlerDelegate::CreateUObject(
                      this, &ThisClass::HandleActorExtension);
    TSharedPtr<FComponentRequestHandle> ExtensionRequestHandle = ComponentMan->AddExtensionHandler(this, FooBarDelegate);
    // Save the ExtensionRequestHandle somewhere, or delegate will be removed when the handle out of scope.
}
#+end_src

#+begin_src cpp
void AFooBarActor::HandleActorExtension(AActor* Actor, FName EventName)
{
    if (EventName == ...)
    {
        // do something
    }
    else if (EventName == ...)
    {
        // do something
    }
}
#+end_src

***** AddComponent Request

request to instantiate components on actors of the given classes.

*** Game Features

**** Setup

Enable _Game Features_ and _Modular Gameplay_ plugin

+ Game Features :: Support for Game Feature and Actions
+ Modular Gameplay :: For add component

***** Create Game Feature

New Plugin -> Game Feature
- Path :: Path/to/Project/Plugins/GameFeatures/
- Content Browser
  check "Show Plugin Content"

***** GameFeatureData Asset

*Do NOT rename it*

defined behavior and Actions

check ProjectSettings/AssetManager->PrimaryAssetType->Load GameFeatureData

***** Actions

***** =UGameFeaturesSubsystem= :: UEngineSubSystem

****** UGameFeaturesProjectPolicies

Defined which GameFeatures should be load

******* UDefaultGameFeaturesProjectPolicies

Load *All* GameFeatures

******* Create GameSpecificPolicies

#+begin_src cpp
GameSpecificPolicies = NewObject<UGameFeaturesProjectPolicies>(this, singletonClass);
#+end_src

******* Setup MyGameFeaturesProjectPolicies

- .uplugin file
  Define a Key(Metadata)
  e.g. "MyGameVersion": 1.1,
- ProjectSettings->Game - Game Features
  - DEFAULT CLASSES->Game Feature Manager Class :: MyGameFeaturesProjectPolicies
  - GAME FEATURES->Additional Plugin Metadata Keys :: MyGameVersion
- C++
  #+begin_src cpp
  void UMyGameFeaturesProjectPolicies::InitGameFeatureManager()
  {
      auto AdditionalFilter = [&](const FString& PluginFilename, const FGameFeaturePluginDetails& PluginDetails, FBuiltInGameFeaturePluginBehaviorOptions& OutOptions) -> bool
      {
          if (const FString* MyGameVersion = PluginDetails.AdditionalMetadata.find(TEXT("MyGameVersion")))
          {
              float version = FCString::Atoi(**myGameVersion);
              if (version > 2.0)
              {
                  return true;
              }
          }
          return false;
      };

      UGameFeaturesSubsystem::Get().LoadBuiltInGameFeaturePlugins(AdditionalFilter);
  }
  #+end_src

****** UGameFeaturesSubsystemSettings

**** Feature State

**** GameFeature snippet

***** FindOrAddComponentForActor

***** HandleActorExtensionEvent

* Animation

** Skeleton

*** Import Options

- Use T0 as Ref Pose :: won't print warning if skeleton is different from Unreal Engine usually expect

*** Skeleton Mesh

*** Skeleton Assets

A list of Bone & Hierarchy information

**** Hierarchy & Naming

share animation between same base bone setup, hierarchy and naming convention

and fine to attach thing to hierarchy (without change naming, reordering)

**** Sockets, Notifies, Curve Names, Slot Names

**** Retargeting

*** Physics Assets

Ragdoll physics
constraint

** Notifies

There is two type notify: =Queue= & =Branching Point=, =Queue= is default and less reliable and may have latency, usually used for _cosmetic_ (FX); and =Branching Point= is reliable and trigger immediately, suitable for _gameplay relevant_ things.

+ Tip: Branching Point can not be overlapped, so for AnimNotifyState only one branching point state get triggered at the same time.
+ Tip: Hold =Shift= to edit with animation playing

*** AnimNotify

**** Implementation

***** Blueprint

override function =Received_Notify= (for both Queue and Branching Point)

***** Native

- Queue

  override =void Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference)=

- Branching Point

  set =bIsNativeBranchingPoint = true;= in ctor, and override =void BranchingPointNotify(FBranchingPointNotifyPayload& BranchingPointPayload)=

*** AnimNotifyState

**** Implementation

***** Blueprint

override function =Received_NotifyBegin= =Received_NotifyEnd= =Received_NotifyTick=

***** Native

- Queue

  override =NotifyBegin= =NotifyEnd= =NotifyTick=

- Branching Point

  set =bIsNativeBranchingPoint = true;= in ctor, and override =BranchingPointNotifyBegin= =BranchingPointNotifyEnd= =BranchingPointNotifyTick=

use MeshComp->GetOwner to get actor, or use interface

** Movement drive Animation VS. Animation drive Movement

** *Animation Blueprint*

+ Parent Class :: UAnimInstance

** *Montage and Slot*

+ Combine Animations
+ Play Animations Selectively
+ Fire off Events

*** Slot(Animation Blueprint)

Play Montage

** Sync Group & Sync Marker

*** e.g. for leg consistence

- Without Sync

#+ATTR_HTML: width="300px"
#+ATTR_ORG: :width 300
  [[file:./images/animation_transition_without_sync_group.webp]]

- With Sync

#+ATTR_HTML: width="300px"
#+ATTR_ORG: :width 300
  [[file:./images/animation_transition_with_sync_group.webp]]

*** Setup

**** Group-Based Syncing (Match the the length of two blend anim)

- Set the same Sync Group name on animBP nodes

- Set Sync Method to Sync Group

**** Sync Markers (Match relevant position of markers)

- Mark animations with Sync Markers

  Notify > Add Sync Marker

- Set the same Sync Group name on animBP nodes

- Set Sync Method to Sync Group

** Pose Snapshot

Cache pose then blend in AnimBP

** AnimInstance

*** Multi Threaded Animation Update

** *Control Rig*

A plugin

faster than AnimationBP by using special VM

*** Space and Control

**** Control

in Viewport

**** Space

Define origin point of the Control

*** Forwards Solve (Controls driving Bones)

Solving from control rig to FK

*** Backwards Solve (Bones driving Controls (Rig Inversion))

When you already have bone animation, bake to control rig

*** Setup Event

Before any forward or backward solve logic

*** Rig Sharing

*** Control Rig Component

*** Setup Graph

Run once before frame update start to setup some static value(e.g. hand length)

*** Python API

*** Nodes

**** Basic IK

+ Effector
  Default to origin
+ Primary Axis
  point to bone alone the chain
+ Secondary Axis
  point to pole vector

*** Runtime Rigging

**** Parameter and Variable

***** Parameter

taking external data into control rig

only have getters

***** Variable

within control rig

**** Add bones

Not real bone but just Transform Variable with parent-child relationship

*** Bake Animation Assets

*** Driving Gameplay

*** Change Existing Animations

Setup Backwards Solve

*** Debug Tips

+ Use Control Rig to watch instances in the level
  to find Magic Number
+ Visual Debug
+ Draw Line Node
+ Debug ctrls attach to a situation depends on the execution orders to visualize

*** Editor Widgets and Python API

** *Motion Warping*

+ Forward Solve
  Init IK bones(or virtual bones)

*** Distance Matching and Stride Warping

Adjust animation to work with varying player movement speed

*** Orientation Waring

Adjust animation to work with varying player movement angles

*** Turn in Place

Natural looking animations when player rotates in place without moving

Play repositioning animations once the orientation is too great

*** Foot placement

** *Full-Body IK Plugin*

Data driven

** Motion Matching

from UBI

** Vertex Animation

* Cinematics

** Sequencer

* Rendering

** Material

*** Texture

**** Texture Compression Format

BC(DXT) oodle

ASTC

*** World Offset

leafs and grass

*** World-Aligned Textures and Normals

- Convert texture sample to texture object

*** Strata

** Nanite

*** Mass Optimization

prevent overdraw in basic asset

+ Generate simplified collision for physics and navigation
  source code: /AncientGame/Plugin/InstanceLevelCollision
+ One sided
  block the light leaking using large blocks
+ Check for non-Nanite meshes
  ShowFlags.NaniteMeshes 0

** Virtual Texture

*** not for

UI Element
VFX Texture
Opacity masks

*** show only things would invalidate the shadow maps

ShowFlag.DrawOnlyVSMInvalidatingGeo 1

** Lighting

*** Light Function

*** Cost

Rect >> Point > Spot

** VFX

*** Prepared

**** FBX

**** Alembic

**** VAT

*** Real-Time

**** Niagara

**** PhysX

**** Chaos

** Post Process

** Volumetric Effects

** Cel Shading

*** Material

*** Post Process

**** PPCelShader

+ Turn off Unreal Tone mapping
  + (deprecated) r.TonemapperFilm 0
    DefaultEngine.ini
    [/Script/Engine.RendererSettings]
    r.TonemapperFilm 0
  + PostProcessVolume->Detail->Color Grading->Misc->Expand Gamut->0
  + PostProcessVolume->Detail->Color Grading->Misc->Tone Curve Amount->0

*** Idol Master

**** Tone Mapper Setting

***** Post Process

r.TonemapperFilm 1
ToneCurveAmount 0

***** ini Config

#+begin_src conf
[/Script/Engine.RendererSettings]
#+end_src

** Super Sampling

*** FSR

*** XeSS

[[https://github.com/GameTechDev/XeSSUnrealPlugin]]

*** DLSS

** Anti-aliasing (AA)

*** TSR

**** Reduce artifact when texture rotate

- Material check =Has Pixel Animation=
- r.TSR.ShadingRejection.Flickering.Period 1
- rotate object instead
- use other AA

** Hair and Fur System (Groom)

*** Requirements

**** Plugin

+ Groom
+ Alembic Groom Importer

**** Settings

+ Support Compute Skin Cache

*** Materials

*** Skinning

**** Process

+ Binding through asset
+ Influenced by triangles
  r.HairStrands.DebugMode 12
  r.HairStrands.MeshProjection.Sim.Deformed.Triangles 1

*** Simulation

*** Advanced

*** LOD System

**** Strands

+ Reducing strand density

**** Cards

+ Generating cards
+ Skinning
+ Material attributes

**** Mesh

* World

** Level

** Landscape

** Environment Query System (EQS)

** PCG (Procedural Content Generation)

* Physics

** Physics Body Properties

- Location :: The location in the world of the body
- Rotation :: The rotation or orientation in the world of the body
- Linear velocity :: How fast and in what direction the body is moving, or changing location
- Angular velocity :: How fast the body is rotating, or changing rotation, in each of the roll, pitch and yaw axes
- Mass :: The density of the body, or the resistance to movement forces applied to the body
- Center of mass :: The center of mass offset from the physical center of the body
- Inertia tensor :: The resistance to rotational forces, or torques, applied to the body

You move physics bodies by applying forces to them

They come in two flavors, forces and impulses

The equation for a force is *force = mass * distance + time^2*

Forces are generally applied over time and are useful for things like motors or engines

The equation for an impulse is *impulse = mass * distance + time*

Impulses are generally applied over just a single game frame and are useful for things like explosions

Mass and inertia tensor, act against forces and torques respectively

The more massive an object, the more force you need to move it

The more inertia tensor an object has, the more torque you need to rotate it

You should think of mass as *anti-force*

And inertia tensor as *anti-torque*

** Sub-Stepping

switch to Sub-Stepping for physics to get consistent result, no matter how slow rendering rate might be

physics simulations that are more accurate and stable

Regular =Tick()= function will not be called per sub-step, it called per game frame

** Ragdoll & Physics Assets

+ Animation Pose Snapshot | Live Training | Unreal Engine
+ Physical Animations | Live Training | Unreal Engine

*** Custom Constraint Profiles

- Add Profile
  Window->Physics Asset->Profiles->Constraint Profiles
- Add Constraints to Profile
- Set Constraint Profile
  Skeletal Mesh Component

* UI/UX

** UMG

*** Viewmodel (MVVM)

** Common UI

*** Implement

Enable CommonUI plugin

change =Game Viewport Client Class= to =CommonGameViewportClient= in project settings

*** Hide old widget class in UMG editor

#+begin_src conf
[/Script/UMGEditor.UMGEditorProjectSettings]
+WidgetClassesToHide=/Script/UMG.WidgetSwitcher
+WidgetClassesToHide=/Script/UMG.TextBlock
#+end_src

* Audio

** Unreal Audio

*** Audio Files

imported audio file is stored in a 16-bit, uncompressed =.wav= format.

**** 24 to 16bit Dithering

Unreal won't dither 24bit audio when convert it to 16bit.
use your external daw like IZotop RX or Reaper

*** Sound Source

**** MetaSounds

**** Source Bus

**** Sound Cues (Legacy)

Unreal Engine's legacy audio objects.

Don't use it anymore.

*** Source Effects

Source effects are DSP effects that apply to individual sound sources.

**** Sound Effect Chain

***** ~USoundEffectSourcePreset~


***** ~FSoundEffectSource~

Setup in ~USoundEffectSourcePreset~
#+begin_src cpp
// Preset for the Project Acoustics spatial reverb virtual speaker sound effect
UCLASS(ClassGroup = AudioSourceEffect, meta = (BlueprintSpawnableComponent))
class USoundEffectFooPreset : public USoundEffectSourcePreset
{
    GENERATED_BODY()

public:
    EFFECT_PRESET_METHODS(FooSoundEffectSource)
#+end_src

*** Audio Mixing

**** Audio Modulation

**** =Submix=

like Bus in DAW

Send sound sources to =Submix=

**** Audio Bus

Audio buses are a way to have audio routed without rendering (you can use it to analyze, etc)

***** Source Bus

Source buses are a way to sonify the audio in an audio bus... and can be itself spatialzied, effects processed, etc.

#+begin_quote
Use audio buses and source buses for situations where you want to do some more obvious "bounce"/early reflection stuff.
#+end_quote

**** Sound Class, Sound Class Mix (Legacy)

Don't use it anymore.

Replaced by =SubMix=, =Audio Modulation=.

- Sound Class :: To categorize sounds, Assign Sound Class Asset to Sound Sources, able to modify static parameters of all these sound sources.
- Sound Mix :: To modulate a set of audio parameters dynamically at runtime.

*** Spatialization

**** Sound Attenuation

To control sound volume, panning, frequency cut-off, etc.

**** Spatializer Plugin

***** Build-in Spatializer

Just panning.

***** Simple Interaural Time Delay (ITD)

binaural, in plugin =Spatialization=, much cheaper than HRTF.

#+begin_quote
Using a Spatialization plugin (like the ITD one) and using a CVAR to disable binaural spatialization is how we do non-headphone mode in Fortnite.
#+end_quote

***** Google Resonance Audio

in Fortnite (newer version)

HRTF style spatializer, cheaper HRTF solutions and least colored, ported to whichever platforms.

**** Occlusion Plugin

Built-in

*** Reverb Plugin

*** Convolution Reverb

*** Modulation Plugin

*** Gameplay

**** Audio Gameplay Volumes

**** Quartz

combine sound and gameplay

*** Audio Analysis

*** Audio Link

AudioLink plugin allows 3rd party audio engines to interact with Unreal Audio sources and submixes.

*** Miscellaneous

**** ~FAudioDevice~

#+begin_quote
From AaronMcLeran

managed by FAudioDeviceManager, which allows us to do multi-PIE
FAudioDevice isn't really named properly
it has little to do with "audio devices"
it's an audio system... like the whole shebang
has a listener, list of sounds its trying to play
it's the interface to the engine to play audio
each PIE instance is a unique UWorld/Viewport
a unique FAudioDevice is created for each one in multi-pie
then when sounds play it knows what UWorld it's associated with
grabs the audio device for that UWorld, then plays the sound
#+end_quote

***** ~FListener~ (Audio thread)

***** ~FListenerProxy~ (Game thread)

Game thread representation of a listener

**** Channel Agnostic Type (CAT)

** Loudness

** Plugin for Audio

*** Source Data Override Plugin

**** ~IAudioSourceDataOverride~

#+begin_src
#pragma once

#include "IAudioExtensionPlugin.h"

class FFooSourceDataOverride : public IAudioSourceDataOverride
{
public:

    //~IAudioSourceDataOverride interface
    void Initialize(const FAudioPluginInitializationParams InitializationParams) override;
    void OnInitSource(const uint32 SourceId, const FName& AudioComponentUserId, USourceDataOverridePluginSourceSettingsBase* InSettings) override;

    /**
     * @Param SourceId internal handle to the audio engine
     */
    void OnReleaseSource(const uint32 SourceId) override;

    /**
     * @Param InListenerTransform Transform of listener, closest one for split screen.
     * @Param InOutWaveInstance Every data you might need.
     */
    void GetSourceDataOverrides(const uint32 SourceId, const FTransform& InListenerTransform, FWaveInstance* InOutWaveInstance) override;
    void OnAllSourcesProcessed() override;
    //~End of IAudioSourceDataOverride interface
}
#+end_src

***** ~USourceDataOverridePluginSourceSettingsBase~

whatever you want to pass for your plugin

#+begin_src
#pragma once

#include "IAudioExtensionPlugin.h"

UCLASS(AutoExpandCategories = (Settings))
class UE_API UFooSourceDataOverrideSourceSettings
    : public USourceDataOverridePluginSourceSettingsBase
{
    GENERATED_BODY()
}
#+end_src

** Microsoft Project Acoustics

Back accurate acoustics for 3D scenes using wave acoustics engine.

+ lightweight runtime
+ Designer controls
+ Azure or local baking
+ Offerings Unreal Audio & Unreal/Wwise

#+ATTR_HTML: width="500px"
#+ATTR_ORG: :width 500
[[file:./images/Microsoft_ProjectAcoustics_BigPicture.webp]]

*** Project Triton (Top 5 sound propagation effects)

+ Obstruction :: Sound is weakened when it diffracts around obstructions​.

[[file:./images/ProjectTriton_Obstruction_12.3.1-1024x487.webp]]

#+ATTR_HTML: width="300px"
#+ATTR_ORG: :width 300
[[file:./images/microsoft_project_acoustics_obstruction_demonstration.webp]]

+ Portaling (sound redirection) :: Sound heard “through the wall” (red) from source direction is incorrect​. Doors redirect sounds, which is more believable​.

[[file:./images/ProjectTriton_Portaling_12.3-1024x487.webp]]

+ Occlusion :: Occlusion is total reduction in loudness from geometry, involving complex propagation and diffraction (diffracted paths in green)​.

[[file:./images/ProjectTriton_Web_Occlusion_2400x1141-1024x487.webp]]

#+ATTR_HTML: width="300px"
#+ATTR_ORG: :width 300
[[file:./images/microsoft_project_acoustics_portaling_occlusion_demonstration.webp]]

+ Reverberance :: Left: Close to the source, direct path (green) is loud compared to reflections (orange), resulting in high clarity and low reverberance. Right: Behind the partition, direct path is weakened from diffraction, causing low clarity and high reverberance, conveying that the source is in a different room.​

[[file:./images/ProjectTriton_Reverberance_12.3.3-1024x487.webp]]

#+ATTR_HTML: width="300px"
#+ATTR_ORG: :width 300
[[file:./images/microsoft_project_acoustics_reverberance_demonstration.webp]]

+ Decay time :: Larger rooms reverberate longer.​

[[file:./images/ProjectTriton_Web_DecayTime_2400x1141-1024x487.webp]]

#+ATTR_HTML: width="300px"
#+ATTR_ORG: :width 300
[[file:./images/microsoft_project_acoustics_decaytime_demonstration.webp]]

*** Unreal Plugin 2022.1

**** ~UAcousticsSourceDataOverrideSourceSettings~

can be set in Attenuation to control parameters for per sound source, like less wet for speech.
global one in Acoustics Space Actor

**** Debug

- switch on Acoustics Space Actor to show *baked* probe and voxel, check if it's different from preview.
- switch on ~UAcoustircsSourceDataOverrideSourceSettings~ to show parameters about sound source
- CMD start with PA.

**** effects (3/5 effect Implemented in plugin)

***** Portaling

override sound source location, and other plugin can use it for spatialization.

***** Occlusion

override sound source loudnes, this is conflit with other occlution plugin.

***** Reverb

****** Convolution Reverb

the sound source based reverb, get wetness from =acoustics param= for each source, and interp to get a proper time for IR for them.

** Terminology

*** HRTF (Head-Related Transfer Function)

#+begin_quote
This is a good question.  Honestly as usual it really depends. The headphone binaural systems still need to pass by some kind of HRTF encoding, and, believe it or not, there is NO HRTF general function, even if some try  , with various degrees of success, to achieve it. Apple spatial audio, well, don't let me start...   Simply put, to have a real HRTF function you need to have 1 for every kind of head in the world, since we are different, similar, but different. Said this, the comfortable thing about atmos is the compatibility. Which by itself brings the fact that listening environments must be standardized. It is great for the Video industry because you produce once, and it is valid for several dolby compatible systems (Cinemas for example), no matter how many output channels you have. But object based audio is nothing new, and this is what UE does by default if you think about it. -> audio objects in a virtual space...  Now the point would be encoding and decoding, and here dolby does have an upper hand due to the imposition of surround systems for cinema and home cinema. I am more curious if one can import in UE a whole dolby atmos mix and have an automatic render to objects solution...  Any way, as usual it depends on one's use, and necessities.
#+end_quote

*** Reverberation Time (RT60)

The *duration* required for the sound energy in a room to decrease by 60 dB after the source emission has stopped.

*** Interleave (Deinterleave/re-interleave)

- Deinterleave :: Splits one interleaved multichannel audio stream into many mono audio streams.

In interleaved audio, samples from each channel are mixed together in sequence.
Left channel samples:   L1, L2, L3
Right channel samples:  R1, R2, R3
Then interleaved audio: [ L1, R1, L2, R2, L3, R3 ]

*** a voice in unreal audio

an instance of a sound being played

** Dolby Atmos

Well also Atmos is not a normal speaker channel configuration. It's a proprietary encoded data stream that can only be read by Dolby decoding software/hardware.

*** Setup

Main bus (Bed Channels) - Soundfield

- 7.1.4 (or 2.0 if Spetialization turned off in OS)
- Auto detected on Windows/Xbox

** Sound Design

*** Third-person listener

#+begin_quote
from Dannthr, Senior Technical Audio Designer @ Epic Games

For nearby 3rd person, you would not want to move the Spatialization off the camera, it's disorienting and sounds bad in surround.

You only want to move the Attenuation to the pawn.

There should be an Attenuation Override. (=Set Audio Listener Attenuation Override= from Player Controller)

Fortnite has some pretty tight attenuation falloffs--like for chests and stuff--and so players need to be able to find them based on their pawn location.

An example is Fortnite does this, we moved the Attenuation override to the Pawn because Treasure chests had a short attenuation range, shorter than the distance between the Pawn and the Camera/Listener. So people were having a difficult time finding them.
Moving it to the Pawn meant that they could relate the distance of the chest to the pawn but still use the camera/listener to orient the sound correctly to the viewport.

But what I recommend is instead only overriding the Attenuation Listener, so that spatialization is still based on the camera. In other words, whether a sound is in front, behind, to the left, or to the right of the camera is preserved; but the loudness of a sound by distance is based on the pawn position (this is what we do in Fortnite) and it avoids disorientation or confusion since the user's sense of direction is preserved (since they perceive the game world through the camera).
#+end_quote

*** Whizby

#+begin_quote
from Dannthr, Senior Technical Audio Designer @ Epic Games

I did end up doing the core math calculation for the WhizBys, but that's because Rich had already left the project when I had to resolve a bug.
So the whizbys were more like a collab with Rich.
Rich also did the first reflection system.
The whizby stuff was based off of some R&D I did previously and I probably didn't explain the math clearly enough.

#+ATTR_HTML: width="500px"
#+ATTR_ORG: :width 500
[[file:./images/WhizBy_Vector_Math.jpg]]

E for enemy, L for listener, then you just need to determine if the whizby is clockwise or counter-clockwise.
Get the dot product of the FvRv (Firing Vector Right Vector) and the B (closest point on Fv to the L).
Depending on the sign of the output, you can determine if it's clockwise or counter-clockwise.
Clockwise means the whizby is traveling left to right across the stereo field, and vice-versa for the counter-clockwise.
The sound is played at the closest point to listener on the Firing vector.
Then you do stuff like distance blending, nice air absorption, etc. I like to have more characterful whizbys for closer ones, and thinner whizbys for more distance.
This approach sounds good in stereo, but sounds GREAT in surround.
I won't do whizbys for successful hits, but the onset component of a whizby can plus up the impact sound if it precedes it.
Same with nearby impact sounds.
#+end_quote

* Networking

** =Iris= Replication System

** Multiplayer

*** Peer-to-Peer

*** Client-Server

Unreal Engine uses authoritative client-server model

**** Listen-server

**** Dedicated-server

*** Online Subsystem

connect with each other without knowing IP address

*** cmd

+ Open map as a listen server

  Open [map]?listen

+ Connect

  Connect 127.0.0.1

** Net Replication

*** =NetMode=

Property of UWorld depending how GameInstance has started up.
~UWorld::GetNetMode()~

|                    | Playable?                                                | Authority? | Open to clients?          |
|                    | GameInstance has LocalPlayer and process input&rendering |            | Can other people join in? |
|--------------------+----------------------------------------------------------+------------+---------------------------|
| =NM_Standalone=      | Yes                                                      | Yes        |                           |
| =NM_DedicatedServer= |                                                          | Yes        | Yes                       |
| =NM_ListenServer=    | Yes                                                      | Yes        | Yes                       |
| =NM_Client=          | Yes                                                      |            |                           |

=NetDriver=
=NetConnection=
=Channel=

*** Authority

#+begin_src cpp
if (HasAuthority())
{
    // This GameInstance is NM_Standalone
    // -OR- it's NM_DedicatedServer/NM_ListenServer
    // -OR- it's NM_Client and this actor was spawned on server
}
else
{
    // This GameInstance is NM_Client and this actor was spawned on server
}
#+end_src

+ APawn

  #+begin_src cpp
  IsLocallyControlled();
  #+end_src

+ APlayerController

  #+begin_src cpp
  IsLocalController();
  Cast<ULocalPlayer>(Player);
  #+end_src

+ Assertion

  #+begin_src cpp
  checkf(HasAuthority(), TEXT("This code should only run on the server!"));
  checkf(!HasAuthority(), TEXT("This code should only run on the client!"));
  checkf(IsLocallyControlled(), TEXT("Pawn must be locally controlled!"));
  #+end_src

*** Role & RemoteRole of Actor

#+begin_src cpp
enum ENetRole
{
    ROLE_None,            // HasAuthority() => false
    ROLE_SimulatedProxy,  // HasAuthority() => false
    ROLE_AutonomousProxy, // HasAuthority() => false
    ROLE_Authority,       // HasAuthority() => true
    ROLE_MAX,
}
#+end_src

+ =ROLE_Authority= :: Replicated object on the server (almost all), or non-replicated object on client.
+ =ROLE_SimulatedProxy= :: Replicated object controlled by _value replicated from server_.
+ =ROLE_AutonomousProxy= :: Replicated object relies on a client uploading values (usually human inputs) to the server (some values can still be server authoritative) to be replicated for other clients to simulate.

**** Mode of Replication

Predict movement between updates which replicate with =AActor::NetUpdateFrequency= might be low.

- =ROLE_SimulatedProxy= :: using last known velocity (can custom code to use some other information to extrapolate between server updates).
- =ROLE_AutonomousProxy= :: have a bit more information, and can use actual human inputs to fill in the missing info (rather than extrapolating based on the last known velocity).

**** e.g.

- Dedicated Server

  - Client 1 Character
    - Role :: Authority
    - RemoteRole :: Autonomous Proxy

  - Client 2 Character
    - Role :: Authority
    - RemoteRole :: Autonomous Proxy

- Client 1

  - Client 1 Character
    - Role :: Autonomous Proxy
    - RemoteRole :: Authority

  - Client 2 Character
    - Role :: Simulated Proxy
    - RemoteRole :: Authority

- Client 2

  - Client 1 Character
    - Role :: Simulated Proxy
    - RemoteRole :: Authority

  - Client 2 Character
    - Role :: Autonomous Proxy
    - RemoteRole :: Authority


*** Property Replication

eventually

#+begin_quote
Tips: RepNotify functions behavior different on C++ and blueprint, blueprint's OnRep also runs in server.
#+end_quote

**** header

#+begin_src cpp
  UPROPERTY(Replicated)
  int32 ActorProperty;

  UPROPERTY(ReplicatedUsing=OnRep_RunCodeWhenUpdatedProp)
  int32 RunCodeWhenUpdatedProp;

Private:

  UFUNCTION() void OnRep_RunCodeWhenUpdatedProp();
#+end_src

**** cpp

#+begin_src cpp
#include "Net/UnrealNetwork.h"

// Specify which properties should be replicated, and under what conditionsr
void AMyActor::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
    Super::GetLifetimeReplicatedProps(OutLifetimeProps);

    // replicated to all clients at all times
    DOREPLIFETIME(ThisClass, ActorProperty);

    DOREPLIFETIME_CONDITION(ThisClass, ActorProperty, COND_OwnerOnly);// COND_SkipOwner, COND_InitialOnly...
}

Void AMyActor::Foo()
{
    // Changing value on the server wili not automatically invoke the RepNotify function on server in C++
    if (HasAuthority())
    {
        RunCodeWhenUpdatedProp = 42;
        OnRep_RunCodeWhenUpdatedProp();// Manually call the RepNotify function
    }
}
#+end_src

*** RPCs (Remote Procedure Calls)

immediate, reserved for high-priority, time-critical network code

#+begin_src cpp
UFUNCTION(Client)
void Client_Foo();

UFUNCTION(Server)
voud Server_Foo();

UFUNCTION(NetMulticast)
void Multicast_Foo();

UFUNCTION(Reliable, Client) // Reliable RPC guaranteed to arrive and in order within a single actor
void Client_DoSomethingImportant();

UFUNCTION(Unreliable, Client) // Unreliable RPC can be dropped if bandwidth is saturared
void Client_DoSomethingNonEssential();

UFUNCTION(Unreliable, Server, WithValidation)
void Server_DoSomething();
void Server_DoSomething_Implementation();
bool Server_DoSomething_Validate();
#+end_src

_Implementation
_Validate

*** GameFramework

| Class             | Replication                    |
|-------------------+--------------------------------|
| AGameModeBase     | Server-only                    |
| AGameStateBase    | Replicated to all clients      |
| AGameSession      | Server-only                    |
| APlayerController | Replicated to owning client    |
| APlayerState      | Replicated to all clients      |
| APawn             | Replicated to relevant clients |
| AActor            | You decide!                    |

*** Actor Virtual Functions

**** APawn

| =NM_Standalone=                          | =NM_DedicatedServer=                     | =NM_Client=                              |
|----------------------------------------+----------------------------------------+----------------------------------------|
| =void PostInitProperties()=              | =void PostInitProperties()=              | =void PostInitProperties()=              |
| =void PreRegisterAllComponents()=        | =void PreRegisterAllComponents()=        | =void PreRegisterAllComponents()=        |
| =void PostRegisterAllComponents()=       | =void PostRegisterAllComponents()=       | =void PostRegisterAllComponents()=       |
| =void OnConstruction(const FTransform&)= | =void OnConstruction(const FTransform&)= | =void OnConstruction(const FTransform&)= |
| =void PreInitializeComponents()=         | =void PreInitializeComponents()=         | =void PreInitializeComponents()=         |
| =void PostInitializeComponents()=        | =void PostInitializeComponents()=        | =void PostInitializeComponents()=        |
| =void BeginPlay()=                       | =void BeginPlay()=                       | =void BeginPlay()=                       |
|----------------------------------------+----------------------------------------+----------------------------------------|
| =float TakeDamage(float, ...)=           | =float TakeDamage(float, ...)=           |                                        |
| =void PossessedBy(AController*)=         | =void PossessedBy(AController*)=         |                                        |
| =void UnPossessed()=                     | =void UnPossessed()=                     |                                        |
|----------------------------------------+----------------------------------------+----------------------------------------|
| =void PawnClientRestart()=               |                                        | =void PawnClientRestart()=               |
| =void Restart()=                         |                                        | =void Restart()=                         |
|----------------------------------------+----------------------------------------+----------------------------------------|
|                                        |                                        | =void PreNetReceive()=                   |
|                                        |                                        | =void PostNetReceive()=                  |
|                                        |                                        | =void PostNetInit()=                     |
|                                        |                                        | =void OnRep_Controller()=                |
|                                        |                                        | =void OnRep_PlayerState()=               |

*** Fast TArray Replication

+ Engine\Source\Runtime\Net\Core\Classes\Net\Serialization\FastArraySerializer.h

Fast TArray Replication is a custom implementation of NetDeltaSerialize that is suitable for TArrays of UStructs. It offers performance improvements for large data sets, it serializes removals from anywhere in the array optimally, and allows events to be called on clients for adds and removals. The downside is that you will need to have game code mark items in the array as dirty, and well as the *order* of the list is not guaranteed to be identical between client and server in all cases.

**** Step 1: Make your struct inherit from =FFastArraySerializerItem=

#+begin_src cpp
USTRUCT()
struct FExampleItemEntry : public FFastArraySerializerItem
{
    GENERATED_USTRUCT_BODY()

    // Your data:
    UPROPERTY()
    int32 ExampleIntProperty;

    UPROPERTY()
    float ExampleFloatProperty;

    /**
     * Optional functions you can implement for client side notification of changes to items;
     * Parameter type can match the type passed as the 2nd template parameter in associated call to FastArrayDeltaSerialize
     *
     * NOTE: It is not safe to modify the contents of the array serializer within these functions, nor to rely on the contents of the array
     * being entirely up-to-date as these functions are called on items individually as they are updated, and so may be called in the middle of a mass update.
     */
    void PreReplicatedRemove(const struct FExampleArray& InArraySerializer);
    void PostReplicatedAdd(const struct FExampleArray& InArraySerializer);
    void PostReplicatedChange(const struct FExampleArray& InArraySerializer);

    // Optional: debug string used with LogNetFastTArray logging
    FString GetDebugString();

};
#+end_src

**** Step 2: You MUST wrap your TArray in another struct that inherits from =FFastArraySerializer=

#+begin_src cpp
USTRUCT()
struct FExampleArray: public FFastArraySerializer
{
    GENERATED_USTRUCT_BODY()

    UPROPERTY()
    TArray<FExampleItemEntry> Items; /** Step 3: You MUST have a TArray named Items of the struct you made in step 1. */

    /** Step 4: Copy this, replace example with your names */
    bool NetDeltaSerialize(FNetDeltaSerializeInfo & DeltaParms)
    {
        return FFastArraySerializer::FastArrayDeltaSerialize<FExampleItemEntry, FExampleArray>( Items, DeltaParms, *this );
    }
};

/** Step 5: Copy and paste this struct trait, replacing FExampleArray with your Step 2 struct. */
template<>
struct TStructOpsTypeTraits< FExampleArray > : public TStructOpsTypeTraitsBase2< FExampleArray >
{
    enum
    {
        WithNetDeltaSerializer = true,
    };
};
#+end_src

**** Step 6 and beyond

- Declare a UPROPERTY of your FExampleArray (step 2) type.

- You MUST call MarkItemDirty on the FExampleArray when you change an item in the array. You pass in a reference to the item you dirtied.

  See =FFastArraySerializer::MarkItemDirty=.

- You MUST call MarkArrayDirty on the FExampleArray if you remove something from the array.

- In your classes GetLifetimeReplicatedProps, use DOREPLIFETIME(ThisClass, YourArrayStructPropertyName);

  You can provide the following functions in your structure (step 1) to get notifies before add/deletes/removes:

  #+begin_src
  void PreReplicatedRemove(const FFastArraySerializer& Serializer)
  void PostReplicatedAdd(const FFastArraySerializer& Serializer)
  void PostReplicatedChange(const FFastArraySerializer& Serializer)
  void PostReplicatedReceive(const FFastArraySerializer::FPostReplicatedReceiveParameters& Parameters)
  #+end_src

That's it!

*** Replication Graph

The Replication Graph Plugin is a system for network replication in multiplayer games that is designed to scale well with large numbers of players and replicated Actors.

*** Push Model

Engine\Source\Runtime\Net\Core\Public\Net\Core\PushModel\PushModel.h

**** Unreal Engine 4. New network model: PushModel

#+BEGIN_QUOTE
In the standard Unreal Engine network architecture, the server checks if the value of the replicated Actor class variable has changed, and in case of a difference, the value is synchronized between the server and the client. When the amount of data to sync is small, there are no particular performance issues.

However, a game can often consist of a huge set of Actors and variables that need to be replicated to one or more clients, and this can already become a problem area.

UE already provides features like: NetUpdateFrequency, NetCullDistanceSquared, etc. The main task of which is to eliminate from the general replication picture as many actors as possible who do not need to constantly synchronize data.

PushModel is, for now, an experimental feature that can allow developers to actively mark the need to synchronize a property, several macros are provided for this:
#+END_QUOTE
#+begin_src cpp
// These macros set a specific variable to mark the need for synchronization, and the server, in turn, removes the need to constantly check for changes in value.
#define MARK_PROPERTY_DIRTY(Object, Property)
#define MARK_PROPERTY_DIRTY_STATIC_ARRAY_INDEX(Object, RepIndex, ArrayIndex)
#define MARK_PROPERTY_DIRTY_STATIC_ARRAY(Object, RepIndex, ArrayIndex)

#define MARK_PROPERTY_DIRTY_FROM_NAME(ClassName, PropertyName, Object)
#define MARK_PROPERTY_DIRTY_FROM_NAME_STATIC_ARRAY_INDEX(ClassName, PropertyName, ArrayIndex, Object)
#define MARK_PROPERTY_DIRTY_FROM_NAME_STATIC_ARRAY(ClassName, PropertyName, ArrayIndex, Object)
#+end_src

***** How to set up PushModel

+ First of all, in Build.cs, you need to add to exclude compilation problems

#+begin_src csharp
PublicDependencyModuleNames.AddRange(new string[]  {"NetCore"});
#+end_src

+ Secondly, mark the necessary variables =UPROPERTY(Replicated)= or =(ReplicatedUsing)=, =GetLifetimeReplicatedProps=, =DOREPLIFETIME_WITH_PARAMS=, =DOREPLIFETIME_WITH_PARAMS_FAST=, =DOREPLIFETIME=, =DOREPLIFETIME_CONDITION=.

#+begin_src cpp
void ASomeActor::GetLifetimeReplicatedProps(TArray< class FLifetimeProperty > & OutLifetimeProps) const
{
    Super::GetLifetimeReplicatedProps(OutLifetimeProps);

    FDoRepLifetimeParams SharedParams;
    SharedParams.bIsPushBased = true;

    SharedParams.Condition = COND_OwnerOnly;
    DOREPLIFETIME_WITH_PARAMS_FAST(ThisClass, SomeVar, SharedParams);

    SharedParams.Condition = COND_InitialOnly;
    DOREPLIFETIME_WITH_PARAMS_FAST(ThisClass, PlayerId, SharedParams);
    DOREPLIFETIME_WITH_PARAMS_FAST(ThisClass, bIsABot, SharedParams);
}
#+end_src

#+begin_src cpp
void ASomeActor::SetSomeVar(const float SomeValue)
{
    MARK_PROPERTY_DIRTY_FROM_NAME(ThisClass, SomeVar, this);
    SomeVar = SomeValue;
}
#+end_src

Detailed usage examples can be found in the APlayerState class in the engine.

+ About =FDoRepLifetimeParams=

#+begin_src cpp
/**
 * Struct containing various parameters that can be passed to DOREPLIFETIME_WITH_PARAMS to control
 * how variables are replicated.
 */
struct ENGINE_API FDoRepLifetimeParams
{
  /** Replication Condition. The property will only be replicated to connections where this condition is met. */
  ELifetimeCondition Condition = COND_None;

  /**
   * RepNotify Condition. The property will only trigger a RepNotify if this condition is met, and has been
   * properly set up to handle RepNotifies.
   */
  ELifetimeRepNotifyCondition RepNotifyCondition = REPNOTIFY_OnChanged;

  /** Whether or not this property uses Push Model. See PushModel.h */
  bool bIsPushBased = false;
};
#+end_src

*** Iris Replication

** Platform

*** Steam

* Scripting

** Blueprint

*** *Blueprint Communications*

**** *Direct Communication*

+ When to Use It
  Basically, you know everything that could ever happen between these two things, you just need to make something happen.
+ 1-to-1 communication
  use flow control techniques such as Loops to talk to many things
+ Sender need reference to receiver

***** Casting

to verify what you're talking to

**** *Blueprint Interface* message calls

+ When to Use Them
  You just want to send a signal to an object; if they know what to do with it, great!
+ 1-to-1 communication
+ Sender need reference to receiver
  only receivers actually need to implement an interface
  Receiver can call that functionality on itself

***** Trace

cast ray or volume

***** asset in Content Browser

****** Create them in the Content Browser

(right click > Blueprints submenu > Blueprint Interface)

****** In the Blueprint Interface Editor, you automatically get your first function.

+ You can setup inputs/outputs if you like.
+ You can't set up any functionality (no other nodes)
  In fact, the graph is grayed out and locked!
+ eg. Event graph on Sender
#+ATTR_HTML: width="1000px"
#+ATTR_ORG: :width 1000
[[file:./images/blueprint_interface_sender.webp]]

****** Implement the Interface

+ In the receiving class, go under Class Settings.
+ Under Implemented Interfaces, add your new Interface.
+ _Recompile_
+ You can now create an event in your graph named the same thing as your function!
+ Now when this class receives the message for that Interface function, something happens!

***** send Interface Messages

+ sender don't even care if receiver knows the signal
+ fail silently unless implement the interface onto receiver

***** Interfaces can be used for communication between *sub-levels*

+ only work on sub-level is (always) streamed in
#+ATTR_HTML: width="600px"
#+ATTR_ORG: :width 600
[[file:./images/blueprint_interface_level_comm.webp]]

**** *Event Dispatchers*

+ Receiver need reference to Sender
+ no return value

***** They're a lot like *Twitter*

+ You set up an Event Dispatcher on the *sender*
  This is like _setting up a Twitter account_
+ Any number of Receivers can *Bind* to this Event Dispatcher
  This is like the _Receiver(s) following_ the Sender's Twitter feed
  NOTE: Receiver will need some initial reference to the Sender to make the Bind!
+ The Sender Calls the Event Dispatcher
  This is like _making a Tweet_, which is just sent out into the ether
  There may be no one following the Sender, so maybe no one gets the Tweet
+ The Receivers who had an Event Bound to that Event Dispatcher can then react accordingly
  _Followers saw_ the Tweet and do something in response

***** Make sure unbind on Destroyed

#+ATTR_HTML: width="400px"
#+ATTR_ORG: :width 400
[[file:./images/event_dispatchers_unbind_on_destroyed.webp]]

***** C++ equivalent

+ setup the Event Dispatcher in the sender
  Declare Delegate (UPROPERTY(BlueprintAssignable))
+ Bind receiver's own Custom Event to that Dispatcher
  Bind Event to the delegate
+ Signatures are a specific combination of inputs on a Dispatcher
  Declare delegate macro, create a matching event in receiver
+ Call the Event Dispatcher
  Delegate.Broadcast()

*** =BlueprintImplementableEvent= vs =BlueprintNativeEvent= usage

- =BlueprintImplementableEvent= can be only be defined in blueprint.
- =BlueprintNativeEvent= will declare extra special virtual function with _Implementation surrfix in generated code which you can override and call it when event is called in C++ and blueprint as well as you can define this event in blueprint to. If you use BlueprintNativeEvent you WILL NEED to define _Implementation function or else you gonna have linker errors.

#+begin_src cpp
UFUNCTION(BlueprintNativeEvent)
void OnDeath();

// You can create a native implementation if blueprint is not override it.
void OnDeath_Implementation();

// vs

virtual void OnDeath();

// call this in native OnDeath().
UFUNCTION(BlueprintImplementableEvent, meta=(DisplayName = "OnDeath"))
void K2_OnDeath();
#+end_src

*** Blueprint Node

**** Node Parameters

References that are _const_ are always *input* parameters

References are _non-const_ are always *output* parameters, use =UPARAM(ref)= to convert them to input parameters

#+begin_src cpp
UFUNCTION(BlueprintCallable, Category = "Test")
void MyTestFunction(
    const TArray<float>& inParam1,       // Input parameter, required
    UPARAM(ref) TArray<float>& inParam2, // Input parameter, required
    TArray<float>& outParam1,              // Output parameter
    const AActor* inParam3,              // Input parameter, not required
    UPARAM(ref) AActor* inParam4,        // Input parameter, required
    AActor* inParam5,                    // Input parameter
    AActor*& outParam2,                    // Output parameter
    const int32 inParam6,                // Input parameter, not required
    UPARAM(ref) int32 inParam7,          // Input parameter, required
    int32 inParam8,                      // Input parameter, not required
    const int32& inParam9,               // Input parameter, required
    int32& outParam3                       // Output parameter
);
#+end_src

#+ATTR_HTML: width="500px"
#+ATTR_ORG: :width 500
[[file:./images/ufunction_input_output_parameters.webp]]

+ Rename Parameter or Return Value Pin

  ~UPARAM(DisplayName = "FooBar")~

**** Multi Execs Pin (Branch)

#+begin_src cpp
UENUM()
enum class EMultiOutputExecPin : uint8
{
    _True = 1,
    _False = 0,
};
#+end_src

#+begin_quote
you can use the name =then= for an unlabeled pin
#+end_quote

#+begin_src cpp
UFUNCTION(BlueprintCallable, meta = (ExpandEnumAsExecs = "Result"))
void MyIfNode(bool Value, EMultiOutputExecPin& Result) {// MultiInput - EMultiOutputExecPin Result
    Result = Value ? EMultiOutputExecPin::_True : EMultiOutputExecPin::_False;
}
#+end_src

#+begin_quote
~ExpandEnumAsExecs = "ReturnValue"~ will also work... for the return value
#+end_quote

~meta = (ExpandBoolAsExecs = "ReturnValue")~ for boolean return value.

**** Blueprint Async Node

***** =UBlueprintAsyncActionBase=

****** header

#+begin_src cpp
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FMyAsyncNodeResult, int32, Result);

UCLASS()
class UMyBlueprintAsyncActionBase : public UBlueprintAsyncActionBase
{
    GENERATED_BODY()

    UPROPERTY(BlueprintAssignable)
    FMyAsyncNodeResult OnSuccess;

    UPROPERTY(BlueprintAssignable)
    FMyAsyncNodeResult OnFail;

    UFUNCTION(BlueprintCallable)
    static UMyBlueprintAsyncActionBase* UMyBlueprintAsyncActionBase::FooNode();
};
#+end_src

****** cpp

#+begin_src cpp
UMyBlueprintAsyncActionBase* UMyBlueprintAsyncActionBase::FooNode()
{
    UMyBlueprintAsyncActionBase* Node = NewObject<UMyBlueprintAsyncActionBase>();

    if ()
    {
        Node->OnSuccess.Broadcast(SuccessResult);
    }
    else
    {
        Node->OnFail.Broadcast(FailResult);
    }

    return Node;
}
#+end_src

***** UCancellableAsyncAction(: =UBlueprintAsyncActionBase=) and ExposedAsyncProxy

need to be explicitly canceled or ended normally to go away

https://mikelis.net/easy-c-latent-functions-in-unreal-engine-blueprints/

***** Latent Node

https://www.youtube.com/watch?v=h_CX0ZitGXg

** Verse

* *AI*

** Behavior Tree

*** "body-soul-brain" pattern

+ "body" is the visual representation of the character
+ "soul" being the entity that control it at that moment
+ "brain" what defines its behavior
+ "memory" where it stores the information it needs to behave
#+ATTR_HTML: width="900px"
#+ATTR_ORG: :width 900
[[file:./images/pawns_and_controller_relationship.webp]]

*** Behavior Trees

describe switching between a finite set of tasks

**** Execution Flow

#+ATTR_HTML: width="500px"
#+ATTR_ORG: :width 500
[[file:./images/behavior_tree_execution_flow.webp]]

**** Composites

Define the *root* of a branch and the base rules for how that branch is *executed*
+ Sequence
  Execute *every child* in order, until one of them fails
+ Selector
  Find and execute the *first child* that does not fail

**** Decorators (Conditionals)

Define *whether or not* a branch in the tree, or even a single node, *can be executed*

**** Services

Will *execute at their defined frequency* as long as their branch is being executed

**** Tasks

*Node that "do" things*, like move to, or adjust Blackboard values
They can have Decorators or Services attached to them

*** Blackboard

*** Perception System

Provides a way for Pawns to receive data from the environment, such as *noises*, *damaged* by something or *see* something.

accomplished with the *AI Perception Component* gathers registered *Stimuli Sources(component)*.

+ Debug view
  '(apostrophe) 4(num)

** Navigation

NavMesh

*** UNavLinkCustomComponent

e.g. enable/disable NavLink when door open/close.

** Mass Framework

*** ZoneGraph

* *Programming*

** C++ Required

+ OOP
+ Polymorphism
+ Reflection and Garbage Collection (Unreal Implement)

** Container

TArray is good at iteration, and TMap is good at lookup.

*** =TArray=

**** Memory Allocate

#+begin_src cpp
// Data allocated on heap, TArray itself is on stack
TArray<int32> RegularTArray = { 1, 2, 3, 4, 5 };

// Length 4 array on stack
TArray<int32, TInlineAllocator<4>> CustomStackAllocatorTArray = { 1, 2, 3 };

// c-style length 4 array on stack
int32 CArray[4] = { 1, 2, 3, 4 };
#+end_src

#+begin_src cpp
// passing reference of TArray is limiting, doesn't work generically for custom stack allocated TArray or c array.
auto FuncTakingSpecificType = [](const TArray<int32>& MyArray){
    int32 Sum = Algo::Accumulate(MyArray, 0);
    return Sum;
};

FuncTakingSpecificType(RegularTArray);
//FuncTakingSpecificType(CustomStackAllocatorTArray); // compile error
//FuncTakingSpecificType(CArray); // complie error

// You can use TArrayView instead
auto FuncTakingView = [](TArrayView<int32>& MyView){
    int32 Sum = Algo::Accumulate(MyView, 0);
    return Sum;
};

FuncTakingView(RegularTArray);
FuncTakingView(CustomStackAllocatorTArray);
FuncTakingView(CArray);
#+end_src

**** Sort (in 2023)

#+begin_quote
Thanks to =Laura= from discord.
#+end_quote

TArray's Sort is a non-static member, but it's strictly worse than =Algo::Sort()=.

TArray::Sort() dereferences pointers, Algo::Sort doesn't.

Use =std::sort()= and =std::stable_sort()= (=eastl::sort()= is faster, or at least =Algo::Sort()= or =Algo::StableSort()=).

#+begin_src cpp
#include <algorithm>

TArray<int> x;
std::sort(x.GetData(), x.GetData() + x.Num(), ...);
#+end_src

#+begin_src cpp
std::sort(FilteredSlots.GetData(), FilteredSlots.GetData() + FilteredSlots.Num(), [this, bReverseSort](UItemSlot* SlotA, UItemSlot* SlotB)
{
    const FEntityTraits& SlotATraits = SlotA->GetEntityTraits();
    const FEntityTraits& SlotBTraits = SlotB->GetEntityTraits();

    UInventoryDevSettings& DevSettings = UInventoryDevSettings::Get();

    const int32& SlotARarity = *DevSettings.ItemRaritySortOrder.Find(SlotATraits.TagTraits.FindRef(TAG_Entity_Trait_Tag_Entity_Rarity));
    const int32& SlotBRarity = *DevSettings.ItemRaritySortOrder.Find(SlotBTraits.TagTraits.FindRef(TAG_Entity_Trait_Tag_Entity_Rarity));

    return (SlotARarity < SlotBRarity) ^ bReverseSort;
});// Munkeysocks from discord
#+end_src

**** TArrayView

TArrayView are cheap, they reference the memory not copy it. You can assign array view to TArray, custom stack allocated TArray or a c array.

array views cannot change size, but you can modify value on the array.

#+begin_quote
You can't use this type in Blueprint.
#+end_quote

***** Mutability

const does not propagate for TArrayView, a const array view not make elements const.

#+begin_src cpp
#include "Containers/ArrayView.h"

TArray<int32> MutableArray = { 1, 2, 3 };
const TArrayView<int32> ConstButMutableView = MutableArray;

// still mutable
ConstButMutableView[0] = 123;

// make elements const to protect values
TArrayView<const int32> ConstEntryArrayView = MutableArray;
// or TConstArrayView<int32> EntryConstArrayView = MutableArray;
ConstArrayView[0] = 123; // compile error
#+end_src

***** Lifetime

TArrayView's lifetime should be shorter than the array, assign a temporary array to array view could cause undefined behavior.

Also, do not modify the size of array while array view is in scope.

*** =TSet=

*** =TMap=

**** Iterate TMap

#+begin_src cpp
for (const auto& [Key, Value] : YourMap)
{
}
#+end_src

** Cast

That's the point, in C++ you would usually use =dynamic_cast= in your case but UE has _RTTI disabled_, which does runtime evaluation.

=static_cast= just makes sure the type exists and appropriate conversion can be performed, it's completely on you to make sure the object is actually of the type you are trying to cast too.

** *Logging*

#+begin_quote
neither log/logfmt like boolean IIRC,
use bMyBool ? TEXT("True") : TEXT("False") or bMyBool ? 1 : 0
#+end_quote

*** =UE_LOG= (old)

#+begin_src cpp
int myInt{ 42 }; // Use Aggregate initialization
float myFloat{ 3.14f };
bool myBool{ true };
UE_LOG(LogTemp, Warning, TEXT("int: %d, float: %f, bool: %d"), myInt, myFloat, myBool);

FString mtString{ TEXT("My String!") };
UE_LOG(LogTemp, Warning, TEXT("%s: FString mtString: %s"), ANSI_TO_TCHAR(__FUNCTION__), *myString);
UE_LOG(LogTemp, Warning, TEXT("Name of Instance: %s"), *GetName());
UE_LOG(LogTemp, Warning, TEXT("Name of Actor: %s"), *GetNameSafe(myActor));  // GetNameSafe will return TEXT("None") if myActor is nullptr
// The asterisk(*) here is not dereference but a overload to convert FString Object to C style string (const TCHAR array)
#+end_src

*** =UE_LOGFMT= (Structured Log)

- support basic types and some core engine types (FString, TArray, FDateTime, etc.)

  #+begin_src cpp
  #include "Logging/StructuredLog.h"

  // positional parameters
  UE_LOGFMT(LogTemp, Log, "The actor {0} in {1} {2} on {3}.",  // 0-16 fields values
      GetName(), locationVector.ToString(), "jumped", FDateTime::Today());
  // print LogTemp: The actor character0 in X=0 Y=0 Z=0 jumped on 2042-04-02T00:00:00.000Z.

  // named parameters
  UE_LOGFMT(LogTemp, Log, "The actor {Name} in {Location} {Action} on {Time}.",  // 0-16 fields values
      ("Name", GetName()), ("Location", locationVector.ToString()), ("Action", "jumped"),
      ("Time", FDateTime::Today()));
  // print LogTemp: The actor character0 in X=0 Y=0 Z=0 jumped on 2042-04-02T00:00:00.000Z.

  // localized logging
  UE_LOGFMT_LOC(CategoryName, Verbosity, Key, Format, ...)
  UE_LOGFMT_NSLOC(CategoryName, Verbosity, Namespace, Key, Format, ...)
  #+end_src

- support custom serialization for any type (=operator<<(FCbWriter&, FieldType)=)

  #+begin_src cpp
  struct FCoolType
  {
      bool bIsCool = false;
      int32 CoolRating = 0;
  };

  FCbWriter& operator<<(FCbWriter& Writer, const FCoolType& Data)
  {
      Writer.BeginObject();
      Writer << "IsCool" << Data.bIsCool;
      Writer << "CoolRating" << Data.CoolRating;
      Writer.EndObject();

      return Writer;
  }
  #+end_src

  #+begin_src cpp
  FCoolType CoolData = { true, 1337 };
  FCoolType UncoolData = { false, 0 };

  UE_LOGFMT(LogCool, Log, "{Data1} vs {Data2}", CoolData, UncoolData);
  // print LogCool: {"IsCool":true,"CoolRating":1337} vs {"IsCool":false:,"CoolRating":0}
  #+end_src

*** Useful Parameter

| LOGFMT Parameter                                | Description                                        | header               | old log format                                                                       |
|-------------------------------------------------+----------------------------------------------------+----------------------+--------------------------------------------------------------------------------------|
| ~std::source_location::current().file_name()~     | The file name. (C++20)                             | ~<source_location>~    |                                                                                      |
| ~std::source_location::current().function_name()~ | The function name. (C++20)                         | ~<source_location>~    | %hs or %s with ~ANSI_TO_TCHAR()~ / ~StringCast<TCHAR>().Get()~                           |
| ~std::string~                                     | STL char string                                    | ~<string>~             | %hs with ~Foo.c_str()~                                                                 |
| ~__func__~                                        | The function name. (C++11, variable)               |                      | %hs with ~__func__~ or %s with ~ANSI_TO_TCHAR(__func__)~ / ~StringCast<TCHAR>(__func__).Get()~ |
| ~__Function__~                                    | The function name. (macro, not standardized, MSVC) |                      | ~ANSI_TO_TCHAR(__FUNCTION__)~ or ~StringCast<TCHAR>(__FUNCTION__).Get()~                     |
| ~GetNameSafe(Object)~                             | Return TEXT("None") if nullptr                     |                      | ~*GetNameSafe()~                                                                       |
| ~FDataTime::Today()~                              | Return ISO 8601 format date of today.              | ~"Misc/DateTime.h"~    | ~*FDataTime::Today().ToString()~                                                       |
| ~FPlatformTime::Seconds()~                        |                                                    | ~"HAL/PlatformTime.h"~ | ~FPlatformTime::Seconds()~                                                             |
| Foo.ToString()                                  |                                                    |                      | ~*Foo.ToString()~                                                                      |
| Foo->GetType()                                  | Type of foo.                                       |                      | ~*Foo->GetType()~                                                                      |
| Foo->GetName()                                  | Name of foo.                                       |                      |                                                                                      |
| Foo->GetPath()                                  | Path of foo.                                       |                      |                                                                                      |

#+begin_src cpp
#if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)
#endif // #if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)
#+end_src

*** =UE_VLOG= (Visual Logger)

To activate the Visual Logger, use Windows > Developer Tools > Visual Logger

#+begin_src cpp
#include "VisualLogger/VisualLogger.h"
#+end_src

[[https://dev.epicgames.com/documentation/en-us/unreal-engine/visual-logger-in-unreal-engine]]

**** Logging Text

**** Drawing Debug Shapes

**** Taking Actor Snapshots

*** AbilitySystemLog

#+begin_src cpp
#include "AbilitySystemLog.h"

ABILITY_LOG(Warning, TEXT(""));
// same to UE_LOG(LogAbilitySystem, Warning, TEXT(""));
#+end_src

*** Log Verbosity Levels

| Verbosity Level       | Printed in Console? | Printed in Editor's Log? | Notes                                            | Intend                                                                          |
|-----------------------+---------------------+--------------------------+--------------------------------------------------+---------------------------------------------------------------------------------|
| Fatal (Lowest)        | Yes                 | N/A                      | Crashes the session, even if logging is disabled |                                                                                 |
| Error                 | Yes                 | Yes                      | Log text is coloured red                         |                                                                                 |
| Warning               | Yes                 | Yes                      | Log text is coloured yellow                      |                                                                                 |
| Display               | Yes                 | Yes                      | Log text is coloured grey                        |                                                                                 |
| Log                   | No                  | Yes                      | Log text is coloured grey                        | This happened. What gameplay programmers may care about to debug                |
| Verbose               | No                  | No                       |                                                  | This is why this happened. What you may turn on to debug the skill system code. |
| VeryVerbose (Highest) | No                  | No                       |                                                  | This is what didn't happen, and why. Extreme printf debugging                   |

*** Custom Log Categories

- header

  #+begin_src cpp
  DECLARE_LOG_CATEGORY_EXTERN(LogCustom, Log, All);
  // DECLARE_LOG_CATEGORY_EXTERN(CategoryName, DefaultVerbosity, CompileTimeVerbosity)
  // Anything more verbose than CompileTimeVerbosity will not be compiled
  #+end_src

- cpp

  #+begin_src cpp
  DEFINE_LOG_CATEGORY(LogCustom);
  #+end_src

*** Printing Messages to Screen

#+begin_src cpp
GEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::White, TEXT("This message will appear on the screen!"));
GEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::White, *FString::Printf(TEXT("%s Num Tile(s): %d"), *SequenceInfo.Name.ToString(), NumVisibleTiles));

#define PRINTSCREEN(Duration, Color, _Text, ...) if (GEngine) GEngine->AddOnScreenDebugMessage(-1, Duration, Color, FString::Printf(_Text __VA_OPT__(,) __VA_ARGS__), true, FVector2D::UnitVector);
#+end_src

*** Viewport Stats Subsystem

#+begin_quote
UE4.26 adds the Viewport Stats Subsystem, allowing to add messages to the current viewport such as "LIGHTING NEEDS TO BE REBUILT" and "BLUEPRINT COMPILE ERROR". Following code sample is copy-pasted directly from this class. Simply inspect this class to check all available options.
#+end_quote

#+begin_src cpp
if (UViewportStatsSubsystem* ViewportSubsystem = GetWorld()->GetSubsystem<UViewportStatsSubsystem>())
{
    // Bind a member function delegate to the subsystem...
    FViewportDisplayCallback Callback;
    Callback.BindDynamic(this, &UCustomClass::DisplayViewportMessage);
    ViewportSubsystem->AddDisplayDelegate(Callback);

    // ... or use inline lambda functions
    ViewportSubsystem->AddDisplayDelegate([](FText& OutText, FLinearColor& OutColor)
    {
        // Some kind of state management
        OutText = NSLOCTEXT("FooNamespace", "Blarg", "Display message here");
        OutColor = FLinearColor::Red;
        return bShouldDisplay;
    });
}
#+end_src

*** Diagnostic Checks (*Asserts*)

| Macro                                | Behavior                                                                                                                                            |
|--------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------|
| =check(Expression);=                   | only evaluate =Expression= and assert with a halt dialog if =Expression= is false in _non-shipping builds_                                                |
| =checkSlow(Expression);=               | only evaluate =Expression= and assert with a halt dialog if =Expression= is false in _debug builds_                                                       |
| =checkf(exp, FormattedText, ...);=     | same as =check=, outputs =FormattedText= to the log                                                                                                     |
| =checkfSlow(exp, FormattedText, ...);= | same as =checkSlow=, outputs =FormattedText= to the log                                                                                                 |
| =checkNoEntry();=                      | code that should be unreachable (default in switch), similar to check(false), require =DO_CHECK=1=                                                    |
| =checkNoReentry();=                    | halts execution if the line is hit more than once                                                                                                   |
| =checkNoRecursion();=                  | halts execution if the line is hit more than once without leaving scope                                                                             |
| =unimplemented();=                     | don't use it, use pure virtual function instead                                                                                                     |
| =verify(Expression);=                  | always evaluate =Expression=, but only assert with a halt dialog if =Expression= is false in _non-shipping builds_                                        |
| =verifySlow(Expression);=              | always evaluate =Expression=, but only assert with a halt dialog if =Expression= is false in _debug builds_                                               |
| =ensure(Expression);=                  | always evaluate =Expression=, but notifies the crash reporter (output log) on the first time rather than halting if =Expression= is false in _all builds_ |

e.g. typical usage

#+begin_src cpp
// I need an actor to work with, and can't continue without one
check(actor != nullptr);

// UpdatePlayer() needs to always run, but can continue in shipping builds even if it fails
verify(UpdatePlayer() == true);

// I want to print current call stack info when exp is false
ensureMsgf(vehicleIndex < Vehicles.Num, TEXT("Bad vehicleIndex"));

if (vehicleIndex < Vehicles.Num)
{
    // ensureMsgf will have reported the failure, but we can handle it anyway
}
#+end_src

If assert parameters is required to run on all builds, don't use =check=, use =verify= instead

If it's just for debugging purposes and isn't required to run on a _shipping build_, then =check= is just fine

The extra =checkSlow= and =verifySlow= are for doing extended validation (require =DO_GUARD_SLOW=1=, i.e. in _debug builds_)

=check= and =verify= kill the process for people trying to work, use them sparingly, think of them as a big, red abort button

=ensure= is often not visible enough, search for *=== Handled ensure: ===* where exceptions occurred

=DO_CHECK=USE_CHECKS_IN_SHIPPING= in _test and shipping (without editor) build_

**** Check

=Expression= might NOT be evaluated in _shipping build_, only evaluate =Expression= if =DO_CHECK=1=

The Check family is the closest to the base assert, in that members of this family halt execution when the first parameter evaluates to a false value, and do not run in shipping builds by default.

**** Verify

behaves identically to =check= when =DO_CHECK=1=, ensure =Expression= will be evaluated

This means that you should use Verify macros only when the expression needs to run independently of diagnostic checks. For example, if you have a function that performs an action and then returns a bool indicating whether that action succeeded or failed, you should use Verify rather than Check to make sure that the action was successful. This is because, in shipping builds, Verify will ignore the return value, but will still perform the action. Check, however, will simply not call the function at all in shipping builds, resulting in different behavior.

**** Ensure

The Ensure family is similar to the Verify family, but works with non-fatal errors. This means that if an Ensure macro's expression evaluates as false, the Engine will inform the crash reporter, but will continue running. In order to avoid flooding the crash reporter, Ensure macros will only report once per Engine or Editor session. If your use case requires that an Ensure macro report every time its expression evaluates as false, use the "Always" version of the macro.

*** *Scripting And Automation*

**** Editor Widgets

Build own tools

**** Python

***** Setup

Enable "Python Editor Script Plugin"

***** Usage

+ cmd open new line
  Shift + Enter
+ Access Asset Property
  #+begin_src python
  import unreal

  your_asset = unreal.load_asset('/Refrence/path/to/assrt')
  prop = your_asset.get_editor_property("property_name")
  print prop
  prop = your_asset.set_editor_property("property_name", value)
  #+end_src
  - Use Get/Set Method
    access property not exposed to blueprint but editor
    there is a post-change hook to rebuild asset
+ Script Path
  #+begin_src python
  import sys
  for path in sys.path:
      print path

  import os
  os.makedirs("UE/Engine/Content/Python")
  os.startfile("UE/Engine/Content/Python")
  #+end_src
+ =init_unreal.py=

** =FString= & =FText= & =FName=

| Class   | Bytes | Case        | Localization  | Usage                         |
|---------+-------+-------------+---------------+-------------------------------|
| =FString= |    40 | Sensitive   | Not localized | ?                             |
| =FText=   |    16 | Sensitive   | Localized     | for all text shown to players |
| =FName=   |     4 | Insensitive | Not localized | for IDs                       |

- =FString= objects store their own character arrays.
- =FText= and =FName= store an index to a shared character array, establish equality by index value.

*** =FString=

Can be searched, modified, and compared against other strings. (Mutable)

*** =FText=

The primary component for text localization, all user-facing text should use this class.

- =AsCultureInvariant()= or =INVTEXT= macro for localization.
- create a blank FText using either =FText::GetEmpty()=, or just =FText()=.

*** =FName=

FNames are case-*insensitive*. They are immutable, and cannot be manipulated.

FNames with spaces is not recommended, it's bad is certain contexts (such as component names).

*** =TEXT()= Macro

the TEXT macro exists because different platforms use different text char sizes, just makes sure that the raw string you pass becomes a proper string like from "hello" to L"hello".

#+begin_src cpp
"Hello World!";             // An ANSI character (8-bit fixed-width)  strlen("Hello") = 5;
L"Hello World!";            // In-memory only. wchar_t strlen(L"Hello") = 10;
TEXT("Hello World!");       // In-memory only. with portability

// Use TCHAR* type
const TCHAR* TcharString = TEXT("Hello World!");
#+end_src

- FName don't need TEXT macro

  #+begin_src cpp
  FName("foo");
  #+end_src

  therefore CDSO(=CreateDefaultSubobject<>(FName SubobjectName, ...)=) don't need TEXT macro.
  it's redundant and adds a teensy bit of overhead.

** =FInstancedStruct=

FInstancedStruct is a polymorphic wrapper for any other USTRUCT(), with complete reflection support. You can safely keep *any* data inside it (Arrays, Object refs, even other USTRUCT(), and you can pass it to UFUNCTION, store as UPROPERTY etc.)

#+begin_quote
In the past, building any kind of "generic" UFUNCTION or UPROPERTY in UE that would accept/store arbitrary data meant using UObject instances. This adds a lot of overhead and boilerplate for something so simple, and Epic are about to make it more difficult.
#+end_quote

FInstancedStruct do not support delta replication since the underlying type could change, so it replicated atomically.

The only reason to use TInstancedStruct(the type-safe wrapper) over FInstancedStruct is to restrict the type at compile time.

#+begin_src cpp
UPROPERTY(EditAnywhere)
FMyStruct MyStruct; // you get properties from FMyStruct

UPROPERTY(EditAnywhere, meta = (BaseStruct = "/Script/MyModule.MyStruct", ExcludeBaseStruct))
FInstancedStruct MyStruct; // you get to select any subclass of FMyStruct and then fill out those properties
#+end_src

#+begin_quote
the metadata for what type an ~FInstancedStruct~ accepts is editor-only, ~TInstancedStruct~ validates at compile time but it doesn't actually pass its metadata along anywhere.
#+end_quote

*** =FStructView= & =FConstStructView=

#+begin_src cpp
#include "StructUtils/StructView.h"
#+end_src

*** Blueprint

#+begin_quote
I think you can use UPARAM(meta = (BaseStruct = "blah")) to limit the struct type
#+end_quote

*** Snippet

#+begin_src cpp
#include <concepts>
#include "StructUtils/InstancedStruct.h"
#include "StructUtils/StructView.h"

    template<std::derived_from<FEquipmentFragmentBase> T>
    FConstStructView GetEquipmentFragment();

template<std::derived_from<FEquipmentFragmentBase> T>
inline FConstStructView UEquipmentInstance::GetEquipmentFragment()
{
    if (not EquipmentFragments.IsEmpty())
    {
        for (const TInstancedStruct<FEquipmentFragmentBase>& Entry : EquipmentFragments)
        {
            if (Entry.IsValid() &&
                Entry.GetScriptStruct()->IsChildOf(TBaseStructure<T>::Get()))
            {
                return FConstStructView::Make(Entry.Get<T>());
            }
        }
    }

    static FConstStructView InvalidView;
    return InvalidView;
}
#+end_src

** Property Bag

** ~TOptional~

=TOptional= is for optional parameters could be unset(null), or to explicitly indicate a primitive data type is not initialized (e.g. a unset boolean variable instead of =false=).

#+begin_src cpp
IsSet()
GetValue()
#+end_src

*** About Named return value optimization (NRVO)

NRVO eliminates the unnecessary copying of objects returned from a function by reusing the same memory location that was used for the object inside the function.

#+begin_quote
For NRVO all return paths must return the same name.
#+end_quote

#+begin_src cpp
// Maybe will NOT optimized due to difference of type local variable and function return type
TOptional<Foo> Func()
{
    Foo v = Foo();
    return v;
}

// Better for NRVO
TOptional<Foo> Func()
{
    TOptional<Foo> v;
    v = Foo();
    return v;
}
#+end_src

** ~TGuardValue~

Sets a value, then resets it when it goes out of scope.

#+begin_src cpp
{
    TGuardValue<bool> GuardSomeBool(bSomeBool, false); // Sets bSomeBool to false, and restores it in dtor.
} // bSomeBool restores its original value here.
#+end_src

** ~TNotNull~

Hit a Check assertion in *non-shipping* build, has no effect in shipping build.

Mainly for UFUNCTION parameter that has to be a pointer, and you don't want the value to be null. Otherwise, use *reference* instead of this wrapping a pointer.

** Smart Pointer =:Deleter=

cannot be used with the UObject system

*** =TSharedPtr<>=

#+begin_src cpp
MakeShared<>();
#+end_src

*** =TSharedRef<>=

always reference a non-null object

cannot change referencing object

*** =TWeakPtr<>=

Weak Pointers are similar to Shared Pointers, but do not own the object they reference, and therefore do not affect its lifecycle. This property can be very useful, as it breaks reference cycles, but it also means that a Weak Pointer can become null at any time, without warning. For this reason, a Weak Pointer can produce a Shared Pointer to the object it references, ensuring programmers safe access to the object on a temporary basis.

*** =TUniquePtr<>=

Since there can only be one Unique Pointer to a given resource, Unique Pointers can transfer ownership, but cannot share it.

#+begin_src cpp
MakeUnique<>();
#+end_src

** MACRO

*** ~UE_CALL_ONCE~

#+begin_src cpp
void Tick()
{
    UE_CALL_ONCE([]()
    {
        UE_LOGFMT(LogTemp, Warning, "Tick called first time.");
    });
}
#+end_src

** Hard & Soft Reference

TODO Okatsu DataAsset

*** FSoftObjectPath

it's literally just a string with a fancy picker
TSoftObjectPtr/FSoftObjectPtr are better
"FSoftObjectPath properties are not cooked"
just checked the source code, I'll try to explain the difference. TSoftObjectPtr contains a pointer to an object, that's why cooker can easily use all objects referenced by a soft pointer. FSoftObjectPath is simpler, and that's why, for some reason, cooker doesn't even try to resolve objects referenced by an object path.
Yes, FSoftObjectPath is basically just a string
You convert the higher order types, eg TSoftObjectPtr, to FSoftObjectPath only when you actually want to load them
there's no reason to be using an exposed FSoftObjectPath property, the fact that it has an editor customization is practically legacy code
The soft object/class ptrs were introduced sometime in the middle of 4.x

** Async

*** Timer

#+begin_quote
Timers are not precise
#+end_quote

** Multithreading

*** =FRunnable=

Interface for "runnable" objects.

A runnable object is an object that is "run" on an arbitrary thread. The call usage pattern is Init(), Run(), Exit(). The thread that is going to "run" this object always uses those calling semantics. It does this on the thread that is created so that any thread specific uses (TLS, etc.) are available in the contexts of those calls. A "runnable" does all initialization in Init().

If initialization fails, the thread stops execution and returns an error code. If it succeeds, Run() is called where the real threaded work is done. Upon completion, Exit() is called to allow correct clean up.

**** Usage

***** header

#+begin_src cpp
#pragma once
#include "HAL/Runnable.h"

class FMyRunnable : public FRunnable
{
public:
    FMyRunnable(FString ThreadName):MyThreadName(ThreadName);

    //~FRunnable interface
    virtual bool Init() override;
    virtual uint32 Run() override;
    virtual void Exit() override;
    //~End of FRunnable interface

    FString MyThreadName;

private:
    static FCriticalSection CriticalSection;// for thread sync
};
#+end_src

***** cpp

#+begin_src cpp
#include "MyRunnable.h"
#include "HAL/RunnableThread.h"

FCriticalSection FMyRunnable::CriticalSection;

uint32 FMyRunnable::Run()
{
    while (IsValid())
    {
        FScopeLock Lock(&CriticalSection);// thread sync

        ...
    }//~FScopeLock here
}
#+end_src

***** object

#+begin_src cpp
FMyRunnable* Runnable1 = new FMyRunnable(TEXT("Thread1"));
FRunnableThread* RunnableThread1 = FRunnableThread::Create(Runnable1, *Runnable1->MyThreadName);
#+end_src

*** AsyncTask

*** TaskGraph

** Garbage Collection

*** Avoid GC

(old) ~AddToRoot()~ and ~RemoveFromRoot()~
add pointer to a subsystem

*** (rarely used) =FGCScopeGuard=

Prevent GC running in the scope.
Basically if GC tries to run while you have the lock, it's gonna sit there and stall until you release it.

*** New Incremental GC

[[https://dev.epicgames.com/documentation/en-us/unreal-engine/incremental-garbage-collection-in-unreal-engine][Incremental Garbage Collection]]

** Delegates

- Multicast :: More than one function can subscribe to the delegate at the same time.
- Dynamic :: For our purposes, this just means that it is compatible with Blueprints.

*** using a delegate

**** Declare the delegate's signature

**** Create variables of your new delegate

**** Subscribe to the delegate

**** Execute the delegate

*** Single

#+begin_src cpp
DECLARE_DELEGATE(FDelegateName);

UENUM(BlueprintType)
enum class EDelegateType:uint8
{
    Static,
    Raw,
    Lambda,
    SP,
    Object,
    UFUNCTION,
    WeakLambda,
};

class USomeClass : public UObject
{
    GENERATED_BODY()

public:
    FDelegateName MyDelegate;

    FDelegateName& BindDemonstration(EDelegateType Type);
};
#+end_src

#+begin_src cpp
FDelegateName& USomeClass::BindDemonstration(EDelegateType Type)
{
    if (MyDelegate.IsBound())
    {
        MyDelegate.UnBind();
    }

    switch (Type)
    {
        case EDelegateType::Static:
            MyDelegate.BindStatic(&SomeRawObject::StaticFoo);
            break;
        case EDelegateType::Raw:
            if (!RawObjectPtr.IsValid())
            {
                RawObjectPtr = MakeShareable(new SomeRawObject);
            }
            MyDelegate.BindRaw(RawObjectPtr.Get(), &SomeRawObject::Foo);
            break;
        case EDelegateType::Lambda:
            MyDelegate.BindLambda(
                [](void)
                {
                    UE_LOGFMT(LogTemp, Warning, std::source_location::current().function_name());
                }
            )
            break;
        case EDelegateType::SP:
            if (!RawObjectPtr.IsValid())
            {
                RawObjectPtr = MakeShareable(new SomeRawObject);
            }
            MyDelegate.BindSP(RawObjectPtr.ToSharedRef(), &SomeRawObject::Foo);
            break;
        case EDelegateType::Object:
            if (SomeUObject == nullptr)
            {
                SomeUObject = NewObject<USomeDelegateObject>();
            }
            MyDelegate.BindUObject(SomeUObject, &USomeDelegateObject::Foo);
            break;
        case EDelegateType::UFUNCTION:
            if (SomeUObject == nullptr)
            {
                SomeUObject = NewObject<USomeDelegateObject>();
            }
            MyDelegate.BindUFunction(SomeUObject, "Foo");
            break;
        case EDelegateType::WeakLambda:
            if (SomeUObject == nullptr)
            {
                SomeUObject = NewObject<USomeDelegateObject>();
            }
            MyDelegate.BindWeakLambda(SomeUObject,
                [](void)
                {
                    UE_LOGFMT(LogTemp, Warning, std::source_location::current().function_name());
                }// Will not execute if SomeUObject is null
            )
        default:
            break;
    }
}

MyDelegate.ExecuteIfBound();
#+end_src

*** Multicast

cannot use return values

**** Events

Only invoke inside class

#+begin_src cpp
DECLARE_EVENT(USomeClass, FEventName);

MyEvent.Broadcast();
#+end_src

*** Dynamic (UObject, serializable)

Dynamic delegates  can be serialized, slower than regular delegates

do not supports payload variables

** Interface

#+begin_quote
They let you define a set of functionality that anything can implement, and not be tied to a rigid class hierarchy.
#+end_quote

*** Use Interface

#+begin_src cpp
#include "ISomeInterface.h"

//if (IsValid(Actor) && Actor->GetClass()->ImplementsInterface(USomeInterface::StaticClass))
if (IsValid(Actor) && Actor->Implements<USomeInterface>())
{
    Cast<ISomeInterface>(Actor)->Foo();// For calling C++ only implementation
    ISomeInterface::Execute_Foo(Actor);// For calling blueprint implementation marked as UFUNCTION(BlueprintNativeEvent/BlueprintImplementableEvent)
}

// for CannotImplementInterfaceInBlueprint interface, you can use safely like below:
if (ISomeInterface* interface = Cast<ISomeInterface>(Actor))// For C++ classes Implemented the interface, it's fine. But for classes only implemented the interface in blueprint (aka only through reflection), cast always return nullptr.
{
    interface->Foo();// For calling C++ only implementation
    interface->Execute_Foo(Actor);// For calling blueprint implementation marked as UFUNCTION(BlueprintNativeEvent/BlueprintImplementableEvent)
}
#+end_src

*** Define Interface

#+begin_src cpp
#pragma once

#include "UObject/Interface.h"

#include "MyInterface.generated.h"

UINTERFACE(BlueprintType, MinimalAPI)
class UMyInterface : public UInterface
{
    GENERATED_BODY()
    // This will always be empty!
};

/**
 * MyInterface
 *
 *  Interface.
 */
class MYMODULE_API IMyInterface
{
    GENERATED_BODY()

public:

    UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category="MyInterface")
    void Foo();
};
#+end_src

#+begin_quote
For ~UINTERFACE(MinimalAPI, meta = (CannotImplementInterfaceInBlueprint))~

Another plus if you don't want to expose the interface to reflection/editor is that you'll be able to simply Cast pointers to the interface type and ->RunInterfaceFunctions() like normal C++ instead of going through the stupid weird ->Implements<Interface>() and ::Execute reflection execution system.
#+end_quote

*** Storing Interfaces As Variables

for blueprint variable, the interface must marked as =BlueprintType=.

for C++ variable, there is =TScriptInterface<>=, but it's weak reference and won't hold the UObject. So, just use UObject pointer might be the more reliable way.

#+begin_src cpp
UPROPERTY(BlueprintReadWrite)
TScriptInterface<IDoSomeThings> SomethingInstance;

if (UKismetSystemLibrary::DoesImplementInterface(Actor, UDoSomeThings::StaticClass()))
{
    SomethingInstance = Actor;
}

if (SomethingInstance)
{
    //int Num = SomethingInstance->GetNumberOfThings();// for C++ classes implemented the interface (Cast<> under the hood)
    int Num = IDoSomeThings::Execute_GetNumberOfThings(SomethingInstance.GetObject());// better way
}
#+end_src

** =TAttribute=

** Console (Cmd)

*** Command

- =stat unit= :: draw basic performance stats
- =ShowFlag.MeshEdges 1= :: render wireframe

*** Declare Command

e.g. Project.cpp (global)

#+begin_src cpp
static void OurGameCommand(const TArray<FString>& args, UWorld* world, FOutputDevice& ar)
{
    // Do something.
}

static FAutoConsoleCommand CConsoleCommand1(
    TEXT("OurGame.Command1"),
    TEXT("Performs no function just yet."),
    FConsoleCommandWithWorldArgsAndOutputDeviceDelegate::CreateStatic(OurGameCommand1), ECVF_Default);
#+end_src

e.g. cheat

+ in Game module cpp

#+begin_src cpp
#include "HAL/IConsoleManager.h"

/**
Demo console variable for extra force controlling player ball bearings.
*********************************************************************************/

static TAutoConsoleVariable<int32> CVarExtraMagnetism(
    TEXT("OurGame.ExtraMagnetism"),
    0,// Default value to this ConsoleVariable
    TEXT("Defines whether we should cheat in getting our bearings into their goals.\n")
    TEXT("  0: no extra magnetism\n")
    TEXT("  1: extra magnetism\n"),
    ECVF_Scalability | ECVF_RenderThreadSafe);
#+end_src

+ in Class function

#+begin_src cpp
    // If we're cheating then give our goals extra magnetism.

    static const IConsoleVariable* extraForce = IConsoleManager::Get().FindConsoleVariable(TEXT("OurGame.ExtraMagnetism"));// Static variable initialize only once, good for runtime performance

    if (extraForce != nullptr &&
        extraForce->GetInt() != 0)
    {
        magnetism *= 4.0f;
    }
#+end_src

e.g. GameMode.h

#+begin_src cpp
UFUNCTION(Exec)
void MyTestFunction()
{
    // Do something.
}
#+end_src

*** Set default value in config file

+ DefaultEngine.ini

  #+begin_src conf
  [SystemSettings]
  OurGame.ExtraMagnetism=1
  #+end_src

** Low-Level Memory (LLM) Tracker

To tracks memory usage, find out memory leak.

- The overhead of LLM can be 100MB or more.
- LLM won't show the on-screen stats page in the =Test= config, and is completely disabled in =Shipping=.

*** How to use

Add =-llm= to:
- (for standalone in editor) =Additional Launch Parameters= in =Editor Preferences= > =Level Editor - Play=
- Windows shortcut target
- IDE debug argument

Then use =stat llm= or =stat llmfull= in cmd.

| Argument                             | Description                                                                      |
|--------------------------------------+----------------------------------------------------------------------------------|
| -LLM                                 | Start with LLM enabled                                                           |
| -NOLLM                               | (Default) Start with LLM disabled                                                |
| -LLMCSV                              | LLM enabled, and Continuously writes out all values to =Saved/Profiling/llm/*.csv= |
| -LLMTAGSETS=Assets (or AssetClasses) | Shows the total allocated by each asset, or for each UObject class type.         |

*** LLM tracker tag

#+begin_src cpp
LLM_SCOPE();
#+end_src

* Data & Asset

** Data/Asset Management

*** Concepts

- Asset ::
- "Primary" assets :: asset auto managed by the asset manager (any UObject that implements =UObject::GetPrimaryAssetId()=)
- Primary Asset Type :: is a unique type like "melee weapon" that indicates a type of things that are loaded or identified at a global level in your game. A Map/Level is the only default primary asset type.
- Primary Asset ID :: uniquely identifies a single Primary Asset instance, such as "Masterwork Axe", you can get a Primary Asset ID list for a certain =Primary Asset Type=.
- Primary Asset Rules ::
- Asset Manager :: lets you manage your content with more control over loading/unloading and even loading only parts of an asset when set up correctly (by using soft-references to this ‘secondary content’ inside your ‘Primary Assets’ such as an Actor Class soft reference inside your Weapon DataAsset)
- Asset Manager Settings ::
- "Secondary" assets :: any UE asset that is not a Primary Asset.
- Asset Bundle ::
- DataAsset ::
- UPrimaryDataAsset ::

*** CDO (Blueprint property)

**** =UPackage=

- Path :: =/Game/TestBlueprint=

Asset in content browser.

**** =UBlueprint= : =UBlueprintCore=

- Path :: =/Game/TestBlueprint.TestBlueprint=

***** ~SkeletonGeneratedClass~

- Type :: ~UBlueprintGeneratedClass~ : ~UClass~
- Path :: =/Game/TestBlueprint.SKEL_TestBlueprint_C=

Generated skeleton class (outline) of the blueprint, regenerate when add or remove any variable/function/macro/interface, kinda like the header of a native class.

***** ~GeneratedClass~

- Type :: ~UBlueprintGeneratedClass~ : UClass
- Path :: =/Game/TestBlueprint.TestBlueprint_C=

The actual class stored in the blueprint asset, it also stores metadata(name, category, etc.) of the class.

****** =ClassDefaultObject= (CDO)

A template UObject of *every* =UClass= as an archetype.

You can call static function without instancelize a object via CDO.

Also for delta serialization (net or savegame).

In most cases, the =Archetype= of an =UObject= (template the object is based on) will be its CDO (~UObejct::GetArchetype()~).

The only special cases are BP-added components, the =Archetype= will be the ~ComponentTemplate~ in the SCS node or in ~UInheritableComponentHandler~ (if exist).

So ~GetDefaultObject~ of an actor is only going to return *native* components, you need to use ~AActor::GetActorClassDefaultComponent<UBPAddedComponent>(ActorClass)~ to get BP-added components.

The =Archetype= (template) of the CDO is the CDO of the parent class (~UClass::GetArchetypeForCDO()~).

******* C++ Constructor

Unreal has reserved the constructor for UObjects for it's own purpose, c++ constructor is called once for CDO (on engine load), and everytime its created using ~NewObject()~ (being spawned as actor).

#+begin_quote
Constructor runs prior serialization.
#+end_quote

******** Some special functions

- ~CreateDefaultSubobject()~

~CreateDefaultSubobject()~ provide a way that child class can change or not to create the subobject, use this instead of ~NewObject()~ in ctor.

#+begin_quote
When you call ~CreateDefaultSubobject()~ without using an ~FObjectInitializer~, fun fact, its just sugar for getting the current initializer and calling it directly.

~FObjectInitializer* CurrentInitializer = FUObjectThreadContext::Get().TopInitializer();~

that ~TopInitializer()~ thing is a thread-local variable that gets set before constructing the object then unset (and its a stack since one object can construct more objects)

also why you cannot use ~CreateDefaultSubobject()~ outside of constructor: the correct initializer is only set in the thread-local variable during construction, so it will fatal error otherwise
#+end_quote

#+begin_quote
At runtime, components are made by ~NewObject~ + ~RegisterComponent~ + ~AddInstanceComponent~.

A BP Construction Script’s C++ equivalent is the ~OnConstruction~ method, not the constructor. Components are made with ~NewObject~ in this case, and to match BP behavior, you’ll need to set this flag manually:

~YourNewComponent->CreationMethod = EComponentCreationMethod::UserConstructionScript;~

- Laura
#+end_quote

- ~SetupAttachment()~ (constructor only)

  ~SetupAttachment~ sets some meta data, when actor is spawned (or previewed) it uses the meta data to determine the attachments.

  ~AttachToComponent~ is anything but constructor.

  ~SetupAttachment~ may be used only before calling ~RegisterComponent~.

- ~IsTemplate()~

#+begin_quote
A typical use case of ~IsTemplate()~ is to put dynamic delegate bindings in the ctor protected by that check.
#+end_quote

****** =SimpleConstructionScript= (SCS)

#+ATTR_HTML: width="300px"
#+ATTR_ORG: :width 300
[[file:./images/scs_in_blueprint_editor.webp]]

The "simple" version of ConstructionScript(ctor) for ~AActor~ to add components.

To reduce quantity of CDO, blueprint class use SCS to store its components (blueprint-added components only) as ~USCS_Node~, instead of storing them in CDO like native class.

Component added via =Components= panel will be stored in ~RootNodes~ array.

When multiple SCS exist in inheritance hierarchy, parent SCS will execute first to add component.

If modify a *SCS-added* component of parent blueprint, a new ~ComponentTemplate~ (instance of modified ~UActorComponent~) will be stored in an array of ~UInheritableComponentHandler~ in current =GeneratedClass=.

#+begin_quote
Native classes doesn't have SCS.
#+end_quote

******* Traverse BP added components in CDO

#+begin_src cpp
auto* blueprint = GetBlueprint();
if (!blueprint || !blueprint->SimpleConstructionScript) return;

auto scs = Blueprint->SimpleConstructionScript;
auto nodes = scs->GetAllNodes();

bool bModifiedBlueprint {false};
for (auto entry : nodes)
{
    if (!entry || !entry->ComponentTemplate) continue;

    auto componentTemplate = Entry->ComponentTemplate;
    // ...
}

if (bModifiedBlueprint)
{
    FKismetEditorUtilities::CompileBlueprint(blueprint);
}
#+end_src

*** ConstructHelper

*** Data Only Blueprint

A data-only blueprint

- How to create a Data Only Blueprint?

Remove =Parent:Construction Script= node in =Construction Script= tab of blueprint, then close and reopen the blueprint, it become Data-only.

#+begin_quote
You can figure whether blueprint is data-only by hovering over it.
#+ATTR_HTML: width="300px"
#+ATTR_ORG: :width 300
[[file:./images/identify_data_only_blueprint.webp]]
#+end_quote

*** Data Table

+ pros
  - csv file support
  - editing properties during runtime
+ cons
  - hard to get data (using row name)
  - loading all content in once
  - no multiple editing support

#+begin_quote
Tips: use with DataRegister
#+end_quote

**** DataTable

***** Get Data

- =Get Data Table Row Names=
- =Get Data Table Row ...(SomeDataTable)=

**** CompositeDataTable

*** Data Asset

#+begin_quote
*Read only* objects at runtime
#+end_quote

+ pros (compare to Data Table)
  - disentanglement
  - easy cooperation
  - get/set without Cast
  - used outside of blueprint (e.g. as AnimNotify parameter)

+ UFunction support (Base on blueprint), and can be *called in editor* using button (e.g. check button)

  They can have logic (it's not like USTRUCTs where the engine forces no UFUNCTIONs) but they shouldn't (in theory) since they're supposed to just be data holders.

  It's fine if they have read only UFUNCTIONs, what it's implying is to not hold or change state on a DA since that's not what they're for.

+ Use _soft reference_ to reduce loading time

#+begin_quote
Note: Make sure to create *Asset Instance* through right-click > Miscellaneous > Data Asset. Creating *Blueprint subclasses* of your UDataAsset is not the same thing.
#+end_quote

#+begin_quote
Note:
It's worth making your data asset properties const.
So either =const UWeaponDataAsset*= or =TObjectPtr<const UWeaponDataAsset>=.
All the properties of the data asset type itself should be =EditDefaultsOnly, BlueprintReadOnly=
#+end_quote

#+begin_quote
the main drawback of subclassing is lack of asset management
you can't know anything inside the class without spawning it or looking at the CDO I guess but that's jank
PDAs are pre-serialized UObjects, you can query and look into them without spawning a whole actor
#+end_quote

**** UDataAsset (native)

Also keep in mind that the best use of DAs is to replicate info that you know ahead of time....

it's much less data to save or replicate a DA *pointer* than it is to replicate the contents, it has a non-transient path which enables a lot of these things.

so you want to use DAs for data you can know in advance.

#+begin_src cpp
UCLASS(CollapseCategories)
class UPlantFlowerData : public UObject
{
    GENERATED_BODY()
public:
    UPROPERTY(EditAnywhere)
    float Radius = 0.5f;

    UPROPERTY(EditAnywhere)
    int32 Count = 5;
};

UCLASS(BlueprintType)
class UPlantDataAsset : public UDataAsset
{
    GENERATED_BODY()
public:
    UPROPERTY(EditAnywhere)
    FText DisplayName;

    UPROPERTY(EditAnywhere)
    FSlateBrush Icon;

    // Showing how to do an inlined UObject instance for completeness
    UPROPERTY(EditAnywhere, Instanced)
    TArray<UPlantFlowerData*> FlowerDatas;

    // Point to other Data Assets
    // Instead of raw pointer could also be TObjectPtr<T> or TAssetPtr<T>
    UPROPERTY(EditAnywhere)
    TArray<UPlantDataAsset*> ChildPlants;
};
#+end_src

**** UPrimaryDataAsset

Primary = auto managed by the asset manager (implements =GetPrimaryAssetId=), with a primary data asset you get automatic discovery, async loading, etc. through the asset manager.

Another benefit of PrimaryDA is that you can use it as a parent class for a BP based DA class, DA doesn't allow direct BP child classes

Additionally they support *AssetBundles* which are very important for heavy data like meshes, so you can just load one part at a time when needed.

There's also the gameplayfeatures integration to inject more DAs into your game, GameFeature plugins can load new PrimaryDataAssets on load

#+begin_src cpp
UCLASS(Abstract, BlueprintType, ClassGroup = Equipment, Category = "Equipment", Meta = (DisplayName = "Some Data", ShortTooltip = "Data asset used to define a something."))
class GAME_API USomeData : public UPrimaryDataAsset
{
    GENERATED_BODY()

    ...

    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Some Property")
    FText ItemName;
    ...
}
#+end_src

**** Snippet for control use of blueprint subclass of DataAsset

***** header

#+begin_src cpp
public:
    //~UObject interface
#if WITH_EDITOR
    virtual EDataValidationResult IsDataValid(class FDataValidationContext& Context) const override;
#endif // WITH_EDITOR
    //~End of UObject interface
#+end_src

***** cpp

****** DataValidation way of =NotBlueprintable=, buy you should just use ~UCLASS(NotBlueprintable, ...)~

#+begin_src cpp
#if WITH_EDITOR
#include "Misc/DataValidation.h"
#endif // WITH_EDITOR

#if WITH_EDITOR
EDataValidationResult ULyraExperienceDefinition::IsDataValid(FDataValidationContext& Context) const
{
    EDataValidationResult Result = CombineDataValidationResults(Super::IsDataValid(Context), EDataValidationResult::Valid);

    // Make sure users didn't subclass from a BP of this.
    if (not GetClass()->IsNative())
    {
        Result = EDataValidationResult::Invalid;

        // Find the native parent and show error message.
        const UClass* FirstNativeParent = GetClass()->GetSuperClass();
        while ((FirstNativeParent != nullptr) && not FirstNativeParent->IsNative())
        {
            FirstNativeParent = FirstNativeParent->GetSuperClass();
        }
        Context.AddError(FText::Format(LOCTEXT("DataAssetInheritenceIsUnsupported", "Blueprint subclasses of {0} is not currently supported (use right-click > Miscellaneous > DataAsset instead)."),
            FText::AsCultureInvariant(GetPathNameSafe(FirstNativeParent))
        ));
    }

    return Result;
}
#endif // WITH_EDITOR
#+end_src

****** only allow subclass once for assigning default value

#+begin_src cpp
#if WITH_EDITOR
EDataValidationResult ULyraExperienceDefinition::IsDataValid(FDataValidationContext& Context) const
{
    EDataValidationResult Result = CombineDataValidationResults(Super::IsDataValid(Context), EDataValidationResult::Valid);

    // Make sure users didn't subclass from a BP of this (it's fine and expected to subclass once in BP, just not twice)
    if (!GetClass()->IsNative())
    {
        const UClass* ParentClass = GetClass()->GetSuperClass();

        // Find the native parent
        const UClass* FirstNativeParent = ParentClass;
        while ((FirstNativeParent != nullptr) && !FirstNativeParent->IsNative())
        {
            FirstNativeParent = FirstNativeParent->GetSuperClass();
        }

        if (FirstNativeParent != ParentClass)
        {
            Context.AddError(FText::Format(LOCTEXT("ExperienceInheritenceIsUnsupported", "Blueprint subclasses of Blueprint experiences is not currently supported (use composition via ActionSets instead). Parent class was {0} but should be {1}."),
                FText::AsCultureInvariant(GetPathNameSafe(ParentClass)),
                FText::AsCultureInvariant(GetPathNameSafe(FirstNativeParent))
            ));
            Result = EDataValidationResult::Invalid;
        }
    }

    return Result;
}
#endif
#+end_src

**** Call in Editor (UFUNCTION modifier)

generate editor button

**** with DataTable

Use =DataTable= or csv file to view/generate plenty of =DataAsset=.

TODO

**** with Subsystem

**** with GAS

**** Sync load

=.Get()= doesn't load the object if it is unloaded, it will give you nullptr

In C++ you can do =.LoadSynchronous()= which is easy but bad -- bad because it not only blocks while the asset is being loaded, but it also causes all other assets being async loaded to load immediately, which can cause stutters.

**** Async Load/Unload by FPrimaryAssetId

#+begin_src cpp
#include "Engine/AssetManager.h"

void USomeInventoryManager::SpawnEquipment(const FPrimaryAssetId& EquipmentDefinitionId)
{
    /// Load EquipmentDefinition via UAssetManager and the PrimaryAssetId
    UAssetManager::Get().LoadPrimaryAsset(EquipmentDefinitionId, /** BundleNames = */ {}, FStreamableDelegate::CreateLambda([this, EquipmentDefinitionId]()
    {
        /// Get the Object and cast it now that it is loaded.
        UEquipmentDefinition* const EquipmentDefinition = Cast<UEquipmentDefinition>(UAssetManager::Get().GetPrimaryAssetObject(EquipmentDefinitionId));

        /// Add the Equipment to the list, assuming the List lives in the Manager.
        EquipmentList.AddEntry(EquipmentDefinition);
    }), /** Priority = */ 0);
}
#+end_src

or use ue5coro

#+begin_src cpp
#include "UE5Coro.h"

using namespace UE5Coro;
using namespace UE5Coro::Latent;

UMechanicalSceneData* data = co_await UE5Coro::Latent::AsyncLoadPrimaryAsset<UMechanicalSceneData>(SceneId);
#+end_src

Releasing the handle does nothing to help get rid of this reference because the reference in YOUR handle is gone but the AM still has its copy. You must call =UnloadPrimaryAssets= or else the AM will keep its reference forever and the object will never be GC'd

**** AssetBundles

*** Asset Manager

(Async) asset loading management

#+begin_quote
Get asset manager

GEngine->AssetManager is weird, use UAssetManager* AssetManager = UAssetManager::GetIfInitialized().

also you should check for validity before you dereferencing the result of your cast

and the asset manager should be initialized super early, usually initialized well before you need it for gameplay etc,
AssetManager should NEVER be null,
so GetIfInitialized is pointless most of the time, just use

UAssetManager& AssetManager = UAssetManager::Get();

#+end_quote

*** Asset Registry

*** Asset Bundles

*** Data Registry

creating composite, cached DTs

PDAs are ideal for aggregated assets like a definition that holds a mesh, a display name, and a key to access stats from DR

DT/CT are important because they are compatible with the hotfix manager (can be hotpatched without patching the game with .ini)
can use external program like Excel or Access to create/modify them and reimport
DT/CT are awful to use without DR, DR brings them up to modern standards
you don't touch Data Tables directly when you use DR

*** Curve Table

*** Settings(ini)

*** Console Variables

*** Data Registry

*** *Data Driven Design*

**** Chooser - Dynamic asset selector

***** Chooser Table

grab a subset of result that potentially fit the same requirements.
Input for the current state of the game, Output to set some variables based on the chosen rows.

Asset Naming :: CHT_

****** Column Type

- Filter
- Scoring
- Output
- Random

****** Use Case
ContactSFX
DifferentCharacter

******* Damege Reaction

- General

| Result                  |  DamageDirection | DamageStrength | Randomize |
| AnimMontage             | Float Difference | Enum           |           |
|-------------------------+------------------+----------------+-----------|
| =AM_HitReact_Front_Lgt_1= |                0 | Light          |         1 |
| =AM_HitReact_Front_Lgt_2= |                0 | Light          |         1 |
| =AM_HitReact_Front_Med_1= |                0 | Medium         |         1 |
| =AM_HitReact_Front_Hvy_1= |                0 | Heavy          |         1 |
| =AM_HitReact_Left_Med_1=  |              -90 | Medium \vert Heavy |         1 |
| =AM_HitReact_Right_Lgt_1= |               90 | Light          |         1 |
| =AM_HitReact_Back_Lgt_1=  |              180 | Light          |         1 |

- Death Montage

| Result           | DamageDirection | Randomize |
| AnimMontage      | Float Range     |           |
|------------------+-----------------+-----------|
| =AM_Death_Front_1= | (-45, 45)       |         1 |
| =AM_Death_Left_1=  | (-135, -45)     |         1 |
| =AM_Death_Right_1= | (45, 135)       |         1 |
| =AM_Death_Back_1=  | (-180, -135)    |         1 |
| =AM_Death_Back_1=  | (135, 180)      |         1 |

***** Proxy Table

multiple characters can share same animBP

****** Use Case
  Weapon

****** Asset Naming
  - Proxy Asset :: PA_
  - Proxy Table :: PT_

*** Async Loading

** Asset Management (Loading)

*** pak dlc chunk

*** package cook

when using a string path to reference blueprint class in C++ (i.e. FClassFinder), the blueprint asset won't be cook and packaged.

reference asset in map or add directory path to =DirectoriesToAlwaysCook= array.

- DefaultGame.ini

#+begin_src conf
[/Script/UnrealEd.ProjectPackagingSettings]
+DirectoriesToAlwaysCook=(Path="/Game/ThirdPersonCPP/Blueprints")
#+end_src

*** UClass String Path

- Native UClass :: ="/Script/{ModuleName}.{ClassName (without U/A prefix)}"=

- Blueprint UClass :: ="/{Engine|Game|PluginName}/{PathToAsset}/{Package(Asset)Name}[.{ClassName}_C (optional)]"=
  > =ConstructorHelpers::FClassFinder= can automatically add class name suffix.

- Blueprint Object :: ="/{Engine|Game|PluginName}/{PathToAsset}/{Package(Asset)Name}.{ObjectName}[:{SubObjectName}]"=

*** Use blueprint asset in C++ constructor

#+begin_quote
Warning: referencing an asset by hardcode path in C++ is a *bad* idea, =ConstructorHelpers= are unreliable at best, can cause issues in packaging.
=ConstructorHelpers= definitely expose asset to cooker, but they may give you loading order issues if complex data involved.
The better way is to held asset constants in =UDeveloperSettings=.
#+end_quote

#+begin_src cpp
#include "UObject/ConstructorHelpers.h"

// in ctor
ASomeActor::ASomeActor(const FObjectInitializer& ObjectInitializer)
    : Super(ObjectInitializer)
{
    static ConstructorHelpers::FObjectFinder<UTexture2D> noteSprite(TEXT("Texture2D'/Engine/EditorResources/S_Note.S_Note'"));
    if (noteSprite.Succeeded())
    {
        BillboardComponent->SetSprite(noteSprite.Object);
    }
    else
    {
        UE_LOG(LogTemp, Error, TEXT("Failed to load proper sprite texture for AScreenDescriptionVolume."));
    }
}
#+end_src

** Save & Settings

*** add custom =ProjectSettings= (INI)

**** Inherit =UDeveloperSettings=

#+begin_quote
DeveloperSettings is a Module. Creating a UDeveloperSettings derived class will add this module to your .uproject automatically. If it doesn’t or you want all your modules in the .Build.cs file then you should add DeveloperSettings manually.
#+end_quote

*** DeveloperSettingsBackedByCVars

binding with Console Variables (CVars) and project/editor settings

* Mass (ECS)

** Usage

* Engine

** =UObject=

*** Garbage Collection

Q: should call destroy() for that, right?
A: Actors yeah, UObjects just clear any refs to it and it will be picked up by GC

you should practically never be destroying UObjects yourself
Just null all references and forget about it

Be careful with AddToRoot
AddToRoot is like a design wise last resort option, only place I use it is in automation testing, If you're using AddToRoot in gameplay code you fucked up

caveat: don't ever use new/delete with UObjects

** Actor Lifecycle

*** Initialize

- Initialize member variables with inline default values in header files
- Perform any further trivial initialization in class constructors
  For actors, use ~CreateDefaultSubobject~ to create components in class constructors
- Class data member may then be modified by loading process
  Virtual Function: ~PreInitializeComponents~, ~PostInitializeComponents~ (usually preferred), ~BeginPlay~

*** Tick

For components, use ~TickComponent~

- For actors class constructor
  #+begin_src cpp
  PrimaryActorTick.bCanEverTick = true;
  #+end_src
- For components
  #+begin_src cpp
  PrimaryComponentTick.bCanEverTick = true;
  #+end_src

*** Destruction

within the ~EndPlay~ function

any UPROPERTYs are automatically destroyed

*** Atomic

*** Different ways to _instantiate_ the object

To understand the difference between these functions, you need to remember that the object model in Unreal Engine is based on object prototypes, very much like in JavaScript. Each UClass is associated to a default instance of the associated UObject class, called the Class Default Object (CDO), which is allocated first and then constructed, only once, via the class constructor when the engine is initialised. The CDO acts as a template from which all other instances of the class are copied, and the constructor is never called again.

This means class constructors _cannot contain any runtime logic_, and should only be used to initialise the CDO and its properties. If the class contains any subobjects, like actor components, these must do the same, so their own default objects must be constructed first. The actual instantiation of the object must then be deferred, after the engine has initialised, so that every time a new instance of the class is requested to be created by normal gameplay code, the parent object and all of its subobjects are instantiated from their respective defaults.

So, the multiple ways of creating objects are necessary to handle all the different scenarios where an object may be created.

- =UObject::CreateDefaultSubobject= is only callable in a class constructor, and takes care of creating an instance of the CDO of the subobject's class, setting its outer class as the caller object, among other things. The created object then becomes the default object for the property when its object class is instantiated.

- =NewObject<T>= is the function normally used to instantiate objects after engine initialisation, during normal gameplay. It provides several convenience overloads to handle most scenarios.

- =UWorld::SpawnActor<T>= is a convenience method to spawn actors in a level with the specified location and rotation, spawn collision settings, and checks to ensure it's a spawnable actor class, and is nothing more than a wrapper of =NewObject<AActor>=.

- =ConstructObject= has been removed in favour of =NewObject=.

- There's also =UGameplayStatics::SpawnObject=.

I recommend checking the engine source code for more information, especially UObject/UObjectGlobal.cpp and UObject/UObjectGlobal.h in the CoreUObject engine module. Internally, all these function ultimately call (as of 4.24) =StaticConstructObject_Internal=, which handles the actual object creation.

Replicating =CreateDefaultSubobject= by using =NewObject= is quite complex, as it does a lot of things for you. Check the source for the former and you'll see why it's so convenient. But yes, the rule of thumb is, =CreateDefaultSubobject= in class constructors, =NewObject= otherwise.

[[https://docs.unrealengine.com/5.0/en-US/creating-unreal-objects/][Doc_UObject Instance Creation]]

*** Change CDO Subobject Class

#+begin_src cpp
AActor::AActor(const FObjectInitializer& ObjectInitializer)
    : Super(ObjectInitializer.SetDefaultSubobjectClass<UMyCharacterMovementComponent>(ACharacter::CharacterMovementComponentName)
            .SetDefaultSubobjectClass<USomeNewComponent>(TEXT("SomeComponent"))
            .DoNotCreateDefaultSubobject(Super::MeshComponentName))
{
}
#+end_src

*** Get component without cast (less memory)

Always need valid check

Blueprint node =Get Component by Class=

#+begin_src cpp
compPtr = FindComponentByClass<USphereComponent>();
#+end_src

*** Animation Montage

**** header

#+begin_src cpp
UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Animation|Montage", meta = (AllowPrivateAccess = "true"))
class UAnimMontage* SomeMontage;
#+end_src

**** cpp

#+begin_src cpp
#include "Animation/AnimMontage.h"

void AMyCharacter::foo()
{
    if (SomeMontage)
    {
        PlayAnimMontage(SomeMontage);
    }
}
#+end_src

*** Enum

**** Class UEnum

#+begin_src cpp
UENUM(BlueprintType, Category = "Weapon")
enum class EWeaponState : uint8
{
    Reloading UMETA(DisplayName = "Weapon Reloading"),
    Equipping UMETA(DisplayName = "Weapon Equipping")
};
#+end_src

#+begin_src cpp
UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Weapon")
EWeaponState WeaponState = EWeaponState::Equipping;
#+end_src

#+begin_src cpp
switch (WeaponState)
{
case EWeaponState::Reloading:
    Foo();
    break;
case EWeaponState::Equipping:
    Bar();
    break;

default:
    break;
}
#+end_src

**** Bitmask UEnum

Enum classes used as flags can take advantage of the =ENUM_CLASS_FLAGS(EnumType)= macro to automatically define all of the bitwise operators

#+begin_src cpp
UENUM(BlueprintType, Category = "Weapon", meta = (Bitflags, UseEnumValuesAsMaskValuesInEditor = "true"))
enum class EWeaponState : uint8
{
    None      = 0x00 UMETA(Hidden),
    Reloading = 0x01 UMETA(DisplayName = "Weapon Reloading"),
    Equipping = 0x02 UMETA(DisplayName = "Weapon Equipping")
};

ENUM_CLASS_FLAGS(EWeaponState)
#+end_src

#+begin_src cpp
UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Weapon", meta = (Bitmask, BitmaskEnum = "EWeaponState"))
uint8 WeaponState = static_cast<uint8>(EWeaponState::Equipping);
#+end_src

***** truth context

The one exception to this is the use of flags in a truth context - this is a limitation of the language. Instead, all flags enums should have an enumerator called =None= which is set to 0 for comparisons:
#+begin_src cpp
// Old
if (Flags & EFlags::Flag1)

// New
if ((Flags & EFlags::Flag1) != EFlags::None)
#+end_src

***** Usage

#+begin_src cpp
void ASampleActor::foo()
{
    // Add flag
    WeaponState |= static_cast<uint8>(EWeaponState::Reloading);

    // Remove flag
    // WeaponState &= ~static_cast<uint8>(EWeaponState::Reloading)

    if ((WeaponState & static_cast<uint8>(EWeaponState::Reloading)) != EFlags::Reloading)
    {
        // Weapon is Reloading
    }
}
#+end_src

*** Pointers & References

#+BEGIN_QUOTE
Pointers & References

from Unreal Engine Community Wiki

So, for objects where being Null is a valid state (like anything that can be garbage collected such as UObjects), it makes sense to pass things by Pointer rather than by Reference. When you pass a value By Pointer, much like By Reference only 8 bytes are pushed onto the stack and object is not copied. The difference is that passing By Pointer is a explicit declaration that the value can be Null and you should absolutely check for that and handle the case where it is. If you pass By Reference, you are saying that it can never be Null.
#+END_QUOTE

+ Pointers (*)
  - Can be null.
  - Have a memory address.
  - Can be changed to point at something else than the previous pointed object.
  - You can’t point to a reference.

+ References (&)
  - Can reference a pointer or the object in memory itself.
  - Have no address, thus you can’t assign a pointer to it.
  - Once you declare it, you can’t change it to reference to something else.

**** Always Check Your Pointers

#+begin_src cpp
check(Ptr);// or
if(!Ptr) return;
#+end_src

*** Lambda

+ Never, ever use [&] or [=], they captures *everything* in the current scope.

#+begin_src cpp
[CharacterClass, var1, &var2](const FStAbilityData& a, const FStAbilityData& b){
    return a.AllowedClasses[CharacterClass] < b.AllowedClasses[CharacterClass]
}
// CharacterClass was a variable defined in the same scope as the lambda (and before it, obviously).
// Other common uses of [] are [this] to capture the local object pointer (be careful because the object might just be GC'd at some point if it's asynchronous).
// Or [&SomeVariable] to capture it by reference.
// You can also create variables inside the capture, e.g. [SomeNewVar = TWeakObjectPtr(this)]
#+end_src

One last thing, is the lambda (or whatever) ever complains about a return type, you can do: =[]() -> ReturnType {}= (e.g. =[]() -> FString { return FString("moo"); }=)
It's usually worked out automatically, but it doesn't always get it right.

#+begin_quote
Thanks to =Daekesh= from discord.
#+end_quote

*** Pure Virtual Function

#+begin_src cpp
// For C++ pure virtual function
virtual bool Foo() = 0;

// Macro for BlueprintNativeEvent UFUNCTION
UFUNCTION(BlueprintNativeEvent)
virtual bool Foo() PURE_VIRTUAL(ThisClass::Foo, return false;);
//bool Foo_Implementation() { return false; }// You can use the macro instead of this.

// And for first one, you can not create instance of class with a pure virtual function, it fail to compile since unreal won't be able to create CDO of the class.
// But for the second one, you can create the instance.
// In interfaces it's slightly more lenient, as no CDO is created for the actual interface.
#+end_src

*** C++ *and* Blueprint

No separate "Scripting API"

+ C++ - programming language
  naturally better-suited for low-level game systems
+ Blueprint - scripting system
  naturally better-suited for high-level behaviors, interactions, integrating assets and fine-tuning cosmetic details

**** Performance

+ In terms of raw execution speed, C++ is faster
  C++ code compile to machine code
  Blueprint run through script VM at runtime
+ Blueprint Nativization (Deprecated)
  buggy

Use profiler

**** Project Organization

**** Access Controls

#+begin_src cpp
class FSomeClass
{
public:
  // Accessible to all other code

protected:
  // Accessible to subclasses

private:
  // Internal to this class alone
}
#+end_src

#+begin_src cpp
// Not exposed to Blueprints at all
UCLASS(NotBlueprintType, NotBlueprintable)

// Can be referenced but not extended
UCLASS(BlueprintType, NotBlueprintable)

// Can be extended in Blueprints
UCLASS(BlueprintType, Blueprintable)
#+end_src

#+begin_src cpp
// Read-only to both users and blueprints
UPROPERTY(VisibleAnywhere, BlueprintReadOnly)

// Can't be modified per-instance, but a new default value can be set per-Blueprint
UPROPERTY(EditDefaultsOnly, BlueprintReadWrite)

// Can be modified in the Details panel and by Blueprints
UPROPERTY(EditAnywhere, BlueprintReadWrite)
#+end_src

**** difference

*** C++ vs. Blueprint Implementation

**** Input

***** Movement

Setup input in project setting first

In some ACharacter class

****** C++

+ .h
#+begin_src cpp
protected:
    // Called when the game starts or when spawned
    virtual void BeginPlay() override;

    // Called for forwards/backwards input
    void MoveForward(float Value);

    // Called for side to side input
    void MoveRight(float Value);
#+end_src
+ .cpp
#+begin_src cpp
void AShooterCharacter::MoveForward(float Value)
{
    if ((Controller != nullptr) && (Value != 0.0f))
    {
        // Find out which way is forward
        const FRotator Rotation{ Controller->GetControlRotation() };
        const FRotator YawRotation{ 0,Rotation.Yaw,0 };

        const FVector Direction{ FRotationMatrix{YawRotation}.GetUnitAxis(EAxis::X) };
        AddMovementInput(Direction, Value);
    }
}

void AShooterCharacter::MoveRight(float Value)
{
    if ((Controller != nullptr) && (Value != 0.0f))
    {
        // Find out which way is forward
        const FRotator Rotation{ Controller->GetControlRotation() };
        const FRotator YawRotation{ 0,Rotation.Yaw,0 };

        const FVector Direction{ FRotationMatrix{YawRotation}.GetUnitAxis(EAxis::Y) };
        AddMovementInput(Direction, Value);
    }
}
#+end_src

#+begin_src cpp
// Called to bind functionality to input
void AShooterCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
{
    Super::SetupPlayerInputComponent(PlayerInputComponent);
    check(PlayerInputComponent);

    PlayerInputComponent->BindAxis("MoveForward", this, &AShooterCharacter::MoveForward);
    PlayerInputComponent->BindAxis("MoveRight", this, &AShooterCharacter::MoveRight);
}
#+end_src

****** Blueprint

#+ATTR_HTML: width="900px"
#+ATTR_ORG: :width 900
[[file:./images/movement_input_blueprint.webp]]

***** Turn and LookUp

****** C++

+ .h
#+begin_src cpp
protected:
    /**
    * Called via input to turn at a given rate.
    * @param Rate  This is a normalized rate, i.e. 1.0 means 100% of desired turn rate
    */
    void TurnAtRate(float Rate);

    /**
    * Called via input to look up/down at a given rate.
    * @param Rate  This is a normalized rate, i.e. 1.0 means 100% of desired rate
    */
    void LookUpAtRate(float Rate);

    /**
    * Rotate controller based on mouse X movement
    * @param Value   The input value from mouse movement
    */
    void Turn(float Value);

    /**
    * Rotate controller based on mouse Y movement
    * @param Value   The input value from mouse movement
    */
    void LookUp(float Value);
#+end_src

#+begin_src cpp
private:
    // Base turn rate, in deg/sec. Other scaling may affect final turn rate
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = "true"))
    float BaseTurnRate;

    // Base look up/down rate, in deg/sec. Other scaling may affect final turn rate
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = "true"))
    float BaseLookUpRate;

    /** Scale factor for mouse look sensitivity. Turn rate when not aiming. */
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = "true"), meta = (ClampMin = "0.0", ClampMax = "1.0", UIMin = "0.0", UIMax = "1.0"))
    float MouseHipTurnRate;

    /** Scale factor for mouse look sensitivity. Look up rate when not aiming. */
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = "true"), meta = (ClampMin = "0.0", ClampMax = "1.0", UIMin = "0.0", UIMax = "1.0"))
    float MouseHipLookUpRate;

    /** Scale factor for mouse look sensitivity. Turn rate when aiming. */
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = "true"), meta = (ClampMin = "0.0", ClampMax = "1.0", UIMin = "0.0", UIMax = "1.0"))
    float MouseAimingTurnRate;

    /** Scale factor for mouse look sensitivity. Look up rate when aiming. */
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = "true"), meta = (ClampMin = "0.0", ClampMax = "1.0", UIMin = "0.0", UIMax = "1.0"))
    float MouseAimingLookUpRate;
#+end_src
+ .cpp
#+begin_src cpp
void AShooterCharacter::TurnAtRate(float Rate)
{
    // Calculate delta for this frame from the rate information
    AddControllerYawInput(Rate * BaseTurnRate * GetWorld()->GetDeltaSeconds()); // deg/sec * sec/frame
}

void AShooterCharacter::LookUpAtRate(float Rate)
{
    AddControllerPitchInput(Rate * BaseLookUpRate * GetWorld()->GetDeltaSeconds()); // deg/sec * sec/frame
}

void AShooterCharacter::Turn(float Value)
{
    float TurnScaleFactor{};
    if (bAiming)
    {
        TurnScaleFactor = MouseAimingTurnRate;
    }
    else
    {
        TurnScaleFactor = MouseHipTurnRate;
    }
    AddControllerYawInput(Value * TurnScaleFactor);
}

void AShooterCharacter::LookUp(float Value)
{
    float LookUpScaleFactor{};
    if (bAiming)
    {
        LookUpScaleFactor = MouseAimingLookUpRate;
    }
    else
    {
        LookUpScaleFactor = MouseHipLookUpRate;
    }
    AddControllerPitchInput(Value * LookUpScaleFactor);
}
#+end_src

#+begin_src cpp
void AShooterCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
{
    Super::SetupPlayerInputComponent(PlayerInputComponent);
    check(PlayerInputComponent);

    PlayerInputComponent->BindAxis("TurnRate", this, &AShooterCharacter::TurnAtRate);
    PlayerInputComponent->BindAxis("LookUpRate", this, &AShooterCharacter::LookUpAtRate);
    PlayerInputComponent->BindAxis("Turn", this, &AShooterCharacter::Turn);
    PlayerInputComponent->BindAxis("LookUp", this, &AShooterCharacter::LookUp);
}
#+end_src

****** Blueprint

#+ATTR_HTML: width="420px"
#+ATTR_ORG: :width 420
[[file:./images/mouse_input_blueprint.webp]]
#+ATTR_HTML: width="700px"
#+ATTR_ORG: :width 700
[[file:./images/gamepad_input_blueprint.webp]]

**** Trace

***** Weapon Trace

****** C++

#+begin_src cpp
void AWeapon::RunWeaponTrace(const FTransform& MuzzleTransform, float TraceDistance)
{
    const FVector TraceStart = MuzzleTransform.GetLocation();
    const FVector TraceEnd = TraceStart + (MuzzleTransform.GetUnitAxis(EAxis::X) * TranceDistance);
    const FCollisionQueryParams QueryParams(TEXT("WeaponTrace"), false, this);

    FHitResult Hit;
    if (GetWorld()->LineTraceSingleByChannel(Hit, TraceStart, TraceEnd, ECC_WeaponFire, QueryParams))
    {
        const float DamageAmount = 1.0f;
        const FVector ShotFromDirection = (TraceEnd - TraceStart).GetSafeNormal();
        const TSubclassOf<UDamegeType> DamegeTypeClass = UDamageType_WeaponFire::StaticClass();
        const FPointDamageEvent DamageEvent(DamageAmount, Hit, ShotFromDirection, DamageTypeClass);
        Hit.Actor->TakeDamege(DamageAmount, DamegeEvent, OwningController, this);
    }
}
#+end_src

****** Blueprint

Trace

**** Collision Component Overlap

***** header

#+begin_src cpp
protect:
    UFUNCTION()
    void OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);

    UFUNCTION()
    void OnOverlapEnd(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
#+end_src

***** cpp

+ header
  #+begin_src cpp
  #include "Components/SphereComponent.h"
  #+end_src
+ in ~BeginPlay()~
  #+begin_src cpp
  {
      // ...
      if (IsValid(Trigger))
      {
          Trigger->OnComponentBeginOverlap.AddDynamic(this, &ThisClass::OnOverlapBegin);
          Trigger->OnComponentEndOverlap.AddDynamic(this, &ThisClass::OnOverlapEnd);
      }
  }
  #+end_src
+ function
  #+begin_src cpp
  void ALookAtActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
  {
      if (not IsValid(OtherActor) || OtherActor == this || not IsValid(OtherComp))
      {
          return;
      }

      // ...
  }

  void ALookAtActor::OnOverlapEnd(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
  {
      if (not IsValid(OtherActor) || OtherActor == this || not IsValid(OtherComp))
      {
          return;
      }

      // ...
  }
  #+end_src

**** Timeline

***** Blueprint

#+ATTR_HTML: width="900px"
#+ATTR_ORG: :width 900
[[file:./images/timeline_implement_blueprint.webp]]

***** C++

****** Create Curve Asset

****** header

#+begin_src cpp
    class UTimelineComponent* MyTimeline;

public:
    UPROPERTY(EditAnywhere, Category = "Timeline")
    UCurveFloat* MyCurve;

    UPROPERTY()
    FVector StartLocation;

    UPROPERTY()
    FVector EndLocation;

    UPROPERTY(EditAnywhere, Category = "Timeline")
    float ZOffset;

    UFUNCTION()
    void TimelineFloatReturn(float value);

    UFUNCTION()
    void OnTimelineFinished();
#+end_src

****** cpp

+ include
  #+begin_src cpp
  #include "Components/TimelineComponent.h"
  #+end_src
+ Constructor
  #+begin_src cpp
  MyTimeline = CreateDefaultSubobject<UTimelineComponent>(TEXT("Timeline"));
  // Setting timeline's settings before start it
  MyTimeline->SetLooping(false);
  MyTimeline->SetIgnoreTimeDilation(true);

  ZOffset = 50.f;
  #+end_src
+ BeginPlay
  #+begin_src cpp
  if (MyCurve)
  {
      // Declare delegate function to be binded with TimelineFloatReturn(float value)
      FOnTimelineFloat TimelineCallback;
      // Declare delegate function to be binded with OnTimelineFinished()
      FOnTimelineEvent TimelineFinishedCallback;

      TimelineCallback.BindUFunction(this, FName("TimelineFloatReturn"));
      TimelineFinishedCallback.BindUFunction(this, FName{ "OnTimelineFinished" });
      // Add the float curve to the timeline and connect it to the interpfunction's delegate
      MyTimeline->AddInterpFloat(MyCurve, TimelineCallback, FName("Alpha"));
      // Add on timeline finished function
      MyTimeline->SetTimelineFinishedFunc(TimelineFinishedCallback);

      // Setting vectors
      StartLocation = GetActorLocation();
      EndLocation = FVector(StartLocation.X, StartLocation.Y, StartLocation.Z + ZOffset);

      // Start timeline
      MyTimeline->Play();
  }
  #+end_src
+ TimelineFloatReturn(float value)
  #+begin_src cpp
  SetActorLocation(FMath::Lerp(StartLocation, EndLocation, value));
  #+end_src
+ OnTimelineFinished()
  #+begin_src cpp
  if (MyTimeline->GetPlaybackPosition() == 0.f)
  {
      MyTimeline->Play();
  }
  else if (MyTimeline->GetPlaybackPosition() == MyTimeline->GetTimelineLength())
  {
      MyTimeline->Reverse();
  }
  #+end_src

**** Death Ragdoll

***** Blueprint

#+ATTR_HTML: width="1000px"
#+ATTR_ORG: :width 1000
[[file:./images/character_death_ragdoll.webp]]

***** C++

****** cpp

#+begin_src cpp
DetachFromControllerPendingDestroy();
UCapsuleComponent* CapsuleComp = GetCapsuleComponent();
CapsuleComp->SetCollisionEnabled(ECollisionEnabled::NoCollision);
CapsuleComp->SetCollisionResponseToAllChannels(ECR_Ignore);

GetMesh()->SetCollisionProfileName(TEXT("Ragdoll"));
SetActorEnableCollision(true);

// Ragdoll
GetMesh()->SetAllBodiesSimulatePhysics(true);
GetMesh()->SetSimulatePhysics(true);
GetMesh()->WakeAllRigidBodies();
GetMesh()->bBlendPhysics = true;

UCharacterMovementComponent* CharacterComp = Cast<UCharacterMovementComponent>(GetMovementComponent());
if (CharacterComp)
{
    CharacterComp->StopMovementImmediately();
    CharacterComp->DisableMovement();
    CharacterComp->SetComponentTickEnabled(false);
}

SetLifeSpan(30.0f);
#+end_src

*** Coroutine

#+begin_quote
- two principal motivations: (1) overcoming the limitations of a single-threaded process; and (2) hoping to achieve better computational performance.

  Motivation (1) is clear to understand when the process must address many things at once where a single thread is a must.
  Motivation (2) may not be as clear to understand, since that is tied to a lot of particulars about the system hardware, compiler design, and language design. I can only imagine that computational effort might be reduced by cutting-back on stack manipulations, avoidance of redoing initializations in a subroutine, or relieving some of the overhead of maintaining a multi-threaded process
#+end_quote

good at iterating massive data and async IO

**** Terminology

- subroutine :: entered at one point and exited at another point.
- coroutine :: a more generalized form of subroutines, can be entered, exited, and resumed at many different points
- function :: essentially the same thing with subroutine.

|                  |  subroutine  |   function   |                         coroutine                          |
|                  |     <c>      |     <c>      |                            <c>                             |
|------------------+--------------+--------------+------------------------------------------------------------|
| #point of entry  |      1       |      1       |                1 or more points of re-entry                |
| Suspend & Resume |      ❌       |      ❌       |                         ✔️ (yield)                          |
| Output           | return value | return value | yield value, call stack, and pointer (promise type in C++) |

*** Miscellaneous

**** PCH (Precompiled Header)

#+begin_quote
PCH is generally not desired for c++ devs IMO.  It is counterproductive for the dev process.  I explicitly disable PCH.
People who create code from the UEditor probably don't need amazing c++ debugging capabilities, so for them, PCH may lead to faster build times.
#+end_quote

**** IWYU (include-what-you-use)

Mandatory since UE 4.24.2.

Requires explicit includes (e.g., #include "GameFramework/Actor.h" instead of monolithic Engine.h).

Enable via DefaultBuildSettings = BuildSettingsVersion.V2.

** *Unreal Engine Reflection System*

*** =UPROPERTY=

It's part of a reflection system engineered into Unreal Engine

- edit a data member in the Editor
- access a data member in blueprint script
- serialize a data member into blueprint or level instance
- synchronize a data member in multiplayer games
- data member is a pointer to a *UObject* of some form

**** Specifiers

basic three aspects

***** visibility or editability

all mutually exclusive

| specifiers          | description                                                                      |
|---------------------+----------------------------------------------------------------------------------|
| EditAnywhere        | property can be edited on archetypes and instances                               |
| EditDefaultsOnly    | property can be edited only on archetypes, not on instances                      |
| EditInstanceOnly    | property can be edited only on instances, not on archetypes                      |
| VisibleAnywhere     | property is visible, but cannot be edited                                        |
| VisibleDefaultsOnly | property is only visible for archetypes, not for instances, and cannot be edited |
| VisibleInstanceOnly | property is only visible for instances, not for archetypes, and cannot be edited |

In the real world, either *no specifier*, *VisibleAnywhere* or *EditAnywhere*, other specifiers are very uncommon

+ An oddity
  for any property pointers like mesh component, the visible specifiers seem to function the same way with edit specifiers.

***** accessibility from blueprint script

| specifiers         | description                                          |
|--------------------+------------------------------------------------------|
| BlueprintReadOnly  | property can be read by blueprints, but not modified |
| BlueprintReadWrite | property can be read or written from a blueprint     |

+ easier for maintenance
  Try to limit access to properties to blueprint script as much as possible

***** category to which belongs

completely free-form text value to group properties

***** Transient

UPROPERTY(Transient)

Any pointer to a class derived *UObject* needs to be a *UPROPERTY*, but never accessed by blueprint or editor any way

this means that it's a temporary property, and the engine should just look after clearing it up
some are generated at run-time though, and don't require editing, serialization etc.

Just so the Unreal Engine knows about, and can manage them via a smart point system

***** EditCondition(meta)

EditCondition can use boolean variable or UFUNCTION that returning a boolean value.

#+begin_src cpp
UFUNCTION()
bool MyFunc()
{
    return MyInt >5;
}

UPROPERTY(EditAnywhere)
int32 MyInt;

UPROPERTY(EditAnywhere, meta = (EditCondition = "MyFunc()", EditConditionHides))
FString MyString;
#+end_src

*** =UFUNCTION=

**** Specifiers

- =BlueprintCallable= :: function can be executed in a Blueprint
- =BlueprintPure= :: function doesn't have any side effects (a lot like a const function), great for function just return information without really doing anything

- =BlueprintImplementableEvent= :: function declared in c++, but only implemented in blueprint, check if the return value is valid when call in c++
- =BlueprintNativeEvent= :: declared in c++, implemented in c++, and possibly blueprint, the c++ function =Foo_Implementation= will only be called if blueprint implementation doesn't exist

- =Exec= :: The function can be executed from the in-game console. Exec commands only function when declared within *certain Classes*.

**** Override implementation of =BlueprintNativeEvent=

- Make sure that your function was appropriately implemented in the base class.

  #+begin_src cpp
  // .cpp
  void ACustomActor::Foo_Implementation()
  {
  }
  #+end_src

- Override in child class like this.

  #+begin_src cpp
  // header
  void Foo_Implementation() override;

  // .cpp
  void ADerivedActor::Foo_Implementation()
  {
  }
  #+end_src

or

#+begin_src cpp
    // header (base class)
    UFUNCTION(BlueprintNativeEvent)
    void Foo();
    virtual void Foo_Implementation() override;

    // .cpp(base class)
    void ADerivedActor::Foo_Implementation()
    {
    }

    // header
    virtual void Foo_Implementation() override;

    // .cpp
    void ADerivedActor::Foo_Implementation()
    {
    }
#+end_src

*** =UCLASS=

**** =StaticClass()=

Returns a pointer of UCLASS type (UObject), referring to a particular class

*** Class References =TSubclassOf=

*** Get Blueprint References

Try to *avoid* this

**** Header

#+begin_src cpp
private:
    TSubClassOf<AParentClass> ChildBP;
#+end_src

=TSubClassOf= holding a class id (UE reflection system), an unique identifier for the class, neither reference nor instance of the class

**** Construct Function

#+begin_src cpp
static ConstructorHelpers::FClassFinder<AParentClass> ChildBPClassFinder(
    TEXT("Blueprint'/Game/Path/to/ChildBP.ChildBP_C'")//Replaced .uasset with .BPNAME_C, "Content" with "Game"
);

ChildBP = ChildBPClassFinder.Class;
#+end_src

Now =ChildBP= is the Type of the Blueprint

**** Function

#+begin_src cpp
AParentClass* Parent = nullptr;

Parent = Pawn->FindParentClass(ChildBP);
if (Parent != nullptr)
{
}
#+end_src

** Modules & Plugins

*** Module

A distinct unit of C++ code, contains a build file

Code only (no assets)

**** ModuleInterface

- default implementation

in =FooBar/Private/FooBarModule.cpp=

#+begin_src cpp
#include "Modules/ModuleManager.h"

IMPLEMENT_MODULE(FDefaultModuleImpl, FooBar)
#+end_src

- custom implementation example

in =FooBar/Public/FooBarModule.h=

#+begin_src cpp
#pragma once

#include "Modules/ModuleManager.h"
//#include "AssetTypeCategories.h"

class FFooBarModule : public IModuleInterface
{
public:
    //~IModuleInterface interface
    virtual void StartupModule() override;
    virtual void ShutdownModule() override;
    //~End of IModuleInterface interface

    //static EAssetTypeCategories::Type GetAssetCategory() { return FooBarAssetCategory; }

//private:
//  void RegisterAssetTools();
//  static EAssetTypeCategories::Type FooBarAssetCategory;
};
#+end_src

in =FooBar/Private/FooBarModule.cpp=

#+begin_src cpp
#include "FooBarModule.h"
//#include "AssetToolsModule.h"

EAssetTypeCategories::Type FFooBarModule::FooBarAssetCategory;

void FFooBarModule::StartupModule()
{
    // This code will execute after your module is loaded into memory; the exact timing is specified in the .uplugin file per-module

    //RegisterAssetTools();
}

void FFooBarModule::ShutdownModule()
{
    // This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,
    // we call this function before unloading the module.
}

//void FGearInventoryEditorModule::RegisterAssetTools()
//{
//    IAssetTools& AssetTools = FAssetToolsModule::GetModule().Get();
//    FooBarAssetCategory = AssetTools.RegisterAdvancedAssetCategory(TEXT("FooBar"), NSLOCTEXT("FooBarEditor", "FooBarCategoryName", "Foo Bar"));
//}

IMPLEMENT_MODULE(FFooBarModule, FooBar)
#+end_src

*** Plugin

Collection of code and data

Made up of one or more modules

*** Dependencies

#+begin_src dot :file ./images/module_plugin_dependencies.png
digraph Dependencies {
    graph[dpi=300, fontname="Fira Code", bgcolor="#030c36", label="Dependencies", fontsize=16, fontcolor=white, rankdir=LR];
    node [shape=box, style=filled];
    edge [style=bold, color=red];
    node0 [label="Engine Module",color=lightblue];
    node1 [label="Engine Module",color=lightblue];
    node2 [label="Engine Plugin",color=lightyellow];
    node3 [label="Engine Plugin",color=lightyellow];
    node4 [label="Game Plugin",color=lightyellow];
    node5 [label="Game Plugin",color=lightyellow];
    node6 [label="Game Module",color=lightblue];
    node7 [label="Game Module",color=lightblue];

    subgraph cluster_0 {
        color=lightgrey;
        node0 -> node1;
        label="Engine";
    }

    subgraph cluster_1 {
        color=lightgrey;
        node2 -> node3;
        label="Independent";
    }

    subgraph cluster_2 {
        color=lightgrey;
        node4 -> node5;
        node6 -> node7 ;
        node6 -> node4 [constraint=false];
        label="Project Specific";
    }

    node2 -> node0 [constraint=false];
    node4 -> node2;
}
#+end_src

#+RESULTS:
[[file:./images/module_plugin_dependencies.webp]]

*** Custom plugin example

**** Build.cs

if you don't want to type the folder name in your including every time, or want to include folder outside of default Public/Private, you can add the folder to you public/private include path in Build.cs:

#+begin_src csharp
using System.IO;
//...

        PublicIncludePaths.AddRange(
            new string[] {
                Path.Combine(ModuleDirectory, "Public/Foobar")
                // ... add public include paths required here ...
            }
        );
#+end_src

*** Add custom UObject to content browser

**** uplugin

#+begin_src csharp
"Modules": [
    {
        "Name": "FooBar",
        "Type": "Runtime",
        "LoadingPhase": "PreDefault"
    },
    {
        "Name": "FooBarEditor",
        "Type": "Editor",
        "LoadingPhase": "PostEngineInit"
    }
]
#+end_src

**** Create UObject In =Runtime= or =Editor= Module

#+begin_src cpp
#include "Engine/DataAsset.h"

UCLASS(ClassGroup = MyClassGroup, Category = "MyCategory", BlueprintType, Blueprintable)
class MYMODULE_API UMyItemsDatabase : public UDataAsset
{
    GENERATED_BODY()

};
#+end_src

**** Add dependency In =Editor= Module

***** AssetDefinition (Use this instead of AssetTypeActions after UE5.2)

****** YourEditor.build.cs

#+begin_src csharp
            PrivateDependencyModuleNames.AddRange(
                new string[] {
                    "Core",
                    "CoreUObject",
                    "UnrealEd",
                    "AssetDefinition",
                    "Foobar"// Your module
                }
            );
#+end_src

****** Add Factory of the UObject in =Private= folder

******* =Private/Factories/FooBarFactory.h=

#+begin_src cpp
#pragma once

#include "Factories/Factory.h"
#include "FooBarFactory.generated.h"

/**
 * The factory for the FooBar asset type.
 * This basically integrates the new asset type into the editor, so you can right click and create a new FooBar asset.
 */
UCLASS(hidecategories=Object)
class UFooBarFactory : public UFactory
{
    GENERATED_BODY()

public:
    UFooBarFactory();

  //~UFactory interface
  virtual UObject* FactoryCreateNew(UClass* InClass, UObject* InParent, FName InName, EObjectFlags Flags, UObject* Context, FFeedbackContext* Warn) override;
  virtual bool ShouldShowInNewMenu() const override;
  virtual FText GetDisplayName() const override;
  virtual uint32 GetMenuCategories() const override;
  //virtual const TArray<FText>& GetMenuCategorySubMenus() const override; // If you want this show in a sub menu
  virtual FText GetToolTip() const override;
  virtual bool ConfigureProperties() override;
  virtual FString GetDefaultNewAssetName() const override;
  //~End of UFactory interface
};
#+end_src

******* =Private/Factories/FooBarFactory.cpp=

#+begin_src cpp
#include "Factories/FooBarFactory.h"
#include "Path/to/FooBar.h"
#include "AssetTypeCategories.h"
//#include "AssetToolsModule.h"

#define LOCTEXT_NAMESPACE "FooBarFactory"

UFooBarFactory::UFooBarFactory()
{
    bCreateNew = true;
    bEditAfterNew = true;
    SupportedClass = UFooBar::StaticClass();
}

UObject* UFooBarFactory::FactoryCreateNew(UClass* InClass, UObject* InParent, FName InName, EObjectFlags Flags, UObject* Context, FFeedbackContext* Warn)
{
    check(InClass->IsChildOf(UFooBar::StaticClass()));
    return NewObject<UFooBar>(InParent, InClass, InName, Flags | RF_Transactional, Context);;
}

bool UFooBarFactory::ShouldShowInNewMenu() const
{
    return true;
}

FText UFooBarFactory::GetDisplayName() const
{
    return LOCTEXT("FooBar_DisplayName", "Foo Bar");
}

uint32 UFooBarFactory::GetMenuCategories() const
{
    return EAssetTypeCategories::Gameplay;
}

/* other usage sample:
uint32 UFooBarFactory::GetMenuCategories() const
{
    // Multiple categories
    return EAssetTypeCategories::Gameplay | EAssetTypeCategories::Media;

    // New categories
    IAssetTools& AssetTools = FAssetToolsModule::GetModule().Get(); // or IAssetTools& AssetTools = FModuleManager::LoadModuleChecked<FAssetToolsModule>("AssetTools").Get();
    return AssetTools.RegisterAdvancedAssetCategory(TEXT("FooBar"), LOCTEXT("FooBarCategoryName", "Foo Bar"));
    // or Registered categories
    return AssetTools.FindAdvancedAssetCategory(TEXT("FooBar"));
}
,*/

//const TArray<FText>& UFooBarFactory::GetMenuCategorySubMenus() const
//{
//	static TArray<FText> SubMenus { LOCTEXT("SubMenuFooBars", "FooBars") };
//	return SubMenus;
//}

FText UFooBarFactory::GetToolTip() const
{
    return LOCTEXT("FooBar_Tooltip", "FooBar asset.");
}

bool UFooBarFactory::ConfigureProperties()
{
    return true;
}

FString UFooBarFactory::GetDefaultNewAssetName() const
{
    return FString(TEXT("FB_NewFooBar"));
}

#undef LOCTEXT_NAMESPACE
#+end_src

****** Add Definition of the UObject in =Private= folder

******* =Private/AssetTools/AssetDefinition_FooBar.h=

#+begin_src cpp
#pragma once

#include "AssetDefinitionDefault.h"
#include "AssetDefinition_FooBar.generated.h"

UCLASS()
class UAssetDefinition_FooBar : public UAssetDefinitionDefault
{
    GENERATED_BODY()

public:
    //~UAssetDefinition interface
    FText GetAssetDisplayName() const override final;
    TSoftClassPtr<UObject> GetAssetClass() const override final;
    FLinearColor GetAssetColor() const override final;
    FText GetAssetDescription(const FAssetData& AssetData) const override final;
    TConstArrayView<FAssetCategoryPath> GetAssetCategories() const override final;
    //~End of UAssetDefinition interface
};
#+end_src

******* =Private/AssetTools/AssetDefinition_FooBar.cpp=

#+begin_src cpp
#include "AssetTools/AssetDefinition_FooBar.h"
#include "Path/to/FooBar.h"

#define LOCTEXT_NAMESPACE "AssetDefinition_FooBar"

FText UAssetDefinition_FooBar::GetAssetDisplayName() const
{
    return LOCTEXT("AssetTypeActions_FooBar", "Foo Bar");
}

TSoftClassPtr<UObject> UAssetDefinition_FooBar::GetAssetClass() const
{
    return UFooBar::StaticClass();
}

FLinearColor UAssetDefinition_FooBar::GetAssetColor() const
{
    return FLinearColor(FColor(201, 29, 85));
}

FText UAssetDefinition_FooBar::GetAssetDescription(const FAssetData& AssetData) const
{
    return LOCTEXT("AssetTypeActions_FooBarDesc", "A collection of FooBar.");
}

TConstArrayView<FAssetCategoryPath> UAssetDefinition_FooBar::GetAssetCategories() const
{
    static const auto Categories = { EAssetCategoryPaths::Gameplay };
    return Categories;
}

#undef LOCTEXT_NAMESPACE
#+end_src

******* (Additional) For DataAsset supporting diff and merge

#+begin_src cpp
EAssetCommandResult PerformAssetDiff(const FAssetDiffArgs& DiffArgs) const override final;

bool CanMerge() const override final;
EAssetCommandResult Merge(const FAssetAutomaticMergeArgs& MergeArgs) const override final;
EAssetCommandResult Merge(const FAssetManualMergeArgs& MergeArgs) const override final;
#+end_src

#+begin_src cpp
#include "SDetailsDiff.h"// in module Kismet
#include "MergeUtils.h"

EAssetCommandResult UAssetDefinition_DataAsset::PerformAssetDiff(const FAssetDiffArgs& DiffArgs) const
{
    if (DiffArgs.OldAsset == nullptr && DiffArgs.NewAsset == nullptr)
    {
        return EAssetCommandResult::Unhandled;
    }

    const TSharedRef<SDetailsDiff> DetailsDiff = SDetailsDiff::CreateDiffWindow(DiffArgs.OldAsset, DiffArgs.NewAsset, DiffArgs.OldRevision, DiffArgs.NewRevision, UDataAsset::StaticClass());
    // allow users to edit NewAsset if it's a local asset
    if (!FPackageName::IsTempPackage(DiffArgs.NewAsset->GetPackage()->GetName()))
    {
        DetailsDiff->SetOutputObject(DiffArgs.NewAsset);
    }
    return EAssetCommandResult::Handled;
}

bool UAssetDefinition_DataAsset::CanMerge() const
{
    return true;
}

EAssetCommandResult UAssetDefinition_DataAsset::Merge(const FAssetAutomaticMergeArgs& MergeArgs) const
{
    return MergeUtils::Merge(MergeArgs);
}

EAssetCommandResult UAssetDefinition_DataAsset::Merge(const FAssetManualMergeArgs& MergeArgs) const
{
    return MergeUtils::Merge(MergeArgs);
}
#+end_src

****** Another nested arrangement

******* =Private/FooBarAssetDefinitions.h=

#+begin_src cpp
#pragma once

#include "AssetDefinitionDefault.h"
#include "Path/to/FooBarAssetOne.h"
#include "Path/to/FooBarAssetTwo.h"

namespace UE::FooBar
{
    FLinearColor GetAssetColor();
    TConstArrayView<FAssetCategoryPath> GetAssetCategories();
    UThumbnailInfo* LoadThumbnailInfo(const FAssetData& InAssetData);
} // namespace UE::FooBar

#define LOCTEXT_NAMESPACE "FooBarAssetDefinition"

UCLASS()
class UAssetDefinition_FooBarAssetOne : public UAssetDefinitionDefault
{
    GENERATED_BODY()

public:
    virtual FLinearColor GetAssetColor() const override { return UE::FooBar::GetAssetColor(); }
    virtual TConstArrayView<FAssetCategoryPath> GetAssetCategories() const override { return UE::FooBar::GetAssetCategories(); }
    virtual UThumbnailInfo* LoadThumbnailInfo(const FAssetData& InAssetData) const override { return UE::FooBar::LoadThumbnailInfo(InAssetData); }

    virtual FText GetAssetDisplayName() const override { return LOCTEXT("DisplayName_UFooBarAssetOne", "Foo Bar Asset One"); }
    virtual TSoftClassPtr<UObject> GetAssetClass() const override { return UFooBarAssetOne::StaticClass(); }
};

UCLASS()
class UAssetDefinition_FooBarAssetTwo : public UAssetDefinitionDefault
{
    GENERATED_BODY()

public:
    virtual FLinearColor GetAssetColor() const override { return UE::FooBar::GetAssetColor(); }
    virtual TConstArrayView<FAssetCategoryPath> GetAssetCategories() const override { return UE::FooBar::GetAssetCategories(); }
    virtual UThumbnailInfo* LoadThumbnailInfo(const FAssetData& InAssetData) const override { return UE::FooBar::LoadThumbnailInfo(InAssetData); }

    virtual FText GetAssetDisplayName() const override { return LOCTEXT("DisplayName_UFooBarAssetTwo", "Foo Bar Asset Two"); }
    virtual TSoftClassPtr<UObject> GetAssetClass() const override { return UFooBarAssetTwo::StaticClass(); }
};

#undef LOCTEXT_NAMESPACE
#+end_src

******* =Private/FooBarAssetDefinitions.cpp=

#+begin_src cpp
#include "FooBarAssetDefinitions.h"
#include "ThumbnailRendering/SceneThumbnailInfo.h"

namespace UE::FooBar
{

FLinearColor GetAssetColor()
{
    static const FLinearColor AssetColor(FColor(29, 96, 125));
    return AssetColor;
}

TConstArrayView<FAssetCategoryPath> GetAssetCategories()
{
    static const auto Categories = { FAssetCategoryPath(EAssetCategoryPaths::Animation, NSLOCTEXT("FooBarAssetDefinition", "FooBarAssetDefinitionMenu", "FooBar")) };
    return Categories;
}

UThumbnailInfo* LoadThumbnailInfo(const FAssetData & InAssetData)
{
    return UE::Editor::FindOrCreateThumbnailInfo(InAssetData.GetAsset(), USceneThumbnailInfo::StaticClass());
}

} // namespace UE::FooBar
#+end_src

****** Use custom assets category

******* Simple way

in =AssetDefinition_FooBar::GetAssetCategories=

#+begin_src cpp
#define LOCTEXT_NAMESPACE "AssetDefinition_FooBar"

TConstArrayView<FAssetCategoryPath> UAssetDefinition_FooBar::GetAssetCategories() const
{
    static const auto Categories = { FAssetCategoryPath(LOCTEXT("FooBarAssetsCategoryName", "FooBar")) };
    return Categories;
}

#undef LOCTEXT_NAMESPACE
#+end_src

if you want a sub menu:

#+begin_src cpp
{
    //static const auto Categories = { FAssetCategoryPath(EAssetCategoryPaths::Gameplay, LOCTEXT("FooBar_SubCategory", "FooBarSub")) };
    static const auto Categories = { EAssetCategoryPaths::Gameplay / LOCTEXT("FooBarAssetsCategoryName", "FooBar") };
    return Categories;
}
#+end_src

******* AssetTool way

#+begin_src cpp
#include "AssetToolsModule.h"

// Usually StartModule
{
    IAssetTools& AssetTools = FModuleManager::LoadModuleChecked<FAssetToolsModule>("AssetTools").Get();
    FooBarAssetsCategory = AssetTools.RegisterAdvancedAssetCategory(TEXT("FooBar"), LOCTEXT("FooBarAssetsCategoryName", "FooBar"));
}
#+end_src

***** AssetTypeActions (Deprecated)

****** build.cs

#+begin_src csharp
            PrivateDependencyModuleNames.AddRange(
                new string[] {
                    "Core",
                    "CoreUObject",
                    "UnrealEd",
                    "AssetTools",// for addition AssetTypeActions
                }
            );
#+end_src

****** Add Factory of the UObject in =Private= folder (could be inside YourModule.h)

#+begin_src cpp
#pragma once

#include "Factories/Factory.h"
#include "MyModuleEditorModule.generated.h"

// Asset factories

UCLASS()
class MYMODULEEDITOR_API UMyItemsDatabase_Factory : public UFactory
{
    GENERATED_UCLASS_BODY()

public:
    virtual UObject* FactoryCreateNew(UClass* InClass, UObject* InParent, FName InName, EObjectFlags Flags, UObject* Context, FFeedbackContext* Warn) override;

protected:
    virtual bool IsMacroFactory() const { return false; }
};

UCLASS()
class MYMODULEEDITOR_API UOtherObject_Factory : public UFactory
{
    GENERATED_UCLASS_BODY()

public:
    virtual UObject* FactoryCreateNew(UClass* InClass, UObject* InParent, FName InName, EObjectFlags Flags, UObject* Context, FFeedbackContext* Warn) override;

protected:
    virtual bool IsMacroFactory() const { return false; }
};
#+end_src

****** YourModule.cpp

#+begin_src cpp
#include "MyModuleEditorModule.h"
#include "MyItemsDatabase.h"

class FMyModuleEditorModule : public IModuleInterface
{
    // ...
}

IMPLEMENT_MODULE(FMyModuleEditorrModule, MyModuleEditor)

// Asset factories

// MyItemsDatabase
UMyItemsDatabase_Factory::UMyItemsDatabase_Factory(const class FObjectInitializer &OBJ) : Super(OBJ)
{
    SupportedClass = UMyItemsDatabase::StaticClass();
    bEditAfterNew = true;
    bCreateNew = true;
}

UObject* UMyItemsDatabase_Factory::FactoryCreateNew(UClass* InClass, UObject* InParent, FName InName, EObjectFlags Flags, UObject* Context, FFeedbackContext* Warn)
{
    check(InClass->IsChildOf(UMyItemsDatabase::StaticClass()));
    return NewObject<UMyItemsDatabase>(InParent, InClass, InName, Flags | RF_Transactional, Context);
}
#+end_src

Now we can create the object from editor menu (in Miscellaneous category), but not support filter yet.

****** Create new AssetTypeActions in =Private= folder (in module cpp or other file)

#+begin_src cpp
class FMyModuleEditorModule : public IModuleInterface
{
public:
    //~IModuleInterface interface
    virtual void StartupModule() override;
    virtual void ShutdownModule() override;
    //~End of IModuleInterface interface

    static EAssetTypeCategories::Type GetAssetsCategory() { return MyAssetsCategory; }

private:
    void RegisterAssetTypeActions(IAssetTools& AssetTools, TSharedRef<IAssetTypeActions> Action)
    {
        AssetTools.RegisterAssetTypeActions(Action);
        CreatedAssetTypeActions.Add(Action);
    }

    TArray< TSharedPtr<IAssetTypeActions> > CreatedAssetTypeActions;

    static EAssetTypeCategories::Type MyAssetCategory;
}

EAssetTypeCategories::Type FMyModuleEditorModule::MyAssetCategory;

IMPLEMENT_MODULE(FMyModuleEditorrModule, MyModuleEditor)
#+end_src

#+begin_src cpp
#include "MyModuleEditorModule.h"
#include "AssetTypeActions_Base.h"
#include "AssetTypeActions/AssetTypeActions_DataAsset.h"
#include "MyItemsDatabase.h"

#define LOCTEXT_NAMESPACE "MyModuleEditor"

// Asset type actions

class FAssetTypeActions_MyItemsDatabase : public FAssetTypeActions_Base
{
public:
    virtual FText GetName() const override { return LOCTEXT("MyDataAsset", "My Items Data Asset"); }
    virtual uint32 GetCategories() override { return FMyModuleEditorModule::GetAssetsCategory(); }
    virtual FColor GetTypeColor() const override { return FColor(127, 255, 255); }
    virtual FText GetAssetDescription(const FAssetData &AssetData) const override { return LOCTEXT("MyDataAssetDesc", "My DataAsset description."); }
    virtual UClass* GetSupportedClass() const override { return UMyItemsDatabase::StaticClass(); }
};

class FAssetTypeActions_MyDataAsset : public FAssetTypeActions_DataAsset
{
public:
    virtual FText GetName() const override { return NSLOCTEXT("AssetTypeActions", "AssetTypeActions_MyDataAsset", "My Data Asset"); }
    virtual uint32 GetCategories() override { return FTaggedInputEditorModule::GetAssetsCategory(); }
    virtual FColor GetTypeColor() const override { return FColor(127, 255, 255); }
    virtual FText GetAssetDescription(const FAssetData& AssetData) const override { return NSLOCTEXT("AssetTypeActions", "AssetTypeActions_MyDataAssetDesc", "My DataAsset description."); }
    virtual UClass* GetSupportedClass() const override { return UMyDataAsset::StaticClass(); }
};

#undef LOCTEXT_NAMESPACE
#+end_src

****** Register in =StartupModule()=

#+begin_src cpp
void FMyModuleEditorModule::StartupModule()
{
    // Register asset types
    IAssetTools &AssetTools = FModuleManager::LoadModuleChecked<FAssetToolsModule>("AssetTools").Get();
    // Register category
    MyAssetCategory = AssetTools.RegisterAdvancedAssetCategory(TEXT("MyCustomCategory"), LOCTEXT("MyCustomCategory", "MyCustomCategory"));
    // Register asset type actions
    {
        RegisterAssetTypeActions(AssetTools, MakeShareable(new FAssetTypeActions_MyItemsDatabase));
    }
}
#+end_src

****** Unregister in =ShutdownModule()=

#+begin_src cpp
void FMyModuleEditorModule::StartupModule()
{
    // Unregister asset type actions
    if (FModuleManager::Get().IsModuleLoaded("AssetTools"))
    {
        IAssetTools& AssetToolsModule = FModuleManager::GetModuleChecked<FAssetToolsModule>("AssetTools").Get();
      for (auto& AssetTypeAction : CreatedAssetTypeActions)
      {
          if (AssetTypeAction.IsValid())
          {
              AssetToolsModule.UnregisterAssetTypeActions(AssetTypeAction.ToSharedRef());
          }
      }
    }
    CreatedAssetTypeActions.Empty();
}
#+end_src

*** Creating assets with support of a custom class picker

**** MyAssetFactory.h

#+begin_src cpp
#pragma once

#include "CoreMinimal.h"
#include "Templates/SubclassOf.h"
#include "Factories/Factory.h"
#include "ClassViewerModule.h"
#include "ClassViewerFilter.h"
#include "MyAssetFactory.generated.h"

UCLASS(HideCategories=Object, MinimalAPI)
class UMyAssetFactory : public UFactory
{
    GENERATED_UCLASS_BODY()

public:

    // The parent class of the created blueprint
    UPROPERTY(EditAnywhere, Category = UMyAssetFactory)
    TSubclassOf<class UMyAsset> ParentClass;

    //~UFactory interface
    virtual bool ConfigureProperties() override;
    virtual UObject* FactoryCreateNew(UClass* Class, UObject* InParent, FName Name, EObjectFlags Flags, UObject* Context, FFeedbackContext* Warn) override;
    //~End of UFactory interface
};

class FMyAssetClassFilter : public IClassViewerFilter
{
public:
    TSet<const UClass*> AllowedChildrenOfClasses;
    EClassFlags DisallowedClassFlags;

    virtual bool IsClassAllowed(const FClassViewerInitializationOptions& InInitOptions, const UClass* InClass, TSharedRef<class FClassViewerFilterFuncs> InFilterFuncs) override
    {
         return !InClass->HasAnyClassFlags(DisallowedClassFlags) && InFilterFuncs->IfInChildOfClassesSet(AllowedChildrenOfClasses, InClass) != EFilterReturn::Failed;
    }

    virtual bool IsUnloadedClassAllowed(const FClassViewerInitializationOptions& InInitOptions, const TSharedRef<const IUnloadedBlueprintData> InUnloadedClassData, TSharedRef<FClassViewerFilterFuncs> InFilterFuncs) override
    {
         return !InUnloadedClassData->HasAnyClassFlags(DisallowedClassFlags) && InFilterFuncs->IfInChildOfClassesSet(AllowedChildrenOfClasses, InUnloadedClassData) != EFilterReturn::Failed;
    }
};
#+end_src

**** MyAssetFactory.cpp

#+begin_src cpp
#include "MyAssetFactory.h"
#include "UnrealEd.h"
#include "ClassViewerModule.h"
#include "ClassViewerFilter.h"
#include "Kismet2/SClassPickerDialog.h"
#include "MyAsset.h"

#define LOCTEXT_NAMESPACE "UMyAssetFactory"

UMyAssetFactory::UMyAssetFactory(const FObjectInitializer& ObjectInitializer)
    : Super(ObjectInitializer)
{
    bCreateNew = true;
    bEditAfterNew = true;
    SupportedClass = UMyAsset::StaticClass();
}

bool UMyAssetFactory::ConfigureProperties()
{
    // nullptr the ParentClass so we can check for selection
    ParentClass = nullptr;

    // Load the classviewer module to display a class picker
    FClassViewerModule& ClassViewerModule = FModuleManager::LoadModuleChecked<FClassViewerModule>("ClassViewer");

    FClassViewerInitializationOptions Options;
    Options.Mode = EClassViewerMode::ClassPicker;

    TSharedPtr<FGearModClassFilter> Filter = MakeShareable(new FGearModClassFilter);
    Filter->AllowedChildrenOfClasses.Add(UGearMod::StaticClass());
    // Prevent selecting Abstract, Deprecated classes
    Filter->DisallowedClassFlags = CLASS_Abstract | CLASS_Deprecated;

    // Options.ClassFilters;
    Options.ClassFilter = Filter;//deprecated

    const FText TitleText = LOCTEXT("CreateMyAssetOptions", "Pick My Asset Class");
    UClass* ChosenClass = nullptr;
    const bool bPressedOk = SClassPickerDialog::PickClass(TitleText, Options, ChosenClass, UMyAsset::StaticClass());

    if (bPressedOk)
    {
        ParentClass = ChosenClass;
    }

    return bPressedOk;
};

UObject* UMyAssetFactory::FactoryCreateNew(UClass* Class, UObject* InParent, FName Name, EObjectFlags Flags, UObject* Context, FFeedbackContext* Warn)
{
      if (ParentClass != nullptr)
      {
           return NewObject<UMyAsset>(InParent, ParentClass, Name, Flags | RF_Transactional);
      }
      else
      {
           check(Class->IsChildOf(UMyAsset::StaticClass()));
           return NewObject<UMyAsset>(InParent, Class, Name, Flags | RF_Transactional);
      }
}

#undef LOCTEXT_NAMESPACE
#+end_src

** *Unreal Build System*

*** Unreal Header Tool (UHT)

**** Reflection

include "Actor.generated.h"
Macro

*** Unreal Build Tool (UBT)

*** Build Configuration

*** Build scripts

#+begin_src csharp
PublicDependencyModuleNames.AddRange(new string[]{ "Core", "CoreUObject", "Engine"});
#+end_src

#+begin_quote
Build scripts are written in C# and this line adds decencies to the your module build rules, “Core” module contains most basic functions that you use in C++ inside UE4, “CoreUObject” contains module UObject system, root of class tree in UE4 and “Engine” is core of engine it self. Engine is divided in to more modules (“Engine” module only contains core things), you can see them as dlls in binary folder in the engine and you need to add decency if you referenceing anything from that specific module, this way UnrealBuidTool knows what to build during packaging and properly configures compilation environment for your module, so build is fully optimized.
#+end_quote

*** Specify Compiler Version (Windows)

**** (Global) In =BuildConfiguration.xml= (on Windows, under =%AppData%\Unreal Engine\UnrealBuildTool=)

#+begin_src xml
<?xml version="1.0" encoding="utf-8" ?>
<Configuration xmlns="https://www.unrealengine.com/BuildConfiguration">
    <WindowsPlatform>
        <Compiler>VisualStudio2022</Compiler>
        <CompilerVersion>14.38.33130</CompilerVersion>
    </WindowsPlatform>
</Configuration>
#+end_src

**** (Per project) In =.Target.cs= (under =Source/=)

#+begin_src csharp
public class GFEOTBEditorTarget : TargetRules
{
    public MyProjectEditorTarget(TargetInfo Target) : base(Target)
    {
        // ...
        WindowsPlatform.Compiler = WindowsCompiler.VisualStudio2022;
        WindowsPlatform.CompilerVersion = "14.38.33130";
    }
}
#+end_src

**** In =DefaultEngine.ini= (under =Config/=)

#+begin_src conf
[/Script/WindowsTargetPlatform.WindowsTargetSettings]
Compiler=VisualStudio2022
CompilerVersion="14.38.33130"
#+end_src

*** Inline Generated Cpp

This improves compile times because less header parsing is required.

**** Usage (in cpp file)

#+begin_src cpp
#include UE_INLINE_GENERATED_CPP_BY_NAME(FileName)
#+end_src

**** Definition

#+begin_src cpp
// Used to inline generated cpp files from UObject headers
#define UE_INLINE_STRINGIFY(name) #name
#if UE_DISABLE_INLINE_GEN_CPP
    #define UE_INLINE_GENERATED_CPP_BY_NAME(name) UE_INLINE_STRINGIFY(CoreTypes.h)
#else
    #define UE_INLINE_GENERATED_CPP_BY_NAME(name) UE_INLINE_STRINGIFY(name.gen.cpp)
#endif
#+end_src

So =#include UE_INLINE_GENERATED_CPP_BY_NAME(FileName)= is actually =#include "FileName.gen.cpp"=

It simply includes the equivalent generated cpp file into the current cpp - which doesn't affect anything functional but means that the generated cpp will be part of the same translation unit (a single unit of compilation, usually one cpp file and everything it includes, or a bunch of cpp files when dealing with unity build).

** Platform Compatibility

*** Android

**** Check tool chain version

in =Engine/Config/Android/Android_SDK.json=

* Editor

** Editor Utilities

*** Add =MyGameEditor= Module alongside Game Module

+ Create new editor module under Source folder

+ Add the editor module to Source/MyGameEditor.Target.cs

#+begin_src csharp
public class MyGameEditorTarget : TargetRules
{
    public MyGameEditorTarget(TargetInfo Target) : base(Target)
    {
        Type = TargetType.Editor;
        DefaultBuildSettings = BuildSettingsVersion.Latest;
        IncludeOrderVersion = EngineIncludeOrderVersion.Latest;

        // Add our editor module
        ExtraModuleNames.AddRange(new string[] { "MyGame", "MyGameEditor" });
    }
}
#+end_src

*** Editor Validator Subsystem

This is for proper asset config, expand *Validate Assets* processing when save an asset.

**** Implement

1. Inherit from =UEditorValidatorBase= (C++ or Editor Utility Blueprint)

2. Override function =CanValidateAsset_Implementation(UObject* InAsset)= to specify which kinds of asset to check

  - e.g. check material functions

    #+begin_src cpp
    bool UEditorValidator_MaterialFunctions::CanValidateAsset_Implementation(UObject* InAsset) const
    {
        return Super::CanValidateAsset_Implementation(InAsset) && (InAsset ? InAsset->IsA(UMaterialFunction::StaticClass()) : false);
    }
    #+end_src

  - e.g. validate specific asset path

    #+begin_src cpp
    bool UEditorValidator_MaterialFunctions::CanValidateAsset_Implementation(UObject* InAsset) const
    {
        if (InAsset)
        {
            if (!InAsset->IsA(UBlueprint::StaticClass())) return(false);

            // Asset path contaims "Game/Character/"
            UBlueprint* Blueprint = Cast<UBlueprint>(InAsset);
            if (Blueprint->GetPathName().Contains(TEXT("/Game/Character/"), ESearchCase::CaseSensitive))
            {
                return(true);
            }

            // use wildcard pattern matching
            //if (Blueprint->GetPathName().MatchesWildcard(TEXT("/Game/Character/Chara??BP.*"), ESearchCase::CaseSensitive))
            //{
            //    return(true);
            //}
        }

        return(false);
    }
    #+end_src

3. Override function =ValidateLoadedAsset_Implementation(UObject* InAsset, TArray<FText>& ValidationErrors)= to implement validate logic

  - If check passes, call =AssetPasses(InAsset)= (C++/BP) and will return =EDataValidationResult::Valid=.
  - If check fails, call =AssetFails(InAsset, FText::FromString(WarningOrError), ValidationErrors)= and will return =EDataValidationResult::Invalid=.
  - Similar for warning.

  #+begin_src cpp
  EDataValidationResult UEditorValidator_MaterialFunctions::ValidateLoadedAsset_Implementation(UObject* InAsset, TArray<FText>& ValidationErrors)
  {
      // ...

      if (GetValidationResult() != EDataValidationResult::Invalid)
      {
          AssetPasses(InAsset);
      }

      return GetValidationResult();
  }
  #+end_src

**** e.g. Validate AActor

- Since using actor CDO for validation, properties of the actor's components can be checked only if components created by =CreateDefaultSubobject= via actor constructor.

  #+begin_src cpp
  EDataValidationResult UMyEditorValidatorBase::ValidateLoadedAsset_Implementation(UObject* InAsset, TArray<FText>& ValidationErrors)
  {
    UBlueprint* Blueprint = Cast<UBlueprint>(InAsset);
    check(Blueprint);

    AActor* CDO = Blueprint->GeneratedClass->GetDefaultObject<AActor>();
    if (!CDO)
    {
        AssetFails(InAsset, FText::FromString(TEXT("FAILED to get CDO")), ValidationErrors);
    }
    else
    {
        // check code
    }

    if (GetValidationResult() != EDataValidationResult::Invalid)
    {
        AssetPasses(InAsset);
    }

    return GetValidationResult();
  }
  #+end_src

*** Editor Utility Widget

TODO

*** FSlateStyleSet

Manages the style which provides resources for editor widgets.

Ref: NiagaraEditorStyle

*** Commandlet

for bulk edit assets (typically for automation).

*** Change to custom editor/engine

The =GameEngine= class should inherited from ~UGameEngine~, =UnrealEdEngine= and =EditorEngine= should inherited from ~UUnrealEdEngine~.

#+begin_quote
For anyone who ever wondered what is the difference between the =EditorEngine= and the =UnrealEdEngine=: the =EditorEngine= is created when running editor =commandlets=.
#+end_quote

in =Config/DefaultEngine.ini=:

#+begin_src conf
[/Script/Engine.Engine]
GameEngine=/Script/GAME.GAMEEngine
UnrealEdEngine=/Script/GAMEEditor.GAMEEditorEngine
EditorEngine=/Script/GAMEEditor.GAMEEditorEngine
#+end_src

*** Change default classes that appear in the new blueprint dialogue

in =Config/DefaultEditor.ini=:

#+begin_src conf
; This sets the default classes that appear in the new blueprint dialogue
[/Script/UnrealEd.UnrealEdOptions]
!NewAssetDefaultClasses=ClearArray
+NewAssetDefaultClasses=(ClassName="/Script/LyraGame.LyraCharacter", AssetClass="/Script/Engine.Blueprint")
+NewAssetDefaultClasses=(ClassName="/Script/LyraGame.LyraGameMode", AssetClass="/Script/Engine.Blueprint")
+NewAssetDefaultClasses=(ClassName="/Script/LyraGame.LyraGameplayAbility", AssetClass="/Script/Engine.Blueprint")
+NewAssetDefaultClasses=(ClassName="/Script/GameplayAbilities.GameplayEffect", AssetClass="/Script/Engine.Blueprint")
+NewAssetDefaultClasses=(ClassName="/Script/GameplayAbilities.GameplayCueNotify_Burst", AssetClass="/Script/Engine.Blueprint")
+NewAssetDefaultClasses=(ClassName="/Script/GameplayAbilities.GameplayCueNotify_BurstLatent", AssetClass="/Script/Engine.Blueprint")
+NewAssetDefaultClasses=(ClassName="/Script/GameplayAbilities.GameplayCueNotify_Looping", AssetClass="/Script/Engine.Blueprint")
#+end_src

changed default Actor (when you create a new actor) in ProjectSettings > =DefaultBlueprintBaseClass=

** Add Custom Sections (Filter Buttons) to Details Panel

#+begin_src cpp
// const TSharedRef<FPropertySection> Section = PropertyModule.FindOrCreateSection(ClassName, SectionName, DisplayName);
// Section->AddCategory(CategoryName);

// ClassName = The class you want this section to show up in the details panel
// Section Name = Unique name for the new section
// DisplayName = DisplayName on the details panel
// CategoryName = filter categories

// Add the Cloth Component "Cloth Sim" section to the Details panel UI
FPropertyEditorModule& PropertyModule = FModuleManager::GetModuleChecked<FPropertyEditorModule>("PropertyEditor");
{
    const TSharedPtr<FPropertySection> Section = PropertyModule.FindOrCreateSection(UChaosClothComponent::StaticClass()->GetFName(), TEXT("ClothSim"), LOCTEXT("ClothSim", "Cloth Sim"));
    Section->AddCategory("Cloth Component");
}
PropertyModule.NotifyCustomizationModuleChanged();
#+end_src

#+begin_src cpp
virtual void ShutdownModule() override
{
#if WITH_EDITOR
    if (UObjectInitialized())
    {
        // Remove sections
        FPropertyEditorModule& PropertyModule = FModuleManager::GetModuleChecked<FPropertyEditorModule>("PropertyEditor");
        PropertyModule.RemoveSection(UChaosClothComponent::StaticClass()->GetFName(), TEXT("ClothSim"));
    }
#endif
}
#+end_src

if not an editor module, wrap them with =#if WITH_EDITOR=

** Add validator to check collision profile "Custom..."

#+begin_src cpp
#pragma once

#include "EditorValidatorBase.h"
#include "EditorValidator_CollisionPresetCustom.generated.h"

class UPrimitiveComponent;

/**
 * UEditorValidator_CollisionPresetCustom
 *
 *  Check if the asset is using "Custom..." as collision profile.
 *  The "Custom..." profile is:
 *    - Source of inconsistency, setup error
 *    - Hard to make large scale changes to channel usage
 *    - Lots of retroactive work to assign collision presets
 */
UCLASS()
class UEditorValidator_CollisionPresetCustom : public UEditorValidatorBase
{
    GENERATED_BODY()

public:
    //~UEditorValidatorBase interface
    virtual bool CanValidateAsset_Implementation(const FAssetData& InAssetData, UObject* InObject, FDataValidationContext& InContext) const override;
    virtual EDataValidationResult ValidateLoadedAsset_Implementation(const FAssetData& InAssetData, UObject* InAsset, FDataValidationContext& Context) override;
    //~End of UEditorValidatorBase interface

private:
    bool IsUsingCustomPreset(const UPrimitiveComponent* PrimitiveComponent) const;
};
#+end_src

#+begin_src cpp
#include "EditorValidator_CollisionPresetCustom.h"

#include "Engine/Blueprint.h"
#include "Components/PrimitiveComponent.h"
#include "GameFramework/Actor.h"
#include "Misc/DataValidation.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(EditorValidator_CollisionPresetCustom)

#define LOCTEXT_NAMESPACE "EditorValidator"

bool UEditorValidator_CollisionPresetCustom::CanValidateAsset_Implementation(const FAssetData& InAssetData, UObject* InObject, FDataValidationContext& InContext) const
{
    return InObject && InObject->IsA<UBlueprint>();
}

EDataValidationResult UEditorValidator_CollisionPresetCustom::ValidateLoadedAsset_Implementation(const FAssetData& InAssetData, UObject* InAsset, FDataValidationContext& Context)
{
    const auto* Blueprint = Cast<UBlueprint>(InAsset);
    if (!Blueprint)
    {
        return EDataValidationResult::NotValidated;
    }

    if (Blueprint->GeneratedClass->IsChildOf<UPrimitiveComponent>())
    {
        const auto* PrimitiveComp = GetDefault<UPrimitiveComponent>(Blueprint->GeneratedClass);
        if (PrimitiveComp && IsUsingCustomPreset(PrimitiveComp))
        {
            Context.AddError(FText::FromString(TEXT("The 'Custom...' collision profile might cause trouble, use/add preset in ProjectSettings.")));
            return EDataValidationResult::Invalid;
        }
    }
    else if (Blueprint->GeneratedClass->IsChildOf<AActor>())
    {
        const auto* Actor = GetDefault<AActor>(Blueprint->GeneratedClass);
        if (Actor)
        {
            TInlineComponentArray<UPrimitiveComponent*> PrimComponents(Actor);
            for (const UPrimitiveComponent* Entry : PrimComponents)
            {
                if (IsUsingCustomPreset(Entry))
                {
                    Context.AddError(FText::FromString(TEXT("The 'Custom...' collision profile might cause trouble, use/add preset in ProjectSettings.")));
                    return EDataValidationResult::Invalid;
                }
            }
        }
    }

    return EDataValidationResult::Valid;
}

bool UEditorValidator_CollisionPresetCustom::IsUsingCustomPreset(const UPrimitiveComponent* PrimitiveComponent) const
{
    if (IsValid(PrimitiveComponent) && PrimitiveComponent->GetCollisionProfileName().IsEqual(TEXT("Custom")))
    {
        return true;
    }

    return false;
}

#undef LOCTEXT_NAMESPACE
#+end_src

* *HID*

** Enhanced Input

*** Setup

+ Enable Plugin
  =ProjectSettings= > =Engine - Input= > =Default Classes= > =Default Player Input Class= > =EnhancedPlayerInput=
  =ProjectSettings= > =Engine - Input= > =Default Classes= > =Default Input Component Class= > =EnhancedInputComponent=

*** Implement

**** Build.cs

#+begin_src csharp
PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "EnhancedInput" });
#+end_src

**** .h

#+begin_src cpp
#include "InputActionValue.h"

// Forward declaration
class UInputAction;
class UInputMappingContext;
#+end_src

#+begin_src cpp
protected:
    virtual void PawnClientRestart() override;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Player Controls|Input Action")
    UInputAction* YourAction;

    /** Input mapping to add to the input system */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Player Controls|Input Mapping")
    UInputMappingContext* BaseInputMappingContext = nullptr;

    /** Priority to bind mapping context with */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Player Controls|Input Mapping")
    int BaseInputPriority = 0;
#+end_src

**** .cpp

+ Header
#+begin_src cpp
#include "EnhancedInputComponent.h"
#include "EnhancedInputSubsystems.h"
#+end_src

+ Subsystem
#+begin_src cpp
void AShooterCharacter::PawnClientRestart()
{
    Super::PawnClientRestart();

    // Make sure that we have a valid PlayerController.
    if (APlayerController* PC = Cast<APlayerController>(GetController()))
    {
        // Get the Enhanced Input Local Player Subsystem from the Local Player related to our Player Controller.
        if (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(PC->GetLocalPlayer()))
        {
            // PawnClientRestart can run more than once in an Actor's lifetime, so start by clearing out any leftover mappings.
            Subsystem->ClearAllMappings();

            // Add each mapping context, along with their priority values. Higher values outprioritize lower values.
            Subsystem->AddMappingContext(BaseInputMappingContext, BaseInputPriority);
        }
    }
}
#+end_src

+ Handler function
#+begin_src cpp
#include "Logging/StructuredLog.h"
#include <source_location>

void AMyPawn::MyFirstAction(const FInputActionValue& Value)
{
    // Debug log output to confirm that the handler function is running.
    UE_LOGFMT(LogTemp, Warning, "{0} called with Input Action Value {1} (magnitude {2})", std::source_location::current().function_name(), Value.ToString(), Value.GetMagnitude());
    // Use the GetType() function to determine Value's type, and the [] operator with an index between 0 and 2 to access its data.
}
#+end_src

+ Setup Input Component to bind function to *Input Action*
#+begin_src cpp
void AYourGameCharacter::SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent)
{
    // Make sure that we are using a UEnhancedInputComponent; if not, the project is not configured correctly.
    if (UEnhancedInputComponent* PlayerEnhancedInputComponent = Cast<UEnhancedInputComponent>(PlayerInputComponent))
    {
        // There are ways to bind a UInputAction* to a handler function and multiple types of ETriggerEvent that may be of interest.

        // This calls the handler function on the tick when MyInputAction starts, such as when pressing an action button.
        if (MyInputAction)
        {
            PlayerEnhancedInputComponent->BindAction(MyInputAction, ETriggerEvent::Started, this, &AMyPawn::MyInputHandlerFunction);
        }

        // This calls the handler function (a UFUNCTION) by name on every tick while the input conditions are met, such as when holding a movement key down.
        if (MyOtherInputAction)
        {
            PlayerEnhancedInputComponent->BindAction(MyOtherInputAction, ETriggerEvent::Triggered, this, TEXT("MyOtherInputHandlerFunction"));
        }
    }
}
#+end_src

*** Debug

~showdebug EnhancedInput~

*** Input Trigger

#+ATTR_HTML: width="600px"
#+ATTR_ORG: :width 600
[[file:./images/enhanced_input_trigger.webp]]

**** Trigger State

+ None
+ Ongoing
+ Triggered

**** Trigger Event

#+begin_src cpp
enum class ETriggerEvent : uint8
{
  // No significant trigger state changes occurred and there are no active device inputs
  None = 0                UMETA(Hidden),

  // Triggering occurred after one or more processing ticks
  Triggered,              // ETriggerState (None -> Triggered, Ongoing -> Triggered, Triggered -> Triggered)

  // An event has occurred that has begun Trigger evaluation. Note: Triggered may also occur this frame.
  Started,                // ETriggerState (None -> Ongoing, None -> Triggered)

  // Triggering is still being processed
  Ongoing,                // ETriggerState (Ongoing -> Ongoing)

  // Triggering has been canceled
  Canceled,               // ETriggerState (Ongoing -> None)

  // The trigger state has transitioned from Triggered to None this frame, i.e. Triggering has finished.
  // NOTE: Using this event restricts you to one set of triggers for Started/Completed events. You may prefer two actions, each with its own trigger rules.
  // TODO: Completed will not fire if any trigger reports Ongoing on the same frame, but both should fire. e.g. Tick 2 of Hold (= Ongoing) + Pressed (= None) combo will raise Ongoing event only.
  Completed,              // ETriggerState (Triggered -> None)
};
#+end_src

**** Triggers

+ Down :: Trigger fires when the input exceeds the actuation threshold.
  Note: When no triggers are bound Down (with an actuation threshold of > 0) is the default behavior.

+ Pressed :: Trigger fires once only when input exceeds the actuation threshold.
  Holding the input will not cause further triggers.

+ Released :: Trigger returns Ongoing whilst input exceeds the actuation threshold.
  Trigger fires once only when input drops back below actuation threshold.

+ Hold :: Trigger fires once input has remained actuated for HoldTimeThreshold seconds.
  Trigger may optionally fire once, or repeatedly fire.

+ HoldAndRelease :: Trigger fires when input is released after having been actuated for at least HoldTimeThreshold seconds.

+ Tap :: Input must be actuated then released within TapReleaseTimeThreshold seconds to trigger.

+ Chorded :: Applies a chord action that must be triggering for this trigger's action to trigger

*** InputAction

instanced per player

*** Keybindings

=FEnhancedActionKeyMapping=

** =GameInput= for Windows

Built-in after UE5.7

#+begin_src conf
[/Script/GameInputBase.GameInputDeveloperSettings]
#+end_src

*** DUALSHOCK®3 wireless controller (SCPH-98050/CECHZC2)

#+begin_quote
from 0lento
Seems to lose analog triggers on windows but I remember it being like that on directinput too.
#+end_quote

#+begin_src conf
+DeviceConfigurations=(DeviceIdentifier=(VendorId=1356,ProductId=616),Description="DUALSHOCK 3 wireless controller (SCPH-98050/CECHZC2)",bOverrideHardwareDeviceIdString=True,OverriddenHardwareDeviceId="SCPH-98050/CECHZC2",bProcessControllerButtons=True,bProcessControllerSwitchState=False,bProcessControllerAxis=True,ControllerButtonMappingData=((1, "Gamepad_Special_Left"),(2, "Gamepad_LeftThumbstick"),(4, "Gamepad_RightThumbstick"),(8, "Gamepad_Special_Right"),(16, "Gamepad_DPad_Up"),(32, "Gamepad_DPad_Right"),(64, "Gamepad_DPad_Down"),(128, "Gamepad_DPad_Left"),(256, "Gamepad_LeftTrigger"),(512, "Gamepad_RightTrigger"),(1024, "Gamepad_LeftShoulder"),(2048, "Gamepad_RightShoulder"),(4096, "Gamepad_FaceButton_Top"),(8192, "Gamepad_FaceButton_Right"),(16384, "Gamepad_FaceButton_Bottom"),(32768, "Gamepad_FaceButton_Left"),(65536, "Gamepad_Special_Left_X")),ControllerAxisMappingData=((0, (KeyName="Gamepad_LeftX",bIsPackedPositveAndNegative=True)),(1, (KeyName="Gamepad_LeftY",Scalar=-1.000000,bIsPackedPositveAndNegative=True)),(2, (KeyName="Gamepad_RightX",bIsPackedPositveAndNegative=True)),(3, (KeyName="Gamepad_RightY",Scalar=-1.000000,bIsPackedPositveAndNegative=True))),bProcessRawReportData=False,RawReportReadingId=0,RawReportMappingData=())
#+end_src

*** DUALSHOCK®4 wireless controller (CUH-ZCT1)

#+begin_quote
The PS4 DualShock4 controller is actually considered a “Gamepad” type by the low level Game Input API. Because of this, it will actually “just work” if you enable “bProcessGamepad” in your project settings. However, if you want to use the Game Input plugin in conjunction with XInput to get the maximum device support, we would recommend still treating it as a generic “controller” within GameInput.
#+end_quote

#+begin_src conf
+DeviceConfigurations=(DeviceIdentifier=(VendorId=1356,ProductId=1476),Description="DUALSHOCK 4 wireless controller (CUH-ZCT1)",bOverrideHardwareDeviceIdString=True,OverriddenHardwareDeviceId="CUH-ZCT1",bProcessControllerButtons=True,bProcessControllerSwitchState=True,bProcessControllerAxis=True,ControllerButtonMappingData=((1, "Gamepad_FaceButton_Left"),(2, "Gamepad_FaceButton_Bottom"),(4, "Gamepad_FaceButton_Right"),(8, "Gamepad_FaceButton_Top"),(16, "Gamepad_LeftShoulder"),(32, "Gamepad_RightShoulder"),(64, "Gamepad_LeftTrigger"),(128, "Gamepad_RightTrigger"),(256, "Gamepad_Special_Left"),(512, "Gamepad_Special_Right"),(1024, "Gamepad_LeftThumbstick"),(2048, "Gamepad_RightThumbstick"),(8192, "Gamepad_Special_Left")),ControllerAxisMappingData=((0, (KeyName="Gamepad_LeftX",DeadZone=0.239532,bIsPackedPositveAndNegative=True)),(1, (KeyName="Gamepad_LeftY",Scalar=-1.000000,bIsPackedPositveAndNegative=True)),(2, (KeyName="Gamepad_RightX",bIsPackedPositveAndNegative=True)),(3, (KeyName="Gamepad_LeftTriggerAxis")),(4, (KeyName="Gamepad_RightTriggerAxis",DeadZone=0.239532)),(5, (KeyName="Gamepad_RightY",Scalar=-1.000000,bIsPackedPositveAndNegative=True))),bProcessRawReportData=False,RawReportReadingId=0,RawReportMappingData=())
#+end_src

#+begin_quote
from 0lento
#+end_quote

#+begin_src conf
+DeviceConfigurations=(DeviceIdentifier=(VendorId=1356,ProductId=1476),Description="DUALSHOCK 4 wireless controller (CUH-ZCT1)",bOverrideHardwareDeviceIdString=True,OverriddenHardwareDeviceId="CUH-ZCT1",bProcessControllerButtons=True,bProcessControllerSwitchState=True,bProcessControllerAxis=True,ControllerButtonMappingData=((1, "Gamepad_FaceButton_Left"),(2, "Gamepad_FaceButton_Bottom"),(4, "Gamepad_FaceButton_Right"),(8, "Gamepad_FaceButton_Top"),(16, "Gamepad_LeftShoulder"),(32, "Gamepad_RightShoulder"),(64, "Gamepad_LeftTrigger"),(128, "Gamepad_RightTrigger"),(256, "Gamepad_Special_Left"),(512, "Gamepad_Special_Right"),(1024, "Gamepad_LeftThumbstick"),(2048, "Gamepad_RightThumbstick"),(4096, "Gamepad_Special_Left_Y"),(8192, "Gamepad_Special_Left_X")),ControllerAxisMappingData=((0, (KeyName="Gamepad_LeftX",bIsPackedPositveAndNegative=True)),(1, (KeyName="Gamepad_LeftY",Scalar=-1.000000,bIsPackedPositveAndNegative=True)),(2, (KeyName="Gamepad_RightX",bIsPackedPositveAndNegative=True)),(3, (KeyName="Gamepad_LeftTriggerAxis")),(4, (KeyName="Gamepad_RightTriggerAxis")),(5, (KeyName="Gamepad_RightY",Scalar=-1.000000,bIsPackedPositveAndNegative=True))),bProcessRawReportData=False,RawReportReadingId=0,RawReportMappingData=())
#+end_src

*** DUALSHOCK®4 wireless controller (CUH-ZCT2)

#+begin_quote
from 0lento
#+end_quote

#+begin_src conf
+DeviceConfigurations=(DeviceIdentifier=(VendorId=1356,ProductId=2508),Description="DUALSHOCK 4 wireless controller (CUH-ZCT2)",bOverrideHardwareDeviceIdString=True,OverriddenHardwareDeviceId="CUH-ZCT2",bProcessControllerButtons=True,bProcessControllerSwitchState=True,bProcessControllerAxis=True,ControllerButtonMappingData=((1, "Gamepad_FaceButton_Left"),(2, "Gamepad_FaceButton_Bottom"),(4, "Gamepad_FaceButton_Right"),(8, "Gamepad_FaceButton_Top"),(16, "Gamepad_LeftShoulder"),(32, "Gamepad_RightShoulder"),(64, "Gamepad_LeftTrigger"),(128, "Gamepad_RightTrigger"),(256, "Gamepad_Special_Left"),(512, "Gamepad_Special_Right"),(1024, "Gamepad_LeftThumbstick"),(2048, "Gamepad_RightThumbstick"),(4096, "Gamepad_Special_Left_Y"),(8192, "Gamepad_Special_Left_X")),ControllerAxisMappingData=((0, (KeyName="Gamepad_LeftX",bIsPackedPositveAndNegative=True)),(1, (KeyName="Gamepad_LeftY",Scalar=-1.000000,bIsPackedPositveAndNegative=True)),(2, (KeyName="Gamepad_RightX",bIsPackedPositveAndNegative=True)),(3, (KeyName="Gamepad_LeftTriggerAxis")),(4, (KeyName="Gamepad_RightTriggerAxis")),(5, (KeyName="Gamepad_RightY",Scalar=-1.000000,bIsPackedPositveAndNegative=True))),bProcessRawReportData=False,RawReportReadingId=0,RawReportMappingData=())
#+end_src

*** DualSense wireless controller (CFI-ZCT1W)

#+begin_src conf
+DeviceConfigurations=(DeviceIdentifier=(VendorId=1356,ProductId=3302),Description="DualSense wireless controller (CFI-ZCT1W)",bOverrideHardwareDeviceIdString=True,OverriddenHardwareDeviceId="CFI-ZCT1W",bProcessControllerButtons=True,bProcessControllerSwitchState=True,bProcessControllerAxis=True,ControllerButtonMappingData=((1, "Gamepad_FaceButton_Left"),(2, "Gamepad_FaceButton_Bottom"),(4, "Gamepad_FaceButton_Right"),(8, "Gamepad_FaceButton_Top"),(16, "Gamepad_LeftShoulder"),(32, "Gamepad_RightShoulder"),(64, "Gamepad_LeftTrigger"),(128, "Gamepad_RightTrigger"),(256, "Gamepad_Special_Left"),(512, "Gamepad_Special_Right"),(1024, "Gamepad_LeftThumbstick"),(2048, "Gamepad_RightThumbstick"),(8192, "Gamepad_Special_Left")),ControllerAxisMappingData=((0, (KeyName="Gamepad_LeftX",DeadZone=0.239532,bIsPackedPositveAndNegative=True)),(1, (KeyName="Gamepad_LeftY",Scalar=-1.000000,bIsPackedPositveAndNegative=True)),(2, (KeyName="Gamepad_RightX",bIsPackedPositveAndNegative=True)),(3, (KeyName="Gamepad_LeftTriggerAxis")),(4, (KeyName="Gamepad_RightTriggerAxis",DeadZone=0.239532)),(5, (KeyName="Gamepad_RightY",Scalar=-1.000000,bIsPackedPositveAndNegative=True))))
#+end_src

#+begin_quote
from 0lento
#+end_quote

#+begin_src conf
+DeviceConfigurations=(DeviceIdentifier=(VendorId=1356,ProductId=3302),Description="DualSense wireless controller (CFI-ZCT1W)",bOverrideHardwareDeviceIdString=True,OverriddenHardwareDeviceId="CFI-ZCT1W",bProcessControllerButtons=True,bProcessControllerSwitchState=True,bProcessControllerAxis=True,ControllerButtonMappingData=((1, "Gamepad_FaceButton_Left"),(2, "Gamepad_FaceButton_Bottom"),(4, "Gamepad_FaceButton_Right"),(8, "Gamepad_FaceButton_Top"),(16, "Gamepad_LeftShoulder"),(32, "Gamepad_RightShoulder"),(64, "Gamepad_LeftTrigger"),(128, "Gamepad_RightTrigger"),(256, "Gamepad_Special_Left"),(512, "Gamepad_Special_Right"),(1024, "Gamepad_LeftThumbstick"),(2048, "Gamepad_RightThumbstick"),(4096, "Gamepad_Special_Left_Y"),(8192, "Gamepad_Special_Left_X"),(16384, "Gamepad_Special_Left_Y")),ControllerAxisMappingData=((0, (KeyName="Gamepad_LeftX",bIsPackedPositveAndNegative=True)),(1, (KeyName="Gamepad_LeftY",Scalar=-1.000000,bIsPackedPositveAndNegative=True)),(2, (KeyName="Gamepad_RightX",bIsPackedPositveAndNegative=True)),(3, (KeyName="Gamepad_LeftTriggerAxis")),(4, (KeyName="Gamepad_RightTriggerAxis")),(5, (KeyName="Gamepad_RightY",Scalar=-1.000000,bIsPackedPositveAndNegative=True))),bProcessRawReportData=False,RawReportReadingId=0,RawReportMappingData=())
#+end_src

*** DualSense Edge™ wireless controller (CFI-ZCP1)

#+begin_quote
from 0lento
#+end_quote

#+begin_src conf
+DeviceConfigurations=(DeviceIdentifier=(VendorId=1356,ProductId=3570),Description="DualSense Edge wireless controller (CFI-ZCP1)",bOverrideHardwareDeviceIdString=True,OverriddenHardwareDeviceId="CFI-ZCP1",bProcessControllerButtons=True,bProcessControllerSwitchState=True,bProcessControllerAxis=True,ControllerButtonMappingData=((1, "Gamepad_FaceButton_Left"),(2, "Gamepad_FaceButton_Bottom"),(4, "Gamepad_FaceButton_Right"),(8, "Gamepad_FaceButton_Top"),(16, "Gamepad_LeftShoulder"),(32, "Gamepad_RightShoulder"),(64, "Gamepad_LeftTrigger"),(128, "Gamepad_RightTrigger"),(256, "Gamepad_Special_Left"),(512, "Gamepad_Special_Right"),(1024, "Gamepad_LeftThumbstick"),(2048, "Gamepad_RightThumbstick"),(4096, "Gamepad_Special_Left_Y"),(8192, "Gamepad_Special_Left_X")),ControllerAxisMappingData=((0, (KeyName="Gamepad_LeftX",bIsPackedPositveAndNegative=True)),(1, (KeyName="Gamepad_LeftY",Scalar=-1.000000,bIsPackedPositveAndNegative=True)),(2, (KeyName="Gamepad_RightX",bIsPackedPositveAndNegative=True)),(3, (KeyName="Gamepad_LeftTriggerAxis")),(4, (KeyName="Gamepad_RightTriggerAxis")),(5, (KeyName="Gamepad_RightY",Scalar=-1.000000,bIsPackedPositveAndNegative=True))),bProcessRawReportData=False,RawReportReadingId=0,RawReportMappingData=())
#+end_src

*** Xbox One Rock Band 4 Jaguar Guitar

#+begin_src conf
+DeviceConfigurations=(DeviceIdentifier=(VendorId=3695,ProductId=368),Description="The Xbox One rockband jag guitar",bOverrideHardwareDeviceIdString=True,OverriddenHardwareDeviceId="RockbandJagGuitar",bProcessControllerButtons=True,bProcessControllerSwitchState=True,bProcessControllerAxis=False,ControllerButtonMappingData=((1, "Gamepad_Special_Right"),(2, "Gamepad_Special_Left"),(4, "Gamepad_FaceButton_Bottom"),(8, "Gamepad_FaceButton_Right"),(16, "Gamepad_FaceButton_Left"),(32, "Gamepad_FaceButton_Top"),(64, "Gamepad_DPad_Up"),(128, "Gamepad_DPad_Down"),(256, "Gamepad_DPad_Left"),(512, "Gamepad_DPad_Right"),(1024, "Gamepad_LeftShoulder")),ControllerAxisMappingData=(),bProcessRawReportData=True,RawReportReadingId=32,RawReportMappingData=((2, (KeyName="TIlt")),(3, (KeyName="Gamepad_LeftTriggerAxis")),(6, (KeyName="Gamepad_LeftStick_Down",TranslationBehavior=TreatAsButton,ButtonBitMaskMappings=((1, "Gamepad_LeftStick_Down"),(2, "Gamepad_LeftStick_Down"),(3, "Gamepad_LeftStick_Down"),(4, "Gamepad_LeftStick_Down"),(0, "Gamepad_LeftStick_Down"))))))
#+end_src

*** Logitech G920 Racing Wheel

Enable the “Process Racing Wheel” option in your project settings for your desired platform. Then add this device configuration to your INI file:

#+begin_src conf
+DeviceConfigurations=(DeviceIdentifier=(VendorId=1133,ProductId=49762),Description="Logitech G920 Racing Wheel",bOverrideHardwareDeviceIdString=True,OverriddenHardwareDeviceId="RacingWheel",bProcessControllerButtons=True,bProcessControllerSwitchState=True,bProcessControllerAxis=False,ControllerButtonMappingData=((1, "Gamepad_FaceButton_Bottom"),(2, "Gamepad_FaceButton_Right"),(4, "Gamepad_FaceButton_Left"),(8, "Gamepad_FaceButton_Top"),(64, "Gamepad_Special_Right"),(128, "Gamepad_Special_Left"),(256, "Gamepad_RightShoulder"),(512, "Gamepad_LeftShoulder")),ControllerAxisMappingData=(),bProcessRawReportData=False,RawReportReadingId=0,RawReportMappingData=())
#+end_src

** (Deprecated, use =GameInput= instead) Support for =DUALSHOCK®4= on Windows via =RawInput= plugin

*** Enable "Windows RawInput" plugin

*** Add DualShock4 config to =DefaultInput.ini=

#+begin_src conf
[/Script/RawInput.RawInputSettings]
+DeviceConfigurations=(VendorID="0x054C",ProductID="0x05C4",AxisProperties=((Key=Gamepad_RightY,bInverted=True,bGamepadStick=True),(Key=Gamepad_RightX,bGamepadStick=True),(Key=Gamepad_LeftY,bInverted=True,bGamepadStick=True),(Key=Gamepad_LeftX,bGamepadStick=True),(Key=Gamepad_Special_Left_X,Offset=-1.142857),(bEnabled=False,Key=GenericUSBController_Axis6),(Key=Gamepad_RightTriggerAxis),(Key=Gamepad_LeftTriggerAxis)),ButtonProperties=((Key=Gamepad_FaceButton_Left),(Key=Gamepad_FaceButton_Bottom),(Key=Gamepad_FaceButton_Right),(Key=Gamepad_FaceButton_Top),(Key=Gamepad_LeftShoulder),(Key=Gamepad_RightShoulder),(Key=Gamepad_LeftTrigger),(Key=Gamepad_RightTrigger),(Key=Gamepad_Special_Left),(Key=Gamepad_Special_Right),(Key=Gamepad_LeftThumbstick),(Key=Gamepad_RightThumbstick),(Key=GenericUSBController_Button13),(Key=GenericUSBController_Button14),(bEnabled=False,Key=GenericUSBController_Button15),(bEnabled=False,Key=GenericUSBController_Button16),(bEnabled=False,Key=GenericUSBController_Button17),(bEnabled=False,Key=GenericUSBController_Button18),(bEnabled=False,Key=GenericUSBController_Button19),(bEnabled=False,Key=GenericUSBController_Button20)))
+DeviceConfigurations=(VendorID="0x054C",ProductID="0x09CC",AxisProperties=((Key=Gamepad_RightY,bInverted=True,bGamepadStick=True),(Key=Gamepad_RightX,bGamepadStick=True),(Key=Gamepad_LeftY,bInverted=True,bGamepadStick=True),(Key=Gamepad_LeftX,bGamepadStick=True),(Key=Gamepad_Special_Left_X,Offset=-1.142857),(bEnabled=False,Key=GenericUSBController_Axis6),(Key=Gamepad_RightTriggerAxis),(Key=Gamepad_LeftTriggerAxis)),ButtonProperties=((Key=Gamepad_FaceButton_Left),(Key=Gamepad_FaceButton_Bottom),(Key=Gamepad_FaceButton_Right),(Key=Gamepad_FaceButton_Top),(Key=Gamepad_LeftShoulder),(Key=Gamepad_RightShoulder),(Key=Gamepad_LeftTrigger),(Key=Gamepad_RightTrigger),(Key=Gamepad_Special_Left),(Key=Gamepad_Special_Right),(Key=Gamepad_LeftThumbstick),(Key=Gamepad_RightThumbstick),(Key=GenericUSBController_Button13),(Key=GenericUSBController_Button14),(bEnabled=False,Key=GenericUSBController_Button15),(bEnabled=False,Key=GenericUSBController_Button16),(bEnabled=False,Key=GenericUSBController_Button17),(bEnabled=False,Key=GenericUSBController_Button18),(bEnabled=False,Key=GenericUSBController_Button19),(bEnabled=False,Key=GenericUSBController_Button20)))
+DeviceConfigurations=(VendorID="0x054C",ProductID="0x0CE6",AxisProperties=((Key=Gamepad_RightTriggerAxis),(Key=Gamepad_LeftTriggerAxis),(Key=Gamepad_RightY,bInverted=True,bGamepadStick=True),(Key=Gamepad_RightX,bGamepadStick=True),(Key=Gamepad_LeftY,bInverted=True,bGamepadStick=True),(Key=Gamepad_LeftX,bGamepadStick=True),(bEnabled=False,Key=GenericUSBController_Axis7),(Key=Gamepad_Special_Left_X,Offset=-1.142857)),ButtonProperties=((Key=Gamepad_FaceButton_Left),(Key=Gamepad_FaceButton_Bottom),(Key=Gamepad_FaceButton_Right),(Key=Gamepad_FaceButton_Top),(Key=Gamepad_LeftShoulder),(Key=Gamepad_RightShoulder),(Key=Gamepad_LeftTrigger),(Key=Gamepad_RightTrigger),(Key=Gamepad_Special_Left),(Key=Gamepad_Special_Right),(Key=Gamepad_LeftThumbstick),(Key=Gamepad_RightThumbstick),(Key=GenericUSBController_Button13),(Key=GenericUSBController_Button14),(bEnabled=False,Key=GenericUSBController_Button15),(bEnabled=False,Key=GenericUSBController_Button16),(bEnabled=False,Key=GenericUSBController_Button17),(bEnabled=False,Key=GenericUSBController_Button18),(bEnabled=False,Key=GenericUSBController_Button19),(bEnabled=False,Key=GenericUSBController_Button20)))
bRegisterDefaultDevice=True
#+end_src

*** D-pad is recognized as axis, so use blueprint macro for the D-pad input

#+ATTR_HTML: width="400px"
#+ATTR_ORG: :width 400
[[file:./images/dualshock4_rawinput_dpad.webp]]

#+ATTR_HTML: width="700px"
#+ATTR_ORG: :width 700
[[file:./images/dualshock4_rawinput_dpad_macro.webp]]

* Performance & Profiling & Optimization

Early and often, but only optimize after profiling shows problems.

** Profiling in a Build

*** Minimize the noise

+ Turn off everything not using
+ Turn off v-sync
  r.vsync 0

*** Turn off Framerate Smoothing

Project Settings > General Settings > Framerate group

*** Make a Test Build

** Unreal Insights

*** add traces to your own systems

You can also add traces to your own systems to help with diagnosis.

~LLM_SCOPE~ and ~UE_TRACE_LOG~ macros

** Multithreading

*** Task System

*** TaskGraph

** Auto manage attach on particle/audio scene component

auto detach when play finish.

* Unreal Next

** Scene Graph

Scene Graph is a unified structure that connects all the objects in the world.

* Some Modules

** HUD

+ Responsible for drawing in-game UI
  - E.g. Health bar, Ammo counter
+ Simple "immediate mode" API
  - E.g. DrawText, DrawTexture
+ Some simple support for hit boxes
+ No tools for building this UI

** Input

+ Passed in the following order
  - PlayerController
  - Level Blueprint
  - Possessed Pawn

** Collision

+ Line traces (aka raycasts)
+ Geometry sweeps
+ Overlap test
+ In C++ functions are found in UWorld

*** Complex Collision

+ The actual graphics triangles
+ Used for weapons, visibility etc.

*** Simple Collision

+ Set of Box/sphere/capsule/convex
+ Several ways to author (import with mesh, tool on StaticMesh Editor)
+ Used for player movement, physics simulation etc.

*** There is option to "use complex as simple"

E.g. cave interiors

* *Common Gameplay Implementation*

** Cover System

** Aim Assist

+ Slow down when Reticle near target

+ Tracking Reticle when player "attempt" to aim to target

** Weapon Fire

How to handle fire rate and frame rate in shooting game (handle slack between tick/framerate independent fire rate)

Lyra's auto fire RPM is affected by framerate for anyone that doesn't know that. So a smarter setup is needed if you need accurate timings.
Let's say my fps is 100 and my target fire rate is 500 RPM. At 100 fps, the time between frames is 0.1 seconds. 500 RPM converted to sec/round = 60/500 = .12

This is the heart of the problem. If I fire a round and wait .12 seconds the soonest I can do it is after 2 frames (.2 seconds), which results in an inaccurate RPM. The only real solution I can think of is to calculate the slack and offset the next shot, but occasionally you'll still be affected by this at low fps. I'm currently testing batching shots by accumulating the remainders of each frame.

calculate the frame slack between each shot and offset the next shot timer accordingly

*** solution

the way to do it is like this

#+begin_src c
    //Get the timer adjustment for weapon shots
    FORCEINLINE float GetWeaponFireTimerIntervalAdjustment() const { return WeaponFireTimerIntervalAdjust; }

    //Sets the timer adjusment for the shots.
    void SetWeaponFireTimerIntervalAdjustment(float Adjustment) { WeaponFireTimerIntervalAdjust = Adjustment; }

    float        WeaponFireTimerIntervalAdjust;
#+end_src

then you do stuff like

#+begin_src c
    //Retrigger next fire if trigger is automatic
    ScheduleAutomaticRefire(Handle, bFiredCartridge);
#+end_src

#+begin_src c
void ScheduleAutomaticRefire(const FGameplayAbilitySpecHandle& Handle, bool bWeaponFired)
{
    // Next weapon fire time
    const float NextWeaponFireTime = GetAresWeapon()->GetNextWeaponFireTime();

    //We can refire if the weapon fired, and next fire timer is > 0;
    bRefiring = GetAresWeapon()->GetCurrentTriggerModeNum() != 255;

    if (bRefiring)
    {
        const float RefireTime = FMath::Max<float>(NextWeaponFireTime + GetWeaponFireTimerIntervalAdjustment(), SMALL_NUMBER);
        const FTimerDelegate TDel = FTimerDelegate::CreateUObject(this, &ThisClass::RefireWeapon, true, true);
        GetWorld()->GetTimerManager().SetTimer(GetAresWeapon()->GetCurrentTriggerModeNum() == 0 ? PrimaryFireAutomaticFiringHandle : SecondaryFireAutomaticFiringHandle, TDel, RefireTime, false);
        UE_LOG(LogAresWeapon, Verbose, TEXT("Next Automatic Fire: %f"), RefireTime)
        SetWeaponFireTimerIntervalAdjustment(0.f);
    }
}
#+end_src

obvs ignore my custom stuff
RefireWeapon sets the slack

#+begin_src c
    if (bSetTimer)
    {
        const float TimerValue = GetAresWeapon()->GetNextWeaponFireTime();
        const float SlackTimeThisFrame = FMath::Max<float>(0.0f, (GetWorld()->GetTimeSeconds() - GetAresWeapon()->GetLastWeaponFireTime()) - TimerValue);
        SetWeaponFireTimerIntervalAdjustment(GetWeaponFireTimerIntervalAdjustment() - SlackTimeThisFrame);
    }

    TryFire(true);
#+end_src

--------------------------------------

i wrote that 3 years ago

#+begin_src c
void UKaosFireMode_Auto::RefireWeapon()
{
    const float SlackTimeThisFrame = FMath::Max(0.0f, (GetWorld()->GetTimeSeconds() - GetLastShotFireTime()) - GetWeaponROF());
    SetTimerIntervalAdjustment(GetTimerIntervalAdjustment() - SlackTimeThisFrame);

    TryFireWeapon();
}
#+end_src

Trigger Pressed -> TryFireWeapon gets called, then sets the timer using normal ROF time, timer fires and calls RefireWeapon, sets slack for the next timer set, TryFireWeapon is called, Timer is set using ROF adjusted by slack, then the second bit just loops

same timer thing applies to burst shots, each bullet in a burst is a fresh timer adjusted by slack
to make burst shots consistent
it works well till you get to the extremes
like less than 10fps or greater than 600fps (what i tested) below and over them it goes a bit wonky

** Cosmetics System

Attach actors to invisible animated skeleton
- For full mesh
- For individual attachment

* Security

** Anti Cheat

* License

** Unreal Engine EULA and Branding (not for custom license)

- the UE logo at the start of game is *not* mandatory.
- usage of UE Logo need ask Epic Games for permission.
- credit UE in your Credits.

* Math Snippets

** Degrees & Radians

Convert from radians to degrees

#+begin_src cpp
float degrees = FMath::RadiansToDegrees(radians);
#+end_src

And degrees to radians

#+begin_src cpp
float radians = FMath::RadiansToDegrees(degrees);
#+end_src

Check measurement for all these angular functions

e.g. =Sine= used in material construction uses a range of *1*

** Ratios

parametric scale between 0 and 1

#+begin_src cpp
float duration = 5.0f;
float fullyGrown = 75.0f;
float ratio = (currentTime < duration) ? (currentTime / duration) : 1.0f;
float currentGrowth = fullyGrown * ratio;
#+end_src

A general function

#+begin_src cpp
float GetRatio(float value, float minimum, float maximum, bool clamp = true)
{
    if (value > maximum && clamp == tru)
    {
        return 1.0f;
    }
    else if (value > minimum)
    {
        return (value - minimum) / (maximum - minimum);
    }
    else
    {
        return 0.0f;
    }
}
#+end_src

e.g. Sound falloff

#+begin_src cpp
float GetSoundFalloff((float minDistance, float maxDistance, const FVector& soundLocation, const FVector& listenerLocation)
{
    float distance = (soundLocation - listenerLocation).Size();
    float ratio = GetRatio(distance, minDistance, maxDistance);
    float falloff = FMath::Pow(1.0f - ratio, 2.0f);

    return falloff;
}
#+end_src

** Trigonometry

An easing function for a linear ratio (ease In and Out)

#+begin_src cpp
float easedRatio = 1.0f - ((FMath::Cos(linearRatio * PI) * 0.5f) + 0.5f);
#+end_src

#+ATTR_HTML: width="200px"
#+ATTR_ORG: :width 200
[[file:./images/trigonometry_easing_ratio_func.webp]]

Can make noise from =Sine= (oscillator)

e.g. smoke trail

=Tangent= is uncommon in game code, but have a special place in camera code

Unreal use horizontal FOV

#+begin_src cpp
float GetVerticalFOV(float horizontalFOVDegrees, float viewportWidth, float viewportHeight)
{
    float aspectRatio = viewportWidth / viewportHeight;
    float horizontalFOVRadians = FMath::DegreesToRadians(horizontalFOVDegrees);
    float verticalFOVRadians = FMath::Atan(FMath::Tan(horizontalFOVRadians * 0.5f) / aspectRatio) * 2.0f;

    return FMath::RadiansToDegrees(verticalFOVRadians);
}
#+end_src

** Abs & Sign

=FMath::Sign= returns -1, 0, or +1, depending on input value

#+begin_src cpp
float UnitSign(const float x)
{
    return (x >= 0) ? 1 : -1;
}
#+end_src

e.g. produce radians within the 0 to 2\pi range

#+begin_src cpp
float GetNormalizedUnsignedRadians(float x)
{
    x = FMath::Fmod(x, PI * 2.0f * UnitSign(x));

    if (x < 0.0f)
    {
        x = (PI * 2.0f) + x;
    }

    return x;
}
#+end_src

** Pow

Used a lot in game code, most often to shape a linear ratio (easing)

Often replace the use of the more expensive =FRuntimeFloatCurve=

e.g. A HUD indicator, when a new target appears on the screen, with some pop

#+begin_src cpp
float timeToPop = 0.25f;
float ratio = GetRatio(currentTime, 0.0f, timeToPop);
float scale = FMath::Pow(ratio, 0.25f);
#+end_src

=FMath::Pow= only work with positive numbers

This function returns either the positive or negative direction, depending the sign of input

#+begin_src cpp
float NegativePow(float a, float b)
{
    return FMath::Pow(FMath::Abs(a), b) * FMath::Sign(a);
}
#+end_src

** Interpolation

=FMath::Lerp=

Ratio can be greater than 1, but we don't do this often

e.g. Bilinear filter

#+ATTR_HTML: width="200px"
#+ATTR_ORG: :width 200
[[file:./images/lerp_bilinear_filtering_color.webp]]

#+begin_src cpp
FVector3 GetColor(const FVector2& coordinate, const FBitmap& bitmap)
{
    auto cc = coordinate + FVector2(0.5f, 0.5f);
    auto x0 = FMath::Max(0.0f, FMath::FloorToInt(cc.X));
    auto x1 = FMath::Min(bitmap.GetWidth() - 1, FMath::CeilToInt(cc.X));
    auto y0 = FMath::Max(0.0f, FMath::FloorToInt(cc.Y));
    auto y1 = FMath::Min(bitmap.GetHeight() - 1, FMath::CeilToInt(cc.Y));
    auto xr = FMath::Frac(coordinate.X);// FMath::Frac returns the fractional part of value
    auto yr = FMath::Frac(coordinate.Y);// e.g. Frac(7.62) returns 0.62
    auto c0 = FMath::Lerp(bitmap.GetColor(x0, y0), bitmap.GetColor(x0, y1), yr);
    auto c1 = FMath::Lerp(bitmap.GetColor(x1, y0), bitmap.GetColor(x1, y1), yr);

    return FMath::Lerp(c0, c1, xr);
}
#+end_src

** Easing in and out

Ease in, starting slowly before gathering speed

#+begin_src cpp
float EaseIn(float ratio, float easeRate = 2.0f)
{
    return FMath::Pow(ratio, easeRate);
}
#+end_src

#+begin_src octave :results file :exports results :wrap "org\n#+ATTR_HTML: :width 300"
figure( 1, "visible", "off" );

x= linspace(0, 1, 100);
y = x .^ 2;

plot(x, y);
axis([0 1 0 1]);
grid on;
title ("EaseIn");
xlabel ("ratio");
ylabel ("y");

print -dpng ./images/octave-easein.png;
ans = "./images/octave-easein.png";
#+end_src

#+RESULTS:
#+begin_org
#+ATTR_HTML: :width 300
[[file:./images/octave-easein.png]]
#+end_org

Ease out, slowing down to a stop

#+begin_src cpp
float EaseOut(float ratio, float easeRate = 2.0f)
{
    return 1.0f - FMath::Pow(1.0f - ratio, easeRate);
}
#+end_src

#+begin_src octave :results file :exports results :wrap "org\n#+ATTR_HTML: :width 300"
figure( 1, "visible", "off" );

x = linspace(0, 1, 100);
y = 1 - (1 - x) .^ 2;

plot(x, y);
axis([0 1 0 1]);
grid on;
title ("EaseOut");
xlabel ("ratio");
ylabel ("y");

print -dpng ./images/octave-easeout.png;
ans = "./images/octave-easeout.png";
#+end_src

#+RESULTS:
#+begin_org
#+ATTR_HTML: :width 300
[[file:./images/octave-easeout.png]]
#+end_org

Ease both in and out

#+begin_src cpp
float EaseInOut(float ratio, float easeRate = 2.0f)
{
    if (ratio < 0.5f)
    {
        return 0.5f * FMath::Pow(2.0f * ratio, easeRate);
    }
    else
    {
        return 1.0f - (0.5f * FMath::Pow(2.0f * (1.0f - ratio), easeRate));
    }
}
#+end_src

#+begin_src octave :results file :exports results :wrap "org\n#+ATTR_HTML: :width 300"
figure( 1, "visible", "off" );

x1 = linspace(0, 0.5, 100);
x2 = linspace(0.5, 1, 100);

ease_in = @(x) 0.5 * (2 * x) .^ 2 .* ((0<=x) & (x<=0.5));
ease_out = @(x) 1.0 - 0.5 * (2 * (1 - x)) .^ 2 .* ((0.5<=x) & (x<=1));

plot(x1, ease_in(x1));
hold on;
plot(x2, ease_out(x2));
axis([0 1 0 1]);
grid on;
title ("EaseInOut");
xlabel ("ratio");
ylabel ("y");

print -dpng ./images/octave-easeinout.png;
ans = "./images/octave-easeinout.png";
#+end_src

#+RESULTS:
#+begin_org
#+ATTR_HTML: :width 300
[[file:./images/octave-easeinout.png]]
#+end_org

** Time-based Smoothing

e.g. Smoothing camera movement

Often through taking x% of the last frame's value and (100-x)% of this frame's value

Blending from one frame to the next, using interpolation

#+begin_src cpp
float GetYaw(float oldYaw, float targetYaw, float smoothingRatio)
{
    return FMath::Lerp(targetYaw, oldYaw, smoothingRatio);
}
#+end_src

This works fine if the frame rate is _perfectly constant_, we need something to modify the smoothing ratio in concert with that is happening with the frame rate

#+begin_src cpp
float GetSmoothingRatio(float ratio, float deltaSeconds, float authoredFPS = 60.0f)
{
    float timeRatio = deltaSeconds * authoredFPS;// if actual FPS is authored FPS, timeRatio = 1

    if ((ratio > 0.0f) && (timeRatio > 0.0f))
    {
        return FMath::Pow(ratio, timeRatio);
    }

    return ratio;
}
#+end_src

#+begin_src cpp
float GetYaw(float oldYaw, float targetYaw, float smoothingRatio, float deltaSeconds)
{
    return FMath::Lerp(targetYaw, oldYaw, GetSmoothingRatio(smoothingRatio, deltaSeconds));
}
#+end_src

e.g. Trail parameter

#+begin_src cpp
FVector velocity = vehicle->GetComponentVelocity();

Velocity = FMath::Lerp(velocity, Velocity, GetSmoothingRatio(0.8f, deltaSeconds));// Velocity is a member variable of trail class
#+end_src

** Random Number Generation (RNG)

Unreal Engine uses the C runtime =rand= function, you might consider an alternative, the Mersenne Twister algorithm is quite popular.

=FMath::RandRange= used to generate a random number between range

- =int32 RandHelper(int32 Max)=
- =int64 RandHelper64(int64 Max)=
- =bool RandBool()=
- =FVector VRandCone(FVector const& Dir, float ConeHalfAngleRad)=
- =FVector VRandCone(FVector const& Dir, float HorizontalConeHalfAngleRad, float VerticalConeHalfAngleRad)=
- =FVector2D RandPointInCircle(float CircleRadius)=
- =FVector RandPointInBox(const FBox& Box)=

Unreal Engine sets seed from the clock, the RNG is a shared resource

If you want it to be predictable, then call =FMath::RandInit= with a fixed value

=FRandomStream= provide exclusive random numbers, but it's not great, very bad quality in the lower bits. Don't use the modulus (%) operator.

=FRandomFast= is pretty bare bones, but easily extended

Random can produce seemingly non-random numbers quite easily, if not statistically very likely

If you want to avoid repeating numbers, then you might want to develop a random, no repeat feature

You can wrap such a feature into a class for compartmentalized access for a variety of use cases

#+begin_src cpp
class FRandomNoRepeats
{

public:

    int32 LastResult = 0;

    int32 RandRange(int32 minimum, int32 maximum)
    {
        int32 attempts = 0;
        int32 result = FMath::RandRange(minimum, maximum);

        while (result == LastResult && ++attempts < 100)
        {
            result = FMath::RandRange(minimum, maximum);
        }

        LastResult = result;

        return result;
    }
};
#+end_src

Store an instance of this object in your own class like this:

#+begin_src cpp
FRandomNoRepeats GenerateRandom;
#+end_src

And call it like this:

#+begin_src cpp
int32 randomNumber = GenerateRandom.RandRange(0, 10);
#+end_src

** Vectors

*** Dot Product

For normalized vectors

- +1 :: parallel
- 0 :: perpendicular
- -1 :: parallel in opposite direction

#+begin_src cpp
float angle = FMath::RadiansToDegrees(FMath::Acos(dotProduct));
#+end_src

e.g. Determine a point in front of an object facing a given direction?

#+begin_src cpp
bool IsInFront(const FVector& point, const FVector& of, const FVector& direction)
{
    return (FVector::DotProduct(point - of, direction) > 0.0f);// Don't even need to normalize the vector, just need to know if the result is positive
}
#+end_src

e.g. If a vehicle is facing the right direction for a given section of track?

#+begin_src cpp
bool IsFacingForwards(const FVector& vehicleDirection, const FVector& trackDirection, float angleRange)
{
    float dotResult = FVector::DotProduct(vehicleDirection, trackDirection);
    float angleResult = FMath::RadiansToDegrees(FMath::Acos(dotResult));

    return (angleResult < angleRange);
}
#+end_src

e.g. Determine the intersection point between a ray and a plane

#+begin_src cpp
bool RayPlaneIntersection(const FVector& rayOrigin, const FVector& rayDirection, const FVector& planeOrigin,
                          const FVector& planeNormal, FVector& intersection)
{
    float cosAlpha = FVector::DotProduct(rayDirection, planeNormal);

    if (cosAlpha >= 0.0f)
    {
        return false;
    }

    float dotDifference = FVector::DotProduct(planeNormal, planeOrigin - rayOrigin);
    float delta = dotDifference / cosAlpha;

    if (delta < 0.0f)
    {
        return false;
    }

    intersection = rayOrigin + (rayDirection * delta);

    return true;
}
#+end_src

*** Cross Product

e.g. Calculate 3 right-angled vector from one forward vector and one notional up vector

#+begin_src cpp
void GetRightUpVectors(const FVector& forward, FVector& right, FVector& up)
{
    right = FVector::CrossProduct(up, forward);
    right.Normalize();

    up = FVector::CrossProduct(forward, right);
}
#+end_src

** Quaternions

=FQuat=

Use =FQuat::Slerp= to interpolate on hypersphere, guaranteed shortest distance

** Rotators

=FRotator=

Use roll, pitch, yaw in _degrees_, clockwise for positive, anti-clockwise for negative, can be greater than 360 degrees

always between -180 and 180 degrees when converted from a quaternion (normalized)

=FMath::Lerp= takes the shortest distance between two rotations, never interpolates for more than 180 degrees

=FMath::LerpRange= taking the longest route, especially useful for accumulated rotations

=FMath::RInterpTo= interpolates between rotations over time, not as accurate as time-based smoothing, but accurate enough

You can convert a rotator to a vector (from a FVector(1.0f, 0.0f, 0.0f)) pointing in the direction implied by the rotator

e.g. Direction a camera pointing in

#+begin_src cpp
FRotator rotator = camera->GetComponentRotation();
FVector direction = rotator.Vector();
#+end_src

=RotateVector()= method to rotate vector

** Transforms

=FTransform=

Transforming an array of positions like this can be done easily

#+begin_src cpp
TArray<FVector> ProcessPositions(const TArray<FVector>& positions, const FTransform& transform)
{
    TArray<FVector> output;

    for (const FVector& position : positions)
    {
        output.Add(transform.TransformPosition(position));
    }

    return output;
}
#+end_src

=TransformPosition= returns =Rotation.RotateVector(Scale3D * Vector) + Translation=

** Coordinate Spaces

Described by =FTransform=

e.g. Transform from world space into vehicle space

#+begin_src cpp
FTransform vehicleSpace = vehicle->GetActorTransform();// Transform to world space
FVector locationRelativeToVehicle = vehicleSpace.InverseTransformPosition(theObject->GetActorLocation());
#+end_src

e.g. Transform from vehicle space into world space

#+begin_src cpp
FTransform vehicleSpace = vehicle->GetActorTransform();
FVector wheelLocationInWorld = vehicleSpace.TransformPosition(relativeWheelPosition);
#+end_src

** Matrices

=FMatrix=

Unlikely to use them much these days, use =FTransform= instead, 30% faster than =FTransform= to transform a *lot* of vectors

But is good for creating an orientation from a given direction vector and nominal up vector

#+begin_src cpp
void GetRightUpVectors(const FVector& forward, FVector& right, FVector& up)
{
    right = FVector::CrossProduct(up, forward);
    right.Normalize();

    up = FVector::CrossProduct(forward, right);
}

FQuat GetQuaternionFromForwardUp(const FVector& forword, FVector up)
{
    FVector right = FVector::ZeroVector;

    GetRightUpVectors(forward, right, up);

    FMatrix matrix = FMatrix(forward, right, up, FVector::ZeroVector);

    return FQuat(matrix);
}
#+end_src

=InverseTransformPosition= and =InverseTransformVector= using =FMatrix= is *slow*, invert matrix yourself

#+begin_src cpp
FMatrix invMatrix = matrix.Inverse();

localPosition = invMatrix.TransformPosition(position);
#+end_src

=InverseTransformPosition= and =InverseTransformVector= using =FTransform= has no performance penalty

Whereas =FTransform= refers to Translation, =FMatrix= refers to Origin

* Localization

+ FText :: For End User, localization

** FText and LOCTEXT namespace

#+begin_src cpp
#define LOCTEXT_NAMESPACE "Foo"
...
const FText TitleText = LOCTEXT("Title", "WarningMassege"); // same with NSLOCTEXT("Foo", "Title", "WarningMassege")
...
#undef LOCTEXT_NAMESPACE
#+end_src

#+begin_quote
in UE4 localization strings are namespaced (to avoid name collisions with the rest of engine code) and to avoid typing it all the time over and over again in =NSLOCTEXT=, you define =LOCTEXT_NAMESPACE= and use =LOCTEXT= instead _without need of typing in namespace_.
#+end_quote

** Format & Plurals

#+begin_quote
Note: FormatText is NOT free, avoid updating every frame, using delegates and events, or cache the value and apply to UI when it changes.
#+end_quote

https://benui.ca/unreal/ui-localization/

- Blueprint :: =Format Text= node
- C++
  #+begin_src cpp
  FFormatNamedArguments Args;
  Args.Add("GivenNames", GivenNames);
  Args.Add("FamilyName", FamilyName);

  FText FormattedText = FText::Format(
      NSLOCTEXT("MyNamespace", "FullNameFormat", "{GivenNames} {FamilyName}"),
      Args
  );
  // You can also use LOCTEXT() (define a LOCTEXT_NAMESPACE and undefine LOCTEXT_NAMESPACE at the bottom of your cpp file).
  // If you want non-translatable formats, you can use INVTEXT():
  // FText::Format(INVTEXT("Some format {0} Moo"), YourFTextVariable);

  NameLabel->SetText(FormattedText);
  #+end_src

* Accessibility

The design of products, devices, services, vehicles, or environments to be usable by disabled people.

** Overview

User settings should save to cloud.

** UI

*** Larger Chat Text

Large text for communication and accessibility options.

*** High Contrast UI

High Contrast UI for accessibility.

*** Speech to Text Chat (English Only)

Send speech as text to group

*** Text to Speech Chat (English Only)

Convert text chat input to speech.

*** Menu Narration

*** Message Alert

Enable this feature to play a sound when a message in received.

** Color Blind Mode

*** Deuteranopia

*** Tritanopia

*** Protanopia

** Photosensitive Eepilepsy (PSE)

*** Warning

*** Design

** Arachnophobia

** Streamer Mode

Allows users to hide certain information while streaming to protect their privacy and reduce distractions

* *Tips and Tricks*

** Unreal Project Structure

- Binaries(gitignore) :: compile output
- Config :: config files
- Content :: game asset and blueprints
- DerivedDataCache(gitignore) :: platform specified optimized asset
- Intermediate(gitignore) :: temporary files
  - Intermediate files for Build(.obj, precompiled header)
  - .generate.h/.cpp file generated by UHT prepossessing
  - VS.vcxproj file, Shader compiled via .uproject
  - AssetRegistryCache, cache for Asset Registry system, an index for asset
- Saved(gitignore) :: for save, log, info files
- Source :: source code

** Boolean or uint8:1

#+begin_src cpp
// only uses 1 bit
uint8 bCanBeDamaged:1;

// Can have UPROPERTY(), but uses 1 byte (= 8 bit)
bool bCanBeDamaged;
#+end_src

** Git usage

- Git LFS

  #+begin_src shell
  git lfs install
  #+end_src

** Blueprint

*** debug

+ Collision visibility
Details -> Rendering -> Hidden in Game
+ Trace visibility
  Draw debug type
+ Vector Variable
  Details -> Variable -> Instance Editable & Show 3D Widget

*** keep wire nice and tight when Event is far way from Bind Event node

#+ATTR_HTML: width="380px"
#+ATTR_ORG: :width 380
[[file:./images/event_dispatchers_wire_management.webp]]

*** Collapse (select nodes then right click)

+ Collapse Nodes
+ Collapse to Function
  when external objects need to call
+ Collapse to Macro

*** ray-cast channel

Details panel -> Collision -> change Collision Preset to "Custom" -> Ignore all response then select what you need

*** frame delay

It is used to initialize/load some variables/objects/references that has not been initialized in this frame. Sometimes in UE4 objects need to go the 2nd or 3rd iteration to get fully loaded. Sometimes you need to get much longer delays to make sure that it is all loaded.

- Double frame delay (To next frame)
  ->Delay(Duration 0)->Delay(Duration 0)->

*** Show Blueprint Access Specifier

[[file:./images/show_blueprint_access_specifier.webp]]

or in =Config/DefaultEditorPerProjectUserSettings.ini= (project-wise) or =Saved/Config/WindowsEditor/EditorPerProjectUserSettings.ini= (personal)

#+begin_src conf
[/Script/BlueprintGraph.BlueprintEditorSettings]
bShowAccessSpecifier=True
#+end_src

*** Align notes

Select nodes and use Shift+W/A/S/D

** Scale something to 0 hide it

** *Procedural Animation*

** Vertex Shader or Skeletal Mesh

#+begin_comment
Vertex Shader may improve performance, but it cannot affect physics.

A couple of notes and caveats on this:
Vertex shaders do not update mesh normals, so this only works for translation. This is also not an adequate workflow for animators if you are doing interacting reloads.
There is a lot of optimizations you can make on skeletal meshes to reduce the cost.
Static mesh bounds, update rate optimizations, visibility tick and manual ticking (not ticking the weapon when is not moving), as well as lod settings inside anim graphs can help a lot to bring the cost down. GPU skinning if you are not already using it makes skeletal meshes way more efficient.

This is still an important technique to keep in mind.

You can also get rotations and manually adjust normals. For anything more complex than a transform or rotation as seem here you can use Vertex Animation Textures, and can bake the per frame vertex positions and normals into an image. But yeah, just another tool in the box.

Would it make sense to have a relatively simple skeletal mesh with static meshes attached to it, like they did with the ancient in the valley of the ancients demo? Or are you still losing performance due to there being a skeletal mesh?

In some cases it might be, like the ancient. It had so many polygons that it probably would've been impossible to do real time with a skeletal mesh. However, multiple static meshes are usually going to incur multiple draw calls.
I think it could go either way.
#+end_comment

** Outlines

"Real-Time Rendering"

*** Shading Normal Contour Edges

*** Procedural Geometry Silhouetting

*** Edge Detection by Image Processing

*** Geometric Contour Edge Detection

** Lighting Techniques & Guides

** Anti-Ghosting with Temporal Anti-Aliasing (TAA)

Project Settings->Engine - Rendering->Optimizations->Check "Output velocities due to vertex deformation"

+ Uncheck "Output velocities during base pass" before toggle that
+ This incurs a performance cost and can be quite significant if many object are using World Position Offset

** Tweak for Temporal Anti-Aliasing (TAA)

#+begin_src
r.TemporalAACurrentFrameWeight 0.2
r.TemporalAASample 4
r.Tonemapper.Sharpen 0.5
#+end_src

** Boobs Physics, NPR Hair/Cloth Physics, Chain, Slime, Jelly

bouncy and squishy

*** Soft Body

*** AnimDynamics

*** Physics Constraints

*** Niagara Iterative Constraints

*** Kawaii Physics

*** Physics Driven Bones

** Build and Run from Command-Line

On Windows

*** Build

+ Editor
#+begin_src shell
"Path/to/Engine/Build/Batchfiles/Build.bat" GameName(ProjectEditor) PlatformName(Win64) ConfigurationName(Development) "Path/to/Project/Project.uproject" -waitmutex -NoHotReload
#+end_src
+ Cooked Content
#+begin_src shell
"Path/to/Engine/Build/Batchfiles/Build.bat" GameName(Project) PlatformName(Win64) ConfigurationName(Development) "Path/to/Project/Project.uproject" -waitmutex -NoHotReload
#+end_src

*** Run

+ Editor
#+begin_src shell
"Path/to/Engine/Binaries/Win64/UnrealEditor.exe" "Path/to/Project/Project.uproject" -log
#+end_src
+ Standalone
#+begin_src shell
"Path/to/Engine/Binaries/Win64/UnrealEditor.exe" "Path/to/Project/Project.uproject" -game -log -windowed -resx=1280 -resy=720
#+end_src
#+begin_src shell
"Path/to/Project/Binaries/Win64/Project.exe" -game -log -windowed -resx=1280 -resy=720
#+end_src

*** Batch Script

Put these batch files together with the project folder

+ vars.bat
#+begin_src bat
@echo off

REM The %~dp0 specifier resolves to the path to the directory where this .bat is located in.
REM The :~0,-1% will strip the trailing slash from that path
set ROOTDIR=%~dp0
set ROOTDIR=%ROOTDIR:~0,-1%

set PROJECT=ProjectName
set PROJECT_DIR=%ROOTDIR%\%PROJECT%
set UPROJECT_PATH=%PROJECT_DIR%\%PROJECT%.uproject

set UE_DIR=C:\Program Files\Epic Games\UE_5.0
set UEEDITOR_EXE=%UE_DIR%\Engine\Binaries\Win64\UnrealEditor.exe
set BUILD_BAT=%UE_DIR%\Engine\Build\Batchfiles\Build.bat
#+end_src
+ build.bat
#+begin_src bat
@echo off

call %~dp0\vars.bat

call "%BUILD_BAT%" %PROJECT%Editor Win64 Development "%UPROJECT_PATH%" -waitmutex -NoHotReload
#+end_src
+ editor.bat
#+begin_src bat
@echo off

call %~dp0\vars.bat

start "" "%UEEDITOR_EXE%" "%UPROJECT_PATH%" %*
#+end_src
+ Use
#+begin_src shell
build && editor -log
#+end_src

** Unresolved external error

There 3 most common reasons why can have Unresolved External Symbols linker error:

- You declared non-virtual function (standard function) but you didn’t define code for it
- The function is in different module and you didn’t add dependency of that module in build script (*.build.cs file)
- Class you trying to use is declared as MinimalAPI or missing extern (=MODULENAME_API= macro) and can not be used outside of it’s module (in this case you would need to modify engine and rebuild it, possible for game projects no go for plugins)

Number 2 and 3 are UE4 specific, related to UE4 build system and it’s configuration.

** Ternary Operator(?:) with TObjectPtr

TObjectPtr is for UProperty, so if we use raw pointer and TObjectPtr with ternaries, it get a compile error.

The solution is add a =.Get()= to TObjectPtr.

#+begin_src cpp
APawn* pawn = Condition() ? RawPointerPawn : TObjectPtrPawn.Get();
#+end_src

#+begin_quote
from siliex: Ternaries are a bit weird because they need to infer what type they return from two places.
The issue is that you're technically returning two types from the ternary (which is a big no-no).
The ternary can actually handle that situation because there's an implicit conversion from TObjectptr -> normal pointer... but there's also one from normal pointer -> TObjectPtr.
So it has two equally valid choices and gives up.
#+end_quote

** Micro-optimizations

- =FVector::Distance()= is slightly faster than =(a-b).Size()=.

** Disable permutations you don't need

- Disable =Shadowmaps= and =DBuffer decals= on pure real-time illumination games.

** Advanced Renamer Plugin

** IsValid checks the UObject's flags for validity in addition to nullptr

a UObject can be non-null but still in an invalid state.

Always use =IsValid= when checking UObject validity.

it has nothing to do with the container you store the ptr in, raw, TOP, weak, soft, etc.

it has to do with the UObject itself having flags such as being marked pending kill where it should be dead but the GC hasn't released the memory yet, so you can get UB.

#+begin_src cpp
if (Object) // bad
if (IsValid(Object)) // good

UObject* object = GetValid(FooBar); // if you need if-init use GetValid (return the object ptr when valid)
#+end_src

#+begin_quote
though weak will return null for pending kill objects by default.
Blueprint Cast has a valid check, the blueprint pure version cast has no.
#+end_quote

** Remove Starter Content and Stop Auto Add

remove related startup action in =Config/DefaultGame.ini=

#+begin_src conf
bAddPacks=True
InsertPack=(…)
#+end_src

** The project doesn't showing on project browser

Unreal editor only show project under =Documents\Unreal Projects= by default.

How to fix it:

- (easy way) Create new project to the same parent directory of your project.

or

- add new path to =%LOCALAPPDATA%\UnrealEngine\5.4\Saved\Config\WindowsEditor\EditorSettings.ini=

#+begin_src conf
[/Script/UnrealEd.EditorSettings]
CreatedProjectPaths=E:/YourNewPath
#+end_src

** To show errors and warnings on HUD

in =Config/DefaultEngine.ini=:

#+begin_src conf
[/Script/Engine.Engine]
DurationOfErrorsAndWarningsOnHUD=3.0
#+end_src

** Show BP Script Call Stack on Warnings

in =Config/DefaultEngine.ini=:

#+begin_src conf
[Kismet]
ScriptStackOnWarnings=true
#+end_src

** Hide C++ comment in editor

#+begin_src cpp
// This comment show in editor.
//~ This comment won't show in editor.
UPROPERTY()
bool bFooBar;

/*~
 * This also hide in editor.
 */
#+end_src

** Copy pose with 1 frame lag

Tick Dependency

** Access private member

=UE_DEFINE_PRIVATE_MEMBER_PTR=

** You can use Emoji in Blueprint

Use comment box with large font size to hold an emoji.

** What's the difference between =WITH_EDITORONLY_DATA= and =WITH_EDITOR=?

use the DATA version only to wrap UPROPERTIES, as well as any code that uses those properties. use the plain one for everything else (functions, other code, non-UHT data members, etc)

** Function name

=__FUNCTIONW__= for MSVC, =__PRETTY_FUNCTION__= for clang (can use =#if (MSC_VER)= and =#if (__clang__)=

** Video/Emissive material is Blur or color is incorrect in level

add holdout composite component, to pass TSR and tone mapping

** UHT Error: C++ Default parameter not parsed

When UHT says UFUNCTIONs can't have default initialized parameter (e.g. arrays) in their signatures, you can have a non-UFUNCTION function that has the default initialized array (~TArray<int32> MyArray = {}~) and then have a UFUNCTION (K2_ version) that calls the C++ version with the =AutoCreateRefTerm= specifier which allows you to not hook up a pin in BP and it will get a default initialized array like so:

#+begin_src cpp
UFUNCTION(BlueprintCallable, meta=(AutoCreateRefTerm="MyArray"))
K2_MyFunction(TArray<int32> MyArray);
#+end_src

This is also useful for a reference parameters that can have a sensible default value instead of requiring a valid input.

* Traps and Pitfalls

** Asset Conditional Pipeline

Mesh imported to UE will be *Triangulate*

** binding a delegate (especially dynamic) in constructor or getting loaded from serialized data

ctor delegate binding are problematic, UPROPERTY delegates get serialized.

best to do it in ~BeginPlay()~, ~PostInitProperties()~ or ~PostInitializeComponents()~ (Actor only).

If you made any blueprints based on this C++ class, you may need to recreate them if you bound delegates in the constructor, otherwise the delegates can be saved into the BP itself and the problems will persist.

doing delegate binds/adddynamic in constructor is a trap, need to guard CDO as dynamic delegate will be serialized into asset and load wrong pointer afterwards on instances

It might be a bit less of an issue with non-dynamic delegates since I don't think they get serialized like dynamic delegates do, but there are some other things that happen like constructors being ran for CDOs and things that live only in editor so you'd probably want to avoid binding them there in any case.

Constructors are usually a bad place because then your CDO will be binding to them, your CDO shouldn't be responding to events in 99.999% of cases.

** Make Blueprint subclass Data asset to only store data (without any logic)

The BP subclassed DAs (blue) instead of DA instances (red), blue DAs won't even be discovered by the AssetManager by default

if they're primary data asset they will have proper label

AM type entry must have Has Blueprint Classes checked, even if it implements label

** Pointers to uobjects should be UPROPERTY

Pointers to uobjects should be UPROPERTY by default unless you have a reason for them not to be. UPROPERTY raw/TObjectPtr is a strong reference that will keep the object alive when the GC runs.

If you don't want to contribute to forcing it to be alive, TWeakObjectPtr<T>
This is useful if you want to hold a ref for the purpose of observing but not managing the lifetime.

If you don't need reflection to know about them or you want to make a weak tobjectptr/raw ptr
Reflection needs to know about them if you want serialization, BP, etc
Otherwise they live only in C++ land

** TMap

*** Use pointer as key

ptr as key can have UB because potentially multiple nullptr keys,

Probably want to use FObjectKey/TObjectKey.

** Lyra

- one of the more heinous things lyra does is storing Editor time constants in a DA they sync load instead of a UDeveloperSettings

#+begin_quote
binding dynamic delegates in ctor
fsoftclasspath for data assets
sync loading everywhere
global settings DA instead of udevsettings in some places
not accounting for slack with ranged weapons (higher framerate = higher firerate)
animation based weapon timers
sync loaded weapons (no data assets or asset manager, just sync loading BPs for maximum hitching)
I could go on
gameplay affecting animnotifies

if using timers or animations (would be insanely annoying to implement with animations) you need to observe the delta between your ideal timing and the actual timing of the last 2 shots
aka the slack
timers will "bunch up" if a frame hangs and they miss their timing and fire all at once or just desynced from your ideal firerate
you need to maintain your ideal RPM vs actual RPM and adjust every shot
#+end_quote

** Asset management

DT for asset management is troll. DR makes it possible, but you should really be using PDA/AM

** Why my component empty in the blueprint detail panel / see duplicate components on your Actor BPs, phantom properties / components that won’t go away even after they are removed / blueprint unexpected behavior

[[https://hotreloadsucks.com/][Stop Live Coding: The broken promise of a Unity-like workflow in Unreal]]

you likely corrupted your blueprint, possible through using hot reload/live coding with reinstancing on

#+begin_quote
Duplicate components can be potentially fixed with Duroxxigar/ComponentPointerFixer plugin
#+end_quote

also the second thing is relevant, Edit UPROPERTY specifiers should not be used for the component reference

You don't want edit specifiers on ptrs to subobject, Always BlueprintReadOnly, VisibleAnywhere

you have Edit specifier with default subobject created by CreateDefaultSubobject, thats a bug mine with components. must be Visible.

#+begin_quote
UObject outer can be anything, ActorComponent outer has to be always Actor
DetailsView handles components in the same way as uobject without any distinction
so if a Component with Edit specifier is being edited - it is treated as a common instanced UObject instead of Component which affects many things
#+end_quote

** Timer are frame rate dependent (also Tick())

timers are frame rate dependent
but a 30 second timer will always be nearly 30 seconds
but can be off by a very small margin
as timermanager tracks the delta between the last time it was checked, and works out if its close to its elapsed time, so its only going to be off in the order of .1 or less

timers have an issue of increasing/decreasing due to framerate,
so if someone firing a gun at 60fps but it drops to 30fps, gun will fire slower

actually, I'd say the reason ticks are preferred at that point is because ticks are the default anyway, there's zero benefit to using a short looping timer.

Timers can run multiple times each frame if they're too fast. For example if you happen to run that function at 120 fps and get 0.008333, and you start a timer for that, and then walk to a new area in the game and your FPS drops to 60. You're now uselessly running the same function twice every frame.

If you have stuff that needs to update every frame, you have stuff that needs to happen every frame. I see people avoiding tick by doing stuff like putting stuff on timers near the framerate. And it's no better, even worse really since a timer can actually fire twice in one frame and run the function twice if it's faster than the framerate. For instance, stuff like line traces to detect what the player is looking at, those can easily go on timers for like ten to fifteen times a second, they don't need to happen every frame. Where as input checks can start to feel laggy to a player if they're not checked often, that's why Axis events run at the speed of the framerate as well.

#+begin_quote
#+end_quote

use =t.UnsteadyFPS 1= to test

=Tick()= runs every frame, you can simply use =DeltaSeconds= to correct your time based value (e.g. MoveSpeed),
=DeltaSeconds= is the slack time since last frame, so for a stable frame rate, =DeltaSeconds= = 1 / FPS(frame rate per second), hence =DeltaSeconds= * FPS = 1 second,
If you have a time based action in tick (e.g. move per tick), you can time you speed with =DeltaSeconds= to get a correct speed.

** Timer and custom time dilation

#+begin_quote
If you’re using a timer call the logic, custom time dilation will not affect the timers speed. Timers are subject to global time dilation though. Also, why would running a rotation update tick be to performance heavy. Is there going to be 10000 towers ticking at once? Don’t feel the need to over optimize simple things. Using an event tick with a rInterp to calculate the rotation should be fine.

And will be subject to both global and custom time dilation
#+end_quote

** Blueprint Struct

Don't use it. Some function might not work properly (e.g. =Add data table row=).

#+begin_quote
Tips:
You can right click your Blueprint Struct and select =Preview Equivalent C++ Header= to get a C++ version struct body.
#+end_quote

blueprint structs are assets. they do not have any kind of inheritance
they are completely own system that you can't force into cpp as they exist purely in blueprint

if you use and change blueprint struct, restart editor after adding variable.
when it ask you to resave blueprints using this struct, click dont save
otherwise dirty work of rmb on all nodes using this struct and refresh, reconnect shit

one common error is structure is unknown and gives your packaging errors, rename the struct might *temporary* fix it, but revert all the values to default.

#+begin_quote
Blueprint enum is not that bad, but you better avoid use it too due to same reason,
declare in C++ or use gameplay tag.
#+end_quote

** Multiplayer Soft Ref Class Spawn Actor

if the server load the class and replicate to client, client will *sync* load the class if its not loaded.

** Audio thread isn't running in editor (because assets are read-write)

access listener (audio thread variable) from game thread might works fine in Editor build, but non-editor build has different behavior.

#+begin_quote
from AaronMcLeran

Confusingly, IsInAudioThread() will return true in the editor as the audio thread is the game thread in editor.

Issue with supporting it in a packaged game is the audio thread makes all that not thread safe. You'd have to totally rearchitect how all that works (and it'd look like metasounds). But in the editor, the audio thread isn't running, so all it took was to juggle a couple things around to get it to work... no need to create proxies and to shovel a bunch of data around thread-safely, etc. Sound Attenuation, the struct/settings, actually predates the existance of the audio thread. If it was done today, it'd be architected fundmantally to be thread safe and dynamic. Don't worry though, we will eventually get all these features as first-class citizens of the MetaSound world -- think in terms of interfaces, polyphony, in-graph spatialization features, MetaSound effects, etc. We have a saying on the team... it's all going to be "MetaSounds all the way down".

it works in-editor cause it's in the game thread
but in a packaged game, it runs with an audio thread
there's no current way to automatically detect param changes, then do the appropriate shuttle to the audio thread about your change
it's a HUGE problem
when we made the audio thread
and is why we tell people to treat audio data as read-only
via BP
there is a new UProperty feature that allows you to markup properties to get an automatic delegate on property change
so we can get a function call to then move the parameter change to the audio thread
but that's not hooked up yet to attenuation settings and audio component params
if you have some programmers, tell them they need to hook up some code that pushes these changes to the audio thread
i'd do it via BP functions vs setting properties directly
also, a work-around would be to make sure the sound isn't playing before you set the params
like, if you set the attenuation on an audio component, THEN play, the audio component should pick up the attenuation settings when it starts to play
but once the sound is playing, it won't get param changes unless you explicitly call a BP function, which does the appropriate game-thread-to-audio-thread message
does this make sense?
#+end_quote

#+begin_quote
They are, the Audio Thread contains references to UObjects and must wait for the GT to complete its Garbage Collection phase.
But as I understand it, it is parallel.
UObjects are not thread-safe off the Game Thread.
#+end_quote

* Third-party Projects

** =UE5Coro= - Coroutine in Unreal Engine

*** Latent

**** Timeline

***** Timeline cancel

#+begin_src


#+end_src

***** Timeline ease

#+begin_src cpp
co_await UE5Coro::Latent::Timeline(this, 0, 1, 0.5, [&](double Alpha)
{
    const double Value = UKismetMathLibrary::Ease(ValueStart, ValueEnd, Alpha, Easing);
    // ...
});
#+end_src

*** Awaitable

- awaiter
  responsible for resuming the coroutine =co_await= for it
- TCoroutine<T>

*** Generator

Wrapper of coroutine handle

Return (=co_yield=) arbitrary number of values without end then function

**** Iterate template

#+begin_src cpp
#include "UE5Coro.h"

using namespace UE5Coro;

template <std::derived_from<FEquipmentFragmentBase> FragmentType = FEquipmentFragmentBase>
static TGenerator<FConstStructView> IterateFragments(const FEquipmentFragmentContainer& container)
{
    if (not container.IsValid())
    {
        co_return;
    }

    for (const auto& [key, value] : container.EquipmentFragments)
    {
        if (value.IsValid() && value.GetScriptStruct()->IsChildOf(TBaseStructure<FragmentType>::Get()))
        {
            co_yield FConstStructView::Make(value.Get());
        }
    }
}
#+end_src

Use

#+begin_src cpp
for (auto entry : FEquipmentFragmentContainer::IterateFragments<T>(EquipmentFragmentContainer))
{
    return entry;
}
#+end_src

** =Flassari/CommonValidators= - Collection of validators that are useful for all projects.

** =KawaiiPhysics= - pseudo-physics plugin to create simple and cute animations for objects like hair, skirts, and breasts.

* Unreal-specific Terminologies

- dynamic :: dynamic is epic's weird way of saying it is serializable (text based). only serializable stuff works with blueprint. so, yeahs. Dynamic are serializable, aside from BP support that's the only reason to use them.

* Style Guide

** Asset Naming Convention

=Prefix_BaseAssetName_Variant_Suffix=
[[https://dev.epicgames.com/documentation/en-us/unreal-engine/recommended-asset-naming-conventions-in-unreal-engine-projects]]

[[https://github.com/Allar/ue5-style-guide]]

| Asset Type            | Prefix | Suffix |
|-----------------------+--------+--------|
| Texture               | T_     |        |
| Material              | M_     |        |
| Material Instance     | MI_    |        |
| Material Function     | MF_    |        |
| Material Layer        | ML_    |        |
| Post Process Material | PPM_   |        |
| Static Mesh           | SM_    |        |
| Skeleton Mesh         | SK_    |        |
| Skeleton              | SKEL_  |        |
| Animation Sequence    | AS_    |        |
| Montages              | AM_    |        |
| Animation Blueprint   | ABP_   |        |
| Physics Asset         | PHYS_  |        |
| Physics Material      | PM_    |        |
| Blueprint             | BP_    |        |
| Blueprint Interface   | BI_    |        |
| Actor Component       | AC_    |        |
| Widget Blueprint      | WBP_   |        |
| Input Action          | IA_    |        |
| Input Mapping         | IMC_   |        |
| Niagara Emitter       | FXE_   |        |
| Niagara System        | FXS_   |        |
| Niagara Function      | FXF_   |        |

** Editor Asset Color

| Type                       | FColor        | Hex     |
|----------------------------+---------------+---------|
| Blueprint                  | 63, 126, 255  | #3F7EFF |
| Widget Blueprint           | 44, 89, 180   | #2C59B4 |
| Gameplay Ability Blueprint | 0, 96, 128    | #006080 |
| Level                      | 255, 156, 0   | #FF9C00 |
| Input Action               | 127, 255, 255 | #7FFFFF |
| Input Mapping Context      | 255, 255, 127 | #FFFF7F |
| Data Asset                 | 201, 29, 85   | #C91D55 |
| Data Table                 | 62, 140, 35   | #3E8C23 |
| Anim BP                    | 200, 116, 0   | #C87400 |
| Anim Montage               | 100, 100, 255 | #6464FF |
| Anim Sequence              | 80, 123, 72   | #507B48 |
| Blend Space                | 255, 168, 111 | #FFA86F |
| Static Mesh                | 0, 255, 255   | #00FFFF |
| Skeleton                   | 105, 181, 205 | #69B5CD |
| Skeletal Mesh              | 241, 163, 241 | #F1A3F1 |
| Actor                      | 0, 232, 0     | #00E800 |
| Curve                      | 78, 40, 165   | #4E28A5 |
| Texture                    | 192, 64, 64   | #C04040 |
| Material                   | 64, 192, 64   | #40C040 |
| Material Instance          | 0, 128, 0     | #008000 |
| Material Function          | 0, 175, 175   | #00AFAF |
| Physical Material          | 200, 192, 128 | #C8C080 |
| Physics Asset              | 255, 192, 128 | #FFC080 |
| Niagara System             | 1, 202, 252   | #01CAFC |
| Niagara Emitter            | 241, 99, 6    | #F16306 |
| Niagara Script             | 255, 255, 0   | #FFFF00 |
| MetaSound Source           | 103, 214, 66  | #67D642 |
| MetaSound Patch            | 31, 133, 31   | #1F851F |
| Behavior Tree              | 149, 70, 255  | #9546FF |
| Blackboard                 | 201, 29, 85   | #C91D55 |
| State Tree                 | 201, 185, 29  | #C9B91D |

#+begin_quote
sRGB To Linear: Color > 0.04045 ? pow( Color * (1.0 / 1.055) + 0.0521327, 2.4 ) : Color * (1.0 / 12.92);
#+end_quote

* Some Plugins

** Gameplay Message Router

A subsystem that allows registering for and sending messages between unconnected gameplay objects.

*** Update UI without cast to character

* Blender

** Blender Tools

[[https://github.com/EpicGames/BlenderTools]]

*** Send to Unreal

**** Setup

+ Install the add on in Blender and activate it
+ Enable _Editor Scripting Utilities_ and _Python Editor Script Plugin_ Plugin
+ Go to Edit > Project Settings, search for 'python' and then enable remote execution
+ (Option) Go to Edit > Editor Preferences, search for 'CPU',  then under Editor Performance disable _Use Less CPU when in Background_.
  That way unreal continues to update even when it is not the active application. Now the Blender and Unreal UI will update at the same time and you will see your changes update without having to click on Unreal.

*** UE to Rigify

**** Setup

+ Make sure that the _Rigify_ addon is active.
+ Install the add on in Blender and activate it

** Export FBX

+ Path Mode :: Copy (check Embed Textures)
+ Geometry > Smoothing :: Edge (to avoid warnings)
+ Armature :: uncheck Add Leaf Bones

** Bone Orientation

Unreal work with joint, but blender work with bones (a bone with start joint and the end leaf joint, leaf joint ignored in unreal engine)

Select bones > Clear Parent (Alt+P) > Disconnect Bone > Rotate bones by individual origins

# Local Variables:
# jinx-local-words: "AActor BP UObject rigify"
# End:
